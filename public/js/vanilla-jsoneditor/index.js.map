{"version":3,"file":"index.js","sources":["../node_modules/svelte/src/version.js","../node_modules/svelte/src/internal/disclose-version.js","../node_modules/svelte/src/internal/flags/index.js","../node_modules/svelte/src/constants.js","../node_modules/esm-env/false.js","../node_modules/svelte/src/internal/client/constants.js","../node_modules/svelte/src/internal/shared/utils.js","../node_modules/svelte/src/internal/client/dom/task.js","../node_modules/svelte/src/internal/client/reactivity/equality.js","../node_modules/svelte/src/internal/client/proxy.js","../node_modules/svelte/src/internal/client/errors.js","../node_modules/svelte/src/internal/client/reactivity/sources.js","../node_modules/svelte/src/internal/client/runtime.js","../node_modules/svelte/src/internal/client/reactivity/deriveds.js","../node_modules/svelte/src/internal/client/dom/hydration.js","../node_modules/svelte/src/internal/client/dom/operations.js","../node_modules/svelte/src/internal/client/reactivity/effects.js","../node_modules/svelte/src/internal/shared/errors.js","../node_modules/svelte/src/internal/client/context.js","../node_modules/svelte/src/utils.js","../node_modules/svelte/src/internal/client/dom/elements/misc.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js","../node_modules/svelte/src/internal/client/dom/elements/events.js","../node_modules/svelte/src/internal/client/dom/reconciler.js","../node_modules/svelte/src/internal/client/dom/template.js","../node_modules/svelte/src/internal/client/render.js","../node_modules/svelte/src/internal/client/dom/blocks/if.js","../node_modules/svelte/src/internal/client/dom/blocks/key.js","../node_modules/svelte/src/internal/client/dom/blocks/each.js","../node_modules/svelte/src/internal/client/dom/blocks/html.js","../node_modules/svelte/src/internal/client/dom/blocks/slot.js","../node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js","../node_modules/svelte/src/internal/client/dom/elements/actions.js","../node_modules/clsx/dist/clsx.mjs","../node_modules/svelte/src/internal/shared/attributes.js","../node_modules/svelte/src/internal/client/dom/elements/class.js","../node_modules/svelte/src/internal/client/dom/elements/style.js","../node_modules/svelte/src/internal/client/dom/elements/attributes.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/input.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/props.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/select.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/this.js","../node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js","../node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../node_modules/svelte/src/internal/client/dom/legacy/misc.js","../node_modules/svelte/src/index-client.js","../node_modules/svelte/src/internal/client/reactivity/store.js","../node_modules/svelte/src/internal/client/reactivity/props.js","../src/lib/utils/debug.ts","../src/lib/utils/uniqueId.ts","../src/lib/utils/numberUtils.ts","../src/lib/utils/typeUtils.ts","../src/lib/utils/arrayUtils.ts","../src/lib/utils/jsonUtils.ts","../src/lib/types.ts","../src/lib/utils/domUtils.ts","../src/lib/utils/navigatorUtils.ts","../src/lib/utils/keyBindings.ts","../node_modules/style-inject/dist/style-inject.es.js","../src/lib/components/modals/popup/AbsolutePopupEntry.svelte","../src/lib/components/modals/popup/AbsolutePopup.svelte","../src/lib/utils/stringUtils.ts","../src/lib/plugins/query/jsonQueryLanguage.ts","../node_modules/svelte-awesome/package/components/svg/Raw.svelte","../node_modules/svelte-awesome/package/components/Icon.svelte","../node_modules/svelte-awesome/package/components/svg/Svg.svelte","../src/lib/plugins/value/components/BooleanToggle.svelte","../src/lib/components/controls/ColorPickerPopup.svelte","../src/lib/plugins/value/components/ColorPicker.svelte","../src/lib/constants.ts","../src/lib/logic/expandItemsSections.ts","../src/lib/typeguards.ts","../src/lib/logic/documentState.ts","../src/lib/logic/selection.ts","../src/lib/utils/cssUtils.ts","../src/lib/plugins/value/components/utils/getValueClass.ts","../src/lib/components/controls/EditableDiv.svelte","../src/lib/plugins/value/components/EditableValue.svelte","../src/lib/logic/operations.ts","../src/lib/logic/search.ts","../src/lib/components/modes/treemode/highlight/SearchResultHighlighter.svelte","../src/lib/utils/fileUtils.ts","../src/lib/components/controls/Tag.svelte","../node_modules/svelte/src/internal/client/dom/blocks/snippet.js","../src/lib/plugins/value/components/ReadonlyValue.svelte","../src/lib/components/controls/tooltip/Tooltip.svelte","../src/lib/components/controls/tooltip/tooltip.ts","../src/lib/plugins/value/components/TimestampTag.svelte","../src/lib/plugins/value/renderValue.ts","../src/lib/utils/pathUtils.ts","../src/lib/components/modals/transformModalStates.ts","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/svelte-floating-ui/index.js","../node_modules/svelte-select/filter.js","../node_modules/svelte-select/get-items.js","../node_modules/svelte-select/Select.svelte","../src/lib/components/modals/TransformWizard.svelte","../src/lib/components/controls/selectQueryLanguage/SelectQueryLanguage.svelte","../src/lib/components/modals/Header.svelte","../src/lib/components/controls/createAutoScrollHandler.ts","../src/lib/assets/jump.js/src/easing.ts","../src/lib/assets/jump.js/src/jump.ts","../src/lib/utils/timeUtils.ts","../src/lib/logic/validation.ts","../src/lib/components/controls/createFocusTracker.ts","../src/lib/components/controls/Message.svelte","../src/lib/components/controls/ValidationErrorsOverview.svelte","../src/lib/actions/onEscape.ts","../src/lib/components/modals/Modal.svelte","../src/lib/components/modals/CopyPasteModal.svelte","../src/lib/components/controls/Menu.svelte","../src/lib/components/modals/repair/JSONRepairComponent.svelte","../src/lib/components/modals/JSONRepairModal.svelte","../src/lib/components/modes/treemode/CollapsedItems.svelte","../src/lib/components/controls/contextmenu/ContextMenuPointer.svelte","../src/lib/components/modes/treemode/JSONValue.svelte","../src/lib/components/modes/treemode/singleton.ts","../src/lib/logic/dragging.ts","../src/lib/components/modes/treemode/ValidationErrorIcon.svelte","../src/lib/components/modes/treemode/JSONNode.svelte","../src/lib/components/modes/treemode/JSONKey.svelte","../src/lib/img/customFontawesomeIcons.ts","../src/lib/components/modes/treemode/Welcome.svelte","../src/lib/logic/sort.ts","../src/lib/components/controls/navigationBar/NavigationBarDropdown.svelte","../src/lib/components/controls/navigationBar/NavigationBarItem.svelte","../src/lib/utils/copyToClipboard.ts","../src/lib/components/controls/navigationBar/NavigationBarPathEditor.svelte","../src/lib/components/controls/navigationBar/NavigationBar.svelte","../src/lib/components/controls/SearchBox.svelte","../src/lib/logic/table.ts","../src/lib/logic/actions.ts","../src/lib/components/controls/JSONPreview.svelte","../src/lib/components/controls/contextmenu/ContextMenuButton.svelte","../src/lib/components/controls/contextmenu/ContextMenuDropDownButton.svelte","../src/lib/components/controls/DropdownButton.svelte","../src/lib/components/controls/contextmenu/ContextMenu.svelte","../src/lib/plugins/value/components/EnumValue.svelte","../src/lib/utils/jsonSchemaUtils.ts","../src/lib/plugins/value/renderJSONSchemaEnum.ts","../src/lib/plugins/validator/createAjvValidator.ts","../src/lib/plugins/query/jmespathQueryLanguage.ts","../src/lib/plugins/query/jsonpathQueryLanguage.ts","../src/lib/plugins/query/lodashQueryLanguage.ts","../src/lib/plugins/query/javascriptQueryLanguage.ts","../src/lib/actions/resizeObserver.ts","../src/lib/components/modes/treemode/TreeMode.svelte","../src/lib/components/modes/treemode/contextmenu/createTreeContextMenuItems.ts","../src/lib/components/modes/treemode/menu/TreeMenu.svelte","../src/lib/utils/readonlyProxy.ts","../src/lib/logic/history.ts","../src/lib/components/modals/TransformModal.svelte","../src/lib/components/modals/TransformModalHeader.svelte","../src/lib/utils/noop.ts","../src/lib/components/modes/textmode/codemirror/codemirror-theme.ts","../node_modules/codemirror-wrapped-line-indent/dist/index.js","../src/lib/components/modes/textmode/TextMode.svelte","../src/lib/components/modes/textmode/menu/TextMenu.svelte","../src/lib/components/modes/textmode/StatusBar.svelte","../src/lib/components/modes/tablemode/TableModeWelcome.svelte","../src/lib/components/modes/tablemode/TableMode.svelte","../src/lib/components/modes/tablemode/contextmenu/createTableContextMenuItems.ts","../src/lib/components/modes/tablemode/menu/TableMenu.svelte","../src/lib/components/modes/tablemode/ColumnHeader.svelte","../src/lib/components/modes/tablemode/RefreshColumnHeader.svelte","../src/lib/components/modes/tablemode/tag/InlineValue.svelte","../src/lib/components/modes/JSONEditorRoot.svelte","../src/lib/components/modals/sortModalStates.ts","../src/lib/components/JSONEditor.svelte","../src/lib/components/modals/SortModal.svelte","../src/lib/components/modals/JSONEditorModal.svelte","../src/lib/index-vanilla.ts"],"sourcesContent":["// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n * @type {string}\n */\nexport const VERSION = '5.25.6';\nexport const PUBLIC_VERSION = '5';\n","import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined') {\n\t// @ts-expect-error\n\t((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);\n}\n","export let legacy_mode_flag = false;\nexport let tracing_mode_flag = false;\n\nexport function enable_legacy_mode_flag() {\n\tlegacy_mode_flag = true;\n}\n\nexport function enable_tracing_mode_flag() {\n\ttracing_mode_flag = true;\n}\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 2;\nexport const EACH_IS_ANIMATED = 1 << 3;\nexport const EACH_ITEM_IMMUTABLE = 1 << 4;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_BINDABLE = 1 << 3;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 4;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\n/** used to indicate that an `{:else}...` block was rendered */\nexport const HYDRATION_START_ELSE = '[!';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n// Dev-time component properties\nexport const FILENAME = Symbol('filename');\nexport const HMR = Symbol('hmr');\n\nexport const NAMESPACE_HTML = 'http://www.w3.org/1999/xhtml';\nexport const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\nexport const NAMESPACE_MATHML = 'http://www.w3.org/1998/Math/MathML';\n\n// we use a list of ignorable runtime warnings because not every runtime warning\n// can be ignored and we want to keep the validation for svelte-ignore in place\nexport const IGNORABLE_RUNTIME_WARNINGS = /** @type {const} */ ([\n\t'state_snapshot_uncloneable',\n\t'binding_property_non_reactive',\n\t'hydration_attribute_changed',\n\t'hydration_html_changed',\n\t'ownership_invalid_binding',\n\t'ownership_invalid_mutation'\n]);\n\n/**\n * Whitespace inside one of these elements will not result in\n * a whitespace node being created in any circumstances. (This\n * list is almost certainly very incomplete)\n * TODO this is currently unused\n */\nexport const ELEMENTS_WITHOUT_TEXT = ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video'];\n","export default false;\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const BOUNDARY_EFFECT = 1 << 7;\nexport const UNOWNED = 1 << 8;\nexport const DISCONNECTED = 1 << 9;\nexport const CLEAN = 1 << 10;\nexport const DIRTY = 1 << 11;\nexport const MAYBE_DIRTY = 1 << 12;\nexport const INERT = 1 << 13;\nexport const DESTROYED = 1 << 14;\nexport const EFFECT_RAN = 1 << 15;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 16;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 17;\nexport const INSPECT_EFFECT = 1 << 18;\nexport const HEAD_EFFECT = 1 << 19;\nexport const EFFECT_HAS_DERIVED = 1 << 20;\nexport const EFFECT_IS_UPDATING = 1 << 21;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_SYMBOL_METADATA = Symbol('$state metadata');\nexport const LEGACY_PROPS = Symbol('legacy props');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var index_of = Array.prototype.indexOf;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\nexport var is_extensible = Object.isExtensible;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/**\n * TODO replace with Promise.withResolvers once supported widely enough\n * @template T\n */\nexport function deferred() {\n\t/** @type {(value: T) => void} */\n\tvar resolve;\n\n\t/** @type {(reason: any) => void} */\n\tvar reject;\n\n\t/** @type {Promise<T>} */\n\tvar promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\n\t// @ts-expect-error\n\treturn { promise, resolve, reject };\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V | (() => V)} fallback\n * @param {boolean} [lazy]\n * @returns {V}\n */\nexport function fallback(value, fallback, lazy = false) {\n\treturn value === undefined\n\t\t? lazy\n\t\t\t? /** @type {() => V} */ (fallback)()\n\t\t\t: /** @type {V} */ (fallback)\n\t\t: value;\n}\n","import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nconst request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\n/** @type {Array<() => void>} */\nlet micro_tasks = [];\n\n/** @type {Array<() => void>} */\nlet idle_tasks = [];\n\nfunction run_micro_tasks() {\n\tvar tasks = micro_tasks;\n\tmicro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction run_idle_tasks() {\n\tvar tasks = idle_tasks;\n\tidle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (micro_tasks.length === 0) {\n\t\tqueueMicrotask(run_micro_tasks);\n\t}\n\n\tmicro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (idle_tasks.length === 0) {\n\t\trequest_idle_callback(run_idle_tasks);\n\t}\n\n\tidle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (micro_tasks.length > 0) {\n\t\trun_micro_tasks();\n\t}\n\n\tif (idle_tasks.length > 0) {\n\t\trun_idle_tasks();\n\t}\n}\n","/** @import { Equals } from '#client' */\n/** @type {Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function not_equal(a, b) {\n\treturn a !== b;\n}\n\n/** @type {Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","/** @import { ProxyMetadata, Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { get, active_effect, active_reaction, set_active_reaction } from './runtime.js';\nimport { component_context } from './context.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype\n} from '../shared/utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { state as source, set } from './reactivity/sources.js';\nimport { STATE_SYMBOL, STATE_SYMBOL_METADATA } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\nimport { get_stack } from './dev/tracing.js';\nimport { tracing_mode_flag } from '../flags/index.js';\n\n/** @type {ProxyMetadata | null} */\nvar parent_metadata = null;\n\n/**\n * @template T\n * @param {T} value\n * @param {Source<T>} [prev] dev mode only\n * @returns {T}\n */\nexport function proxy(value, prev) {\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any, Source<any>>} */\n\tvar sources = new Map();\n\tvar is_proxied_array = is_array(value);\n\tvar version = source(0);\n\n\tvar stack = DEV && tracing_mode_flag ? get_stack('CreatedAt') : null;\n\tvar reaction = active_reaction;\n\n\t/**\n\t * @template T\n\t * @param {() => T} fn\n\t */\n\tvar with_parent = (fn) => {\n\t\tvar previous_reaction = active_reaction;\n\t\tset_active_reaction(reaction);\n\n\t\t/** @type {T} */\n\t\tvar result;\n\n\t\tif (DEV) {\n\t\t\tvar previous_metadata = parent_metadata;\n\t\t\tparent_metadata = metadata;\n\t\t\tresult = fn();\n\t\t\tparent_metadata = previous_metadata;\n\t\t} else {\n\t\t\tresult = fn();\n\t\t}\n\n\t\tset_active_reaction(previous_reaction);\n\t\treturn result;\n\t};\n\n\tif (is_proxied_array) {\n\t\t// We need to create the length source eagerly to ensure that\n\t\t// mutations to the array are properly synced with our proxy\n\t\tsources.set('length', source(/** @type {any[]} */ (value).length, stack));\n\t}\n\n\t/** @type {ProxyMetadata} */\n\tvar metadata;\n\n\tif (DEV) {\n\t\tmetadata = {\n\t\t\tparent: parent_metadata,\n\t\t\towners: null\n\t\t};\n\n\t\tif (prev) {\n\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t// @ts-expect-error\n\t\t\tconst prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;\n\t\t\tmetadata.owners = prev_owners ? new Set(prev_owners) : null;\n\t\t} else {\n\t\t\tmetadata.owners =\n\t\t\t\tparent_metadata === null\n\t\t\t\t\t? component_context !== null\n\t\t\t\t\t\t? new Set([component_context.function])\n\t\t\t\t\t\t: null\n\t\t\t\t\t: new Set();\n\t\t}\n\t}\n\n\treturn new Proxy(/** @type {any} */ (value), {\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object — which we avoid, so that state can be forked — we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\te.state_descriptors_fixed();\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\ts = with_parent(() => source(descriptor.value, stack));\n\t\t\t\tsources.set(prop, s);\n\t\t\t} else {\n\t\t\t\tset(\n\t\t\t\t\ts,\n\t\t\t\t\twith_parent(() => proxy(descriptor.value))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tsources.set(\n\t\t\t\t\t\tprop,\n\t\t\t\t\t\twith_parent(() => source(UNINITIALIZED, stack))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// When working with arrays, we need to also ensure we update the length when removing\n\t\t\t\t// an indexed property\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n < ls.v) {\n\t\t\t\t\t\tset(ls, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset(s, UNINITIALIZED);\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tget(target, prop, receiver) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\t// create a source, but only if it's an own property and not a prototype property\n\t\t\tif (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\ts = with_parent(() => source(proxy(exists ? target[prop] : UNINITIALIZED), stack));\n\t\t\t\tsources.set(prop, s);\n\t\t\t}\n\n\t\t\tif (s !== undefined) {\n\t\t\t\tvar v = get(s);\n\n\t\t\t\t// In case of something like `foo = bar.map(...)`, foo would have ownership\n\t\t\t\t// of the array itself, while the individual items would have ownership\n\t\t\t\t// of the component that created bar. That means if we later do `foo[0].baz = 42`,\n\t\t\t\t// we could get a false-positive ownership violation, since the two proxies\n\t\t\t\t// are not connected to each other via the parent metadata relationship.\n\t\t\t\t// For this reason, we need to widen the ownership of the children\n\t\t\t\t// upon access when we detect they are not connected.\n\t\t\t\tif (DEV) {\n\t\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\t\tvar prop_metadata = v?.[STATE_SYMBOL_METADATA];\n\t\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar s = sources.get(prop);\n\t\t\t\tif (s) descriptor.value = get(s);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar source = sources.get(prop);\n\t\t\t\tvar value = source?.v;\n\n\t\t\t\tif (source !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (\n\t\t\t\ts !== undefined ||\n\t\t\t\t(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t\t) {\n\t\t\t\tif (s === undefined) {\n\t\t\t\t\ts = with_parent(() => source(has ? proxy(target[prop]) : UNINITIALIZED, stack));\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(s);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn has;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = prop in target;\n\n\t\t\t// variable.length = value -> clear all signals with index >= value\n\t\t\tif (is_proxied_array && prop === 'length') {\n\t\t\t\tfor (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {\n\t\t\t\t\tvar other_s = sources.get(i + '');\n\t\t\t\t\tif (other_s !== undefined) {\n\t\t\t\t\t\tset(other_s, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized source,\n\t\t\t\t\t\t// else a later read of the property would result in a source being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_s = with_parent(() => source(UNINITIALIZED, stack));\n\t\t\t\t\t\tsources.set(i + '', other_s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (s === undefined) {\n\t\t\t\tif (!has || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\ts = with_parent(() => source(undefined, stack));\n\t\t\t\t\tset(\n\t\t\t\t\t\ts,\n\t\t\t\t\t\twith_parent(() => proxy(value))\n\t\t\t\t\t);\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thas = s.v !== UNINITIALIZED;\n\t\t\t\tset(\n\t\t\t\t\ts,\n\t\t\t\t\twith_parent(() => proxy(value))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (DEV) {\n\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\tvar prop_metadata = value?.[STATE_SYMBOL_METADATA];\n\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t}\n\t\t\t\tcheck_ownership(metadata);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!has) {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n >= ls.v) {\n\t\t\t\t\t\tset(ls, n + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tget(version);\n\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar source = sources.get(key);\n\t\t\t\treturn source === undefined || source.v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, source] of sources) {\n\t\t\t\tif (source.v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\te.state_prototype_fixed();\n\t\t}\n\t});\n}\n\n/**\n * @param {Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\ttry {\n\t\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\t\treturn value[STATE_SYMBOL];\n\t\t}\n\t} catch {\n\t\t// the above if check can throw an error if the value in question\n\t\t// is the contentWindow of an iframe on another domain, in which\n\t\t// case we want to just return the value (because it's definitely\n\t\t// not a proxied value) so we don't break any JavaScript interacting\n\t\t// with that iframe (such as various payment companies client side\n\t\t// JavaScript libraries interacting with their iframes on the same\n\t\t// domain)\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead\\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)\\nhttps://svelte.dev/e/bind_invalid_export`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/bind_invalid_export`);\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\`\\nhttps://svelte.dev/e/bind_not_bindable`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/bind_not_bindable`);\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5\\nhttps://svelte.dev/e/component_api_changed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/component_api_changed`);\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`compatibility.componentApi\\` compiler option to \\`4\\` to keep it working.\\nhttps://svelte.dev/e/component_api_invalid_new`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/component_api_invalid_new`);\n\t}\n}\n\n/**\n * A derived value cannot reference itself recursively\n * @returns {never}\n */\nexport function derived_references_self() {\n\tif (DEV) {\n\t\tconst error = new Error(`derived_references_self\\nA derived value cannot reference itself recursively\\nhttps://svelte.dev/e/derived_references_self`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/derived_references_self`);\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}\\nhttps://svelte.dev/e/each_key_duplicate`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/each_key_duplicate`);\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function\\nhttps://svelte.dev/e/effect_in_teardown`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_in_teardown`);\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect\\nhttps://svelte.dev/e/effect_in_unowned_derived`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_in_unowned_derived`);\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)\\nhttps://svelte.dev/e/effect_orphan`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_orphan`);\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\\nhttps://svelte.dev/e/effect_update_depth_exceeded`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application\\nhttps://svelte.dev/e/hydration_failed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/hydration_failed`);\n\t}\n}\n\n/**\n * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`\n * @returns {never}\n */\nexport function invalid_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_snippet\\nCould not \\`{@render}\\` snippet due to the expression being \\`null\\` or \\`undefined\\`. Consider using optional chaining \\`{@render snippet?.()}\\`\\nhttps://svelte.dev/e/invalid_snippet`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/invalid_snippet`);\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode\\nhttps://svelte.dev/e/lifecycle_legacy_only`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/lifecycle_legacy_only`);\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value\\nhttps://svelte.dev/e/props_invalid_value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/props_invalid_value`);\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly\\nhttps://svelte.dev/e/props_rest_readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/props_rest_readonly`);\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files\\nhttps://svelte.dev/e/rune_outside_svelte`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/rune_outside_svelte`);\n\t}\n}\n\n/**\n * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\n * @returns {never}\n */\nexport function state_descriptors_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_descriptors_fixed\\nProperty descriptors defined on \\`$state\\` objects must contain \\`value\\` and always be \\`enumerable\\`, \\`configurable\\` and \\`writable\\`.\\nhttps://svelte.dev/e/state_descriptors_fixed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/state_descriptors_fixed`);\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object\\nhttps://svelte.dev/e/state_prototype_fixed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/state_prototype_fixed`);\n\t}\n}\n\n/**\n * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \\`$state\\`\\nhttps://svelte.dev/e/state_unsafe_mutation`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/state_unsafe_mutation`);\n\t}\n}","/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport {\n\tactive_reaction,\n\tactive_effect,\n\tuntracked_writes,\n\tget,\n\tschedule_effect,\n\tset_untracked_writes,\n\tset_signal_status,\n\tuntrack,\n\tincrement_write_version,\n\tupdate_effect,\n\treaction_sources,\n\tset_reaction_sources,\n\tcheck_dirtiness,\n\tuntracking,\n\tis_destroying_effect,\n\tpush_reaction_value\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport {\n\tCLEAN,\n\tDERIVED,\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tINSPECT_EFFECT,\n\tUNOWNED,\n\tMAYBE_DIRTY,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_IS_UPDATING\n} from '../constants.js';\nimport * as e from '../errors.js';\nimport { legacy_mode_flag, tracing_mode_flag } from '../../flags/index.js';\nimport { get_stack } from '../dev/tracing.js';\nimport { component_context, is_runes } from '../context.js';\nimport { proxy } from '../proxy.js';\n\nexport let inspect_effects = new Set();\nexport const old_values = new Map();\n\n/**\n * @param {Set<any>} v\n */\nexport function set_inspect_effects(v) {\n\tinspect_effects = v;\n}\n\n/**\n * @template V\n * @param {V} v\n * @param {Error | null} [stack]\n * @returns {Source<V>}\n */\n// TODO rename this to `state` throughout the codebase\nexport function source(v, stack) {\n\t/** @type {Value} */\n\tvar signal = {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\tv,\n\t\treactions: null,\n\t\tequals,\n\t\trv: 0,\n\t\twv: 0\n\t};\n\n\tif (DEV && tracing_mode_flag) {\n\t\tsignal.created = stack ?? get_stack('CreatedAt');\n\t\tsignal.debug = null;\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {V} v\n * @param {Error | null} [stack]\n */\nexport function state(v, stack) {\n\tconst s = source(v, stack);\n\n\tpush_reaction_value(s);\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @param {boolean} [immutable]\n * @returns {Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value, immutable = false) {\n\tconst s = source(initial_value);\n\tif (!immutable) {\n\t\ts.equals = safe_equals;\n\t}\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (legacy_mode_flag && component_context !== null && component_context.l !== null) {\n\t\t(component_context.l.s ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @param {boolean} [should_proxy]\n * @returns {V}\n */\nexport function set(source, value, should_proxy = false) {\n\tif (\n\t\tactive_reaction !== null &&\n\t\t!untracking &&\n\t\tis_runes() &&\n\t\t(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&\n\t\t!reaction_sources?.includes(source)\n\t) {\n\t\te.state_unsafe_mutation();\n\t}\n\n\tlet new_value = should_proxy ? proxy(value, source) : value;\n\n\treturn internal_set(source, new_value);\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function internal_set(source, value) {\n\tif (!source.equals(value)) {\n\t\tvar old_value = source.v;\n\n\t\tif (is_destroying_effect) {\n\t\t\told_values.set(source, value);\n\t\t} else {\n\t\t\told_values.set(source, old_value);\n\t\t}\n\n\t\tsource.v = value;\n\t\tsource.wv = increment_write_version();\n\n\t\tif (DEV && tracing_mode_flag) {\n\t\t\tsource.updated = get_stack('UpdatedAt');\n\t\t\tif (active_effect != null) {\n\t\t\t\tsource.trace_need_increase = true;\n\t\t\t\tsource.trace_v ??= old_value;\n\t\t\t}\n\t\t}\n\n\t\tmark_reactions(source, DIRTY);\n\n\t\t// It's possible that the current reaction might not have up-to-date dependencies\n\t\t// whilst it's actively running. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e: `$effect(() => x++)`\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tactive_effect !== null &&\n\t\t\t(active_effect.f & CLEAN) !== 0 &&\n\t\t\t(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0\n\t\t) {\n\t\t\tif (untracked_writes === null) {\n\t\t\t\tset_untracked_writes([source]);\n\t\t\t} else {\n\t\t\t\tuntracked_writes.push(source);\n\t\t\t}\n\t\t}\n\n\t\tif (DEV && inspect_effects.size > 0) {\n\t\t\tconst inspects = Array.from(inspect_effects);\n\n\t\t\tfor (const effect of inspects) {\n\t\t\t\t// Mark clean inspect-effects as maybe dirty and then check their dirtiness\n\t\t\t\t// instead of just updating the effects - this way we avoid overfiring.\n\t\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t\t}\n\t\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\t\tupdate_effect(effect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinspect_effects.clear();\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {number | bigint} T\n * @param {Source<T>} source\n * @param {1 | -1} [d]\n * @returns {T}\n */\nexport function update(source, d = 1) {\n\tvar value = get(source);\n\tvar result = d === 1 ? value++ : value--;\n\n\tset(source, value);\n\n\t// @ts-expect-error\n\treturn result;\n}\n\n/**\n * @template {number | bigint} T\n * @param {Source<T>} source\n * @param {1 | -1} [d]\n * @returns {T}\n */\nexport function update_pre(source, d = 1) {\n\tvar value = get(source);\n\n\t// @ts-expect-error\n\treturn set(source, d === 1 ? ++value : --value);\n}\n\n/**\n * @param {Value} signal\n * @param {number} status should be DIRTY or MAYBE_DIRTY\n * @returns {void}\n */\nfunction mark_reactions(signal, status) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tvar flags = reaction.f;\n\n\t\t// Skip any effects that are already dirty\n\t\tif ((flags & DIRTY) !== 0) continue;\n\n\t\t// In legacy mode, skip the current effect to prevent infinite loops\n\t\tif (!runes && reaction === active_effect) continue;\n\n\t\t// Inspect effects need to run immediately, so that the stack trace makes sense\n\t\tif (DEV && (flags & INSPECT_EFFECT) !== 0) {\n\t\t\tinspect_effects.add(reaction);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_signal_status(reaction, status);\n\n\t\t// If the signal a) was previously clean or b) is an unowned derived, then mark it\n\t\tif ((flags & (CLEAN | UNOWNED)) !== 0) {\n\t\t\tif ((flags & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {Effect} */ (reaction));\n\t\t\t}\n\t\t}\n\t}\n}\n","/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport { define_property, get_descriptors, get_prototype_of, index_of } from '../shared/utils.js';\nimport {\n\tdestroy_block_effect_children,\n\tdestroy_effect_children,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED,\n\tBOUNDARY_EFFECT,\n\tEFFECT_IS_UPDATING\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { internal_set, old_values } from './reactivity/sources.js';\nimport { destroy_derived_effects, update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { FILENAME } from '../../constants.js';\nimport { tracing_mode_flag } from '../flags/index.js';\nimport { tracing_expressions, get_stack } from './dev/tracing.js';\nimport {\n\tcomponent_context,\n\tdev_current_component_function,\n\tis_runes,\n\tset_component_context,\n\tset_dev_current_component_function\n} from './context.js';\nimport { is_firefox } from './dom/operations.js';\n\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\nlet is_throwing_error = false;\n\nlet is_flushing = false;\n\n/** @type {Effect | null} */\nlet last_scheduled_effect = null;\n\nlet is_updating_effect = false;\n\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\n// Handle effect queues\n\n/** @type {Effect[]} */\nlet queued_root_effects = [];\n\n/** @type {Effect[]} Stack of effects, dev only */\nlet dev_effect_stack = [];\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | Reaction} */\nexport let active_reaction = null;\n\nexport let untracking = false;\n\n/** @param {null | Reaction} reaction */\nexport function set_active_reaction(reaction) {\n\tactive_reaction = reaction;\n}\n\n/** @type {null | Effect} */\nexport let active_effect = null;\n\n/** @param {null | Effect} effect */\nexport function set_active_effect(effect) {\n\tactive_effect = effect;\n}\n\n/**\n * When sources are created within a reaction, reading and writing\n * them should not cause a re-run\n * @type {null | Source[]}\n */\nexport let reaction_sources = null;\n\n/**\n * @param {Source[] | null} sources\n */\nexport function set_reaction_sources(sources) {\n\treaction_sources = sources;\n}\n\n/** @param {Value} value */\nexport function push_reaction_value(value) {\n\tif (active_reaction !== null && active_reaction.f & EFFECT_IS_UPDATING) {\n\t\tif (reaction_sources === null) {\n\t\t\tset_reaction_sources([value]);\n\t\t} else {\n\t\t\treaction_sources.push(value);\n\t\t}\n\t}\n}\n\n/**\n * The dependencies of the reaction that is currently being executed. In many cases,\n * the dependencies are unchanged between runs, and so this will be `null` unless\n * and until a new dependency is accessed — we track this via `skipped_deps`\n * @type {null | Value[]}\n */\nlet new_deps = null;\n\nlet skipped_deps = 0;\n\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | Source[]}\n */\nexport let untracked_writes = null;\n\n/** @param {null | Source[]} value */\nexport function set_untracked_writes(value) {\n\tuntracked_writes = value;\n}\n\n/**\n * @type {number} Used by sources and deriveds for handling updates.\n * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing\n **/\nlet write_version = 1;\n\n/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */\nlet read_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\n/** @type {Set<Value> | null} */\nexport let captured_signals = null;\n\n/** @param {Set<Value> | null} value */\nexport function set_captured_signals(value) {\n\tcaptured_signals = value;\n}\n\nexport function increment_write_version() {\n\treturn ++write_version;\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\n\tif ((flags & DIRTY) !== 0) {\n\t\treturn true;\n\t}\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\t\tvar is_unowned = (flags & UNOWNED) !== 0;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar i;\n\t\t\tvar dependency;\n\t\t\tvar is_disconnected = (flags & DISCONNECTED) !== 0;\n\t\t\tvar is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;\n\t\t\tvar length = dependencies.length;\n\n\t\t\t// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)\n\t\t\t// then we need to re-connect the reaction to the dependency\n\t\t\tif (is_disconnected || is_unowned_connected) {\n\t\t\t\tvar derived = /** @type {Derived} */ (reaction);\n\t\t\t\tvar parent = derived.parent;\n\n\t\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\t\tdependency = dependencies[i];\n\n\t\t\t\t\t// We always re-add all reactions (even duplicates) if the derived was\n\t\t\t\t\t// previously disconnected, however we don't if it was unowned as we\n\t\t\t\t\t// de-duplicate dependencies in that case\n\t\t\t\t\tif (is_disconnected || !dependency?.reactions?.includes(derived)) {\n\t\t\t\t\t\t(dependency.reactions ??= []).push(derived);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (is_disconnected) {\n\t\t\t\t\tderived.f ^= DISCONNECTED;\n\t\t\t\t}\n\t\t\t\t// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent\n\t\t\t\t// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned\n\t\t\t\t// flag\n\t\t\t\tif (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {\n\t\t\t\t\tderived.f ^= UNOWNED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tdependency = dependencies[i];\n\n\t\t\t\tif (check_dirtiness(/** @type {Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {Derived} */ (dependency));\n\t\t\t\t}\n\n\t\t\t\tif (dependency.wv > reaction.wv) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals should never be marked as clean unless they\n\t\t// are used within an active_effect without skip_reaction\n\t\tif (!is_unowned || (active_effect !== null && !skip_reaction)) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {unknown} error\n * @param {Effect} effect\n */\nfunction propagate_error(error, effect) {\n\t/** @type {Effect | null} */\n\tvar current = effect;\n\n\twhile (current !== null) {\n\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tcurrent.fn(error);\n\t\t\t\treturn;\n\t\t\t} catch {\n\t\t\t\t// Remove boundary flag from effect\n\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n\t\t\t}\n\t\t}\n\n\t\tcurrent = current.parent;\n\t}\n\n\tis_throwing_error = false;\n\tthrow error;\n}\n\n/**\n * @param {Effect} effect\n */\nfunction should_rethrow_error(effect) {\n\treturn (\n\t\t(effect.f & DESTROYED) === 0 &&\n\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n\t);\n}\n\nexport function reset_is_throwing_error() {\n\tis_throwing_error = false;\n}\n\n/**\n * @param {unknown} error\n * @param {Effect} effect\n * @param {Effect | null} previous_effect\n * @param {ComponentContext | null} component_context\n */\nexport function handle_error(error, effect, previous_effect, component_context) {\n\tif (is_throwing_error) {\n\t\tif (previous_effect === null) {\n\t\t\tis_throwing_error = false;\n\t\t}\n\n\t\tif (should_rethrow_error(effect)) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (previous_effect !== null) {\n\t\tis_throwing_error = true;\n\t}\n\n\tif (\n\t\t!DEV ||\n\t\tcomponent_context === null ||\n\t\t!(error instanceof Error) ||\n\t\thandled_errors.has(error)\n\t) {\n\t\tpropagate_error(error, effect);\n\t\treturn;\n\t}\n\n\thandled_errors.add(error);\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tif (DEV) {\n\t\t\t/** @type {string} */\n\t\t\tvar filename = current_context.function?.[FILENAME];\n\n\t\t\tif (filename) {\n\t\t\t\tconst file = filename.split('/').pop();\n\t\t\t\tcomponent_stack.push(file);\n\t\t\t}\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = is_firefox ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\tdefine_property(error, 'component_stack', {\n\t\tvalue: component_stack\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: new_lines.join('\\n')\n\t\t});\n\t}\n\n\tpropagate_error(error, effect);\n\n\tif (should_rethrow_error(effect)) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * @param {Value} signal\n * @param {Effect} effect\n * @param {boolean} [root]\n */\nfunction schedule_possible_effect_self_invalidation(signal, effect, root = true) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tfor (var i = 0; i < reactions.length; i++) {\n\t\tvar reaction = reactions[i];\n\n\t\tif (reaction_sources?.includes(signal)) continue;\n\n\t\tif ((reaction.f & DERIVED) !== 0) {\n\t\t\tschedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);\n\t\t} else if (effect === reaction) {\n\t\t\tif (root) {\n\t\t\t\tset_signal_status(reaction, DIRTY);\n\t\t\t} else if ((reaction.f & CLEAN) !== 0) {\n\t\t\t\tset_signal_status(reaction, MAYBE_DIRTY);\n\t\t\t}\n\t\t\tschedule_effect(/** @type {Effect} */ (reaction));\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {Reaction} reaction\n * @returns {V}\n */\nexport function update_reaction(reaction) {\n\tvar previous_deps = new_deps;\n\tvar previous_skipped_deps = skipped_deps;\n\tvar previous_untracked_writes = untracked_writes;\n\tvar previous_reaction = active_reaction;\n\tvar previous_skip_reaction = skip_reaction;\n\tvar previous_reaction_sources = reaction_sources;\n\tvar previous_component_context = component_context;\n\tvar previous_untracking = untracking;\n\n\tvar flags = reaction.f;\n\n\tnew_deps = /** @type {null | Value[]} */ (null);\n\tskipped_deps = 0;\n\tuntracked_writes = null;\n\tskip_reaction =\n\t\t(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);\n\tactive_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;\n\n\treaction_sources = null;\n\tset_component_context(reaction.ctx);\n\tuntracking = false;\n\tread_version++;\n\n\treaction.f |= EFFECT_IS_UPDATING;\n\n\ttry {\n\t\tvar result = /** @type {Function} */ (0, reaction.fn)();\n\t\tvar deps = reaction.deps;\n\n\t\tif (new_deps !== null) {\n\t\t\tvar i;\n\n\t\t\tremove_reactions(reaction, skipped_deps);\n\n\t\t\tif (deps !== null && skipped_deps > 0) {\n\t\t\t\tdeps.length = skipped_deps + new_deps.length;\n\t\t\t\tfor (i = 0; i < new_deps.length; i++) {\n\t\t\t\t\tdeps[skipped_deps + i] = new_deps[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treaction.deps = deps = new_deps;\n\t\t\t}\n\n\t\t\tif (!skip_reaction) {\n\t\t\t\tfor (i = skipped_deps; i < deps.length; i++) {\n\t\t\t\t\t(deps[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (deps !== null && skipped_deps < deps.length) {\n\t\t\tremove_reactions(reaction, skipped_deps);\n\t\t\tdeps.length = skipped_deps;\n\t\t}\n\n\t\t// If we're inside an effect and we have untracked writes, then we need to\n\t\t// ensure that if any of those untracked writes result in re-invalidation\n\t\t// of the current effect, then that happens accordingly\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tuntracked_writes !== null &&\n\t\t\t!untracking &&\n\t\t\tdeps !== null &&\n\t\t\t(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0\n\t\t) {\n\t\t\tfor (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {\n\t\t\t\tschedule_possible_effect_self_invalidation(\n\t\t\t\t\tuntracked_writes[i],\n\t\t\t\t\t/** @type {Effect} */ (reaction)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// If we are returning to an previous reaction then\n\t\t// we need to increment the read version to ensure that\n\t\t// any dependencies in this reaction aren't marked with\n\t\t// the same version\n\t\tif (previous_reaction !== null) {\n\t\t\tread_version++;\n\n\t\t\tif (untracked_writes !== null) {\n\t\t\t\tif (previous_untracked_writes === null) {\n\t\t\t\t\tprevious_untracked_writes = untracked_writes;\n\t\t\t\t} else {\n\t\t\t\t\tprevious_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tnew_deps = previous_deps;\n\t\tskipped_deps = previous_skipped_deps;\n\t\tuntracked_writes = previous_untracked_writes;\n\t\tactive_reaction = previous_reaction;\n\t\tskip_reaction = previous_skip_reaction;\n\t\treaction_sources = previous_reaction_sources;\n\t\tset_component_context(previous_component_context);\n\t\tuntracking = previous_untracking;\n\n\t\treaction.f ^= EFFECT_IS_UPDATING;\n\t}\n}\n\n/**\n * @template V\n * @param {Reaction} signal\n * @param {Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tlet reactions = dependency.reactions;\n\tif (reactions !== null) {\n\t\tvar index = index_of.call(reactions, signal);\n\t\tif (index !== -1) {\n\t\t\tvar new_length = reactions.length - 1;\n\t\t\tif (new_length === 0) {\n\t\t\t\treactions = dependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[new_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (\n\t\treactions === null &&\n\t\t(dependency.f & DERIVED) !== 0 &&\n\t\t// Destroying a child effect while updating a parent effect can cause a dependency to appear\n\t\t// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`\n\t\t// allows us to skip the expensive work of disconnecting and immediately reconnecting it\n\t\t(new_deps === null || !new_deps.includes(dependency))\n\t) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\t// Disconnect any reactions owned by this reaction\n\t\tdestroy_derived_effects(/** @type {Derived} **/ (dependency));\n\t\tremove_reactions(/** @type {Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tvar dependencies = signal.deps;\n\tif (dependencies === null) return;\n\n\tfor (var i = start_index; i < dependencies.length; i++) {\n\t\tremove_reaction(signal, dependencies[i]);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @returns {void}\n */\nexport function update_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar previous_effect = active_effect;\n\tvar previous_component_context = component_context;\n\tvar was_updating_effect = is_updating_effect;\n\n\tactive_effect = effect;\n\tis_updating_effect = true;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tset_dev_current_component_function(effect.component_function);\n\t}\n\n\ttry {\n\t\tif ((flags & BLOCK_EFFECT) !== 0) {\n\t\t\tdestroy_block_effect_children(effect);\n\t\t} else {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = update_reaction(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t\teffect.wv = write_version;\n\n\t\tvar deps = effect.deps;\n\n\t\t// In DEV, we need to handle a case where $inspect.trace() might\n\t\t// incorrectly state a source dependency has not changed when it has.\n\t\t// That's beacuse that source was changed by the same effect, causing\n\t\t// the versions to match. We can avoid this by incrementing the version\n\t\tif (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && deps !== null) {\n\t\t\tfor (let i = 0; i < deps.length; i++) {\n\t\t\t\tvar dep = deps[i];\n\t\t\t\tif (dep.trace_need_increase) {\n\t\t\t\t\tdep.wv = increment_write_version();\n\t\t\t\t\tdep.trace_need_increase = undefined;\n\t\t\t\t\tdep.trace_v = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DEV) {\n\t\t\tdev_effect_stack.push(effect);\n\t\t}\n\t} catch (error) {\n\t\thandle_error(error, effect, previous_effect, previous_component_context || effect.ctx);\n\t} finally {\n\t\tis_updating_effect = was_updating_effect;\n\t\tactive_effect = previous_effect;\n\n\t\tif (DEV) {\n\t\t\tset_dev_current_component_function(previous_component_fn);\n\t\t}\n\t}\n}\n\nfunction log_effect_stack() {\n\t// eslint-disable-next-line no-console\n\tconsole.error(\n\t\t'Last ten effects were: ',\n\t\tdev_effect_stack.slice(-10).map((d) => d.fn)\n\t);\n\tdev_effect_stack = [];\n}\n\nfunction infinite_loop_guard() {\n\ttry {\n\t\te.effect_update_depth_exceeded();\n\t} catch (error) {\n\t\tif (DEV) {\n\t\t\t// stack is garbage, ignore. Instead add a console.error message.\n\t\t\tdefine_property(error, 'stack', {\n\t\t\t\tvalue: ''\n\t\t\t});\n\t\t}\n\t\t// Try and handle the error so it can be caught at a boundary, that's\n\t\t// if there's an effect available from when it was last scheduled\n\t\tif (last_scheduled_effect !== null) {\n\t\t\tif (DEV) {\n\t\t\t\ttry {\n\t\t\t\t\thandle_error(error, last_scheduled_effect, null, null);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Only log the effect stack if the error is re-thrown\n\t\t\t\t\tlog_effect_stack();\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandle_error(error, last_scheduled_effect, null, null);\n\t\t\t}\n\t\t} else {\n\t\t\tif (DEV) {\n\t\t\t\tlog_effect_stack();\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nfunction flush_queued_root_effects() {\n\tvar was_updating_effect = is_updating_effect;\n\n\ttry {\n\t\tvar flush_count = 0;\n\t\tis_updating_effect = true;\n\n\t\twhile (queued_root_effects.length > 0) {\n\t\t\tif (flush_count++ > 1000) {\n\t\t\t\tinfinite_loop_guard();\n\t\t\t}\n\n\t\t\tvar root_effects = queued_root_effects;\n\t\t\tvar length = root_effects.length;\n\n\t\t\tqueued_root_effects = [];\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar collected_effects = process_effects(root_effects[i]);\n\t\t\t\tflush_queued_effects(collected_effects);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tis_flushing = false;\n\t\tis_updating_effect = was_updating_effect;\n\n\t\tlast_scheduled_effect = null;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\t\told_values.clear();\n\t}\n}\n\n/**\n * @param {Array<Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0) {\n\t\t\ttry {\n\t\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\t\tupdate_effect(effect);\n\n\t\t\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t\t\t// here (rather than in `update_effect`) allows us to skip the work for\n\t\t\t\t\t// immediate effects.\n\t\t\t\t\tif (effect.deps === null && effect.first === null && effect.nodes_start === null) {\n\t\t\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\t\t\teffect.fn = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\thandle_error(error, effect, null, effect.ctx);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (!is_flushing) {\n\t\tis_flushing = true;\n\t\tqueueMicrotask(flush_queued_root_effects);\n\t}\n\n\tvar effect = (last_scheduled_effect = signal);\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\teffect.f ^= CLEAN;\n\t\t}\n\t}\n\n\tqueued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {Effect} root\n * @returns {Effect[]}\n */\nfunction process_effects(root) {\n\t/** @type {Effect[]} */\n\tvar effects = [];\n\n\t/** @type {Effect | null} */\n\tvar effect = root;\n\n\twhile (effect !== null) {\n\t\tvar flags = effect.f;\n\t\tvar is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;\n\t\tvar is_skippable_branch = is_branch && (flags & CLEAN) !== 0;\n\n\t\tif (!is_skippable_branch && (flags & INERT) === 0) {\n\t\t\tif ((flags & EFFECT) !== 0) {\n\t\t\t\teffects.push(effect);\n\t\t\t} else if (is_branch) {\n\t\t\t\teffect.f ^= CLEAN;\n\t\t\t} else {\n\t\t\t\t// Ensure we set the effect to be the active reaction\n\t\t\t\t// to ensure that unowned deriveds are correctly tracked\n\t\t\t\t// because we're flushing the current effect\n\t\t\t\tvar previous_active_reaction = active_reaction;\n\t\t\t\ttry {\n\t\t\t\t\tactive_reaction = effect;\n\t\t\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\t\t\tupdate_effect(effect);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\thandle_error(error, effect, null, effect.ctx);\n\t\t\t\t} finally {\n\t\t\t\t\tactive_reaction = previous_active_reaction;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/** @type {Effect | null} */\n\t\t\tvar child = effect.first;\n\n\t\t\tif (child !== null) {\n\t\t\t\teffect = child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tvar parent = effect.parent;\n\t\teffect = effect.next;\n\n\t\twhile (effect === null && parent !== null) {\n\t\t\teffect = parent.next;\n\t\t\tparent = parent.parent;\n\t\t}\n\t}\n\n\treturn effects;\n}\n\n/**\n * Synchronously flush any pending updates.\n * Returns void if no callback is provided, otherwise returns the result of calling the callback.\n * @template [T=void]\n * @param {(() => T) | undefined} [fn]\n * @returns {T}\n */\nexport function flushSync(fn) {\n\tvar result;\n\n\tif (fn) {\n\t\tis_flushing = true;\n\t\tflush_queued_root_effects();\n\t\tresult = fn();\n\t}\n\n\tflush_tasks();\n\n\twhile (queued_root_effects.length > 0) {\n\t\tis_flushing = true;\n\t\tflush_queued_root_effects();\n\t\tflush_tasks();\n\t}\n\n\treturn /** @type {T} */ (result);\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flushSync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflushSync();\n}\n\n/**\n * @template V\n * @param {Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tvar flags = signal.f;\n\tvar is_derived = (flags & DERIVED) !== 0;\n\n\tif (captured_signals !== null) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (active_reaction !== null && !untracking) {\n\t\tif (!reaction_sources?.includes(signal)) {\n\t\t\tvar deps = active_reaction.deps;\n\t\t\tif (signal.rv < read_version) {\n\t\t\t\tsignal.rv = read_version;\n\t\t\t\t// If the signal is accessing the same dependencies in the same\n\t\t\t\t// order as it did last time, increment `skipped_deps`\n\t\t\t\t// rather than updating `new_deps`, which creates GC cost\n\t\t\t\tif (new_deps === null && deps !== null && deps[skipped_deps] === signal) {\n\t\t\t\t\tskipped_deps++;\n\t\t\t\t} else if (new_deps === null) {\n\t\t\t\t\tnew_deps = [signal];\n\t\t\t\t} else if (!skip_reaction || !new_deps.includes(signal)) {\n\t\t\t\t\t// Normally we can push duplicated dependencies to `new_deps`, but if we're inside\n\t\t\t\t\t// an unowned derived because skip_reaction is true, then we need to ensure that\n\t\t\t\t\t// we don't have duplicates\n\t\t\t\t\tnew_deps.push(signal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tis_derived &&\n\t\t/** @type {Derived} */ (signal).deps === null &&\n\t\t/** @type {Derived} */ (signal).effects === null\n\t) {\n\t\tvar derived = /** @type {Derived} */ (signal);\n\t\tvar parent = derived.parent;\n\n\t\tif (parent !== null && (parent.f & UNOWNED) === 0) {\n\t\t\t// If the derived is owned by another derived then mark it as unowned\n\t\t\t// as the derived value might have been referenced in a different context\n\t\t\t// since and thus its parent might not be its true owner anymore\n\t\t\tderived.f ^= UNOWNED;\n\t\t}\n\t}\n\n\tif (is_derived) {\n\t\tderived = /** @type {Derived} */ (signal);\n\n\t\tif (check_dirtiness(derived)) {\n\t\t\tupdate_derived(derived);\n\t\t}\n\t}\n\n\tif (\n\t\tDEV &&\n\t\ttracing_mode_flag &&\n\t\ttracing_expressions !== null &&\n\t\tactive_reaction !== null &&\n\t\ttracing_expressions.reaction === active_reaction\n\t) {\n\t\t// Used when mapping state between special blocks like `each`\n\t\tif (signal.debug) {\n\t\t\tsignal.debug();\n\t\t} else if (signal.created) {\n\t\t\tvar entry = tracing_expressions.entries.get(signal);\n\n\t\t\tif (entry === undefined) {\n\t\t\t\tentry = { read: [] };\n\t\t\t\ttracing_expressions.entries.set(signal, entry);\n\t\t\t}\n\n\t\t\tentry.read.push(get_stack('TracedAt'));\n\t\t}\n\t}\n\n\tif (is_destroying_effect && old_values.has(signal)) {\n\t\treturn old_values.get(signal);\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Like `get`, but checks for `undefined`. Used for `var` declarations because they can be accessed before being declared\n * @template V\n * @param {Value<V> | undefined} signal\n * @returns {V | undefined}\n */\nexport function safe_get(signal) {\n\treturn signal && get(signal);\n}\n\n/**\n * Capture an array of all the signals that are read when `fn` is called\n * @template T\n * @param {() => T} fn\n */\nfunction capture_signals(fn) {\n\tvar previous_captured_signals = captured_signals;\n\tcaptured_signals = new Set();\n\n\tvar captured = captured_signals;\n\tvar signal;\n\n\ttry {\n\t\tuntrack(fn);\n\t\tif (previous_captured_signals !== null) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\n\treturn captured;\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar captured = capture_signals(() => untrack(fn));\n\n\tfor (var signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\t// Use internal_set instead of set here and below to avoid mutation validation\n\t\t\t\t\tinternal_set(dep, dep.v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tinternal_set(signal, signal.v);\n\t\t}\n\t}\n}\n\n/**\n * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),\n * any state read inside `fn` will not be treated as a dependency.\n *\n * ```ts\n * $effect(() => {\n *   // this will run when `data` changes, but not when `time` changes\n *   save(data, {\n *     timestamp: untrack(() => time)\n *   });\n * });\n * ```\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tvar previous_untracking = untracking;\n\ttry {\n\t\tuntracking = true;\n\t\treturn fn();\n\t} finally {\n\t\tuntracking = previous_untracking;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\t/** @type {Record<string, unknown>} */\n\tvar result = {};\n\n\tfor (var key in obj) {\n\t\tif (!keys.includes(key)) {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible SvelteDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/** @import { Derived, Effect } from '#client' */\nimport { DEV } from 'esm-env';\nimport { CLEAN, DERIVED, DIRTY, EFFECT_HAS_DERIVED, MAYBE_DIRTY, UNOWNED } from '../constants.js';\nimport {\n\tactive_reaction,\n\tactive_effect,\n\tset_signal_status,\n\tskip_reaction,\n\tupdate_reaction,\n\tincrement_write_version,\n\tset_active_effect,\n\tpush_reaction_value\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { destroy_effect } from './effects.js';\nimport { inspect_effects, set_inspect_effects } from './sources.js';\nimport { get_stack } from '../dev/tracing.js';\nimport { tracing_mode_flag } from '../../flags/index.js';\nimport { component_context } from '../context.js';\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tvar flags = DERIVED | DIRTY;\n\tvar parent_derived =\n\t\tactive_reaction !== null && (active_reaction.f & DERIVED) !== 0\n\t\t\t? /** @type {Derived} */ (active_reaction)\n\t\t\t: null;\n\n\tif (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {\n\t\tflags |= UNOWNED;\n\t} else {\n\t\t// Since deriveds are evaluated lazily, any effects created inside them are\n\t\t// created too late to ensure that the parent effect is added to the tree\n\t\tactive_effect.f |= EFFECT_HAS_DERIVED;\n\t}\n\n\t/** @type {Derived<V>} */\n\tconst signal = {\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\teffects: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfn,\n\t\treactions: null,\n\t\trv: 0,\n\t\tv: /** @type {V} */ (null),\n\t\twv: 0,\n\t\tparent: parent_derived ?? active_effect\n\t};\n\n\tif (DEV && tracing_mode_flag) {\n\t\tsignal.created = get_stack('CreatedAt');\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\nexport function user_derived(fn) {\n\tconst d = derived(fn);\n\n\tpush_reaction_value(d);\n\n\treturn d;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nexport function destroy_derived_effects(derived) {\n\tvar effects = derived.effects;\n\n\tif (effects !== null) {\n\t\tderived.effects = null;\n\n\t\tfor (var i = 0; i < effects.length; i += 1) {\n\t\t\tdestroy_effect(/** @type {Effect} */ (effects[i]));\n\t\t}\n\t}\n}\n\n/**\n * The currently updating deriveds, used to detect infinite recursion\n * in dev mode and provide a nicer error than 'too much recursion'\n * @type {Derived[]}\n */\nlet stack = [];\n\n/**\n * @param {Derived} derived\n * @returns {Effect | null}\n */\nfunction get_derived_parent_effect(derived) {\n\tvar parent = derived.parent;\n\twhile (parent !== null) {\n\t\tif ((parent.f & DERIVED) === 0) {\n\t\t\treturn /** @type {Effect} */ (parent);\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\treturn null;\n}\n\n/**\n * @template T\n * @param {Derived} derived\n * @returns {T}\n */\nfunction execute_derived(derived) {\n\tvar value;\n\tvar prev_active_effect = active_effect;\n\n\tset_active_effect(get_derived_parent_effect(derived));\n\n\tif (DEV) {\n\t\tlet prev_inspect_effects = inspect_effects;\n\t\tset_inspect_effects(new Set());\n\t\ttry {\n\t\t\tif (stack.includes(derived)) {\n\t\t\t\te.derived_references_self();\n\t\t\t}\n\n\t\t\tstack.push(derived);\n\n\t\t\tdestroy_derived_effects(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t\tset_inspect_effects(prev_inspect_effects);\n\t\t\tstack.pop();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tdestroy_derived_effects(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar value = execute_derived(derived);\n\tvar status =\n\t\t(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.wv = increment_write_version();\n\t}\n}\n","/** @import { TemplateNode } from '#client' */\n\nimport {\n\tHYDRATION_END,\n\tHYDRATION_ERROR,\n\tHYDRATION_START,\n\tHYDRATION_START_ELSE\n} from '../../../constants.js';\nimport * as w from '../warnings.js';\nimport { get_next_sibling } from './operations.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * The node that is currently being hydrated. This starts out as the first node inside the opening\n * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.\n * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the\n * time we leave the block it is the closing comment, which serves as the block's anchor.\n * @type {TemplateNode}\n */\nexport let hydrate_node;\n\n/** @param {TemplateNode} node */\nexport function set_hydrate_node(node) {\n\tif (node === null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\treturn (hydrate_node = node);\n}\n\nexport function hydrate_next() {\n\treturn set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));\n}\n\n/** @param {TemplateNode} node */\nexport function reset(node) {\n\tif (!hydrating) return;\n\n\t// If the node has remaining siblings, something has gone wrong\n\tif (get_next_sibling(hydrate_node) !== null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\thydrate_node = node;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n */\nexport function hydrate_template(template) {\n\tif (hydrating) {\n\t\t// @ts-expect-error TemplateNode doesn't include DocumentFragment, but it's actually fine\n\t\thydrate_node = template.content;\n\t}\n}\n\nexport function next(count = 1) {\n\tif (hydrating) {\n\t\tvar i = count;\n\t\tvar node = hydrate_node;\n\n\t\twhile (i--) {\n\t\t\tnode = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\t}\n\n\t\thydrate_node = node;\n\t}\n}\n\n/**\n * Removes all nodes starting at `hydrate_node` up until the next hydration end comment\n */\nexport function remove_nodes() {\n\tvar depth = 0;\n\tvar node = hydrate_node;\n\n\twhile (true) {\n\t\tif (node.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (node).data;\n\n\t\t\tif (data === HYDRATION_END) {\n\t\t\t\tif (depth === 0) return node;\n\t\t\t\tdepth -= 1;\n\t\t\t} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {\n\t\t\t\tdepth += 1;\n\t\t\t}\n\t\t}\n\n\t\tvar next = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tnode.remove();\n\t\tnode = next;\n\t}\n}\n","/** @import { TemplateNode } from '#client' */\nimport { hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\nimport { get_descriptor, is_extensible } from '../../shared/utils.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/** @type {boolean} */\nexport var is_firefox;\n\n/** @type {() => Node | null} */\nvar first_child_getter;\n/** @type {() => Node | null} */\nvar next_sibling_getter;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\tis_firefox = /Firefox/.test(navigator.userAgent);\n\n\tvar element_prototype = Element.prototype;\n\tvar node_prototype = Node.prototype;\n\tvar text_prototype = Text.prototype;\n\n\t// @ts-ignore\n\tfirst_child_getter = get_descriptor(node_prototype, 'firstChild').get;\n\t// @ts-ignore\n\tnext_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;\n\n\tif (is_extensible(element_prototype)) {\n\t\t// the following assignments improve perf of lookups on DOM nodes\n\t\t// @ts-expect-error\n\t\telement_prototype.__click = undefined;\n\t\t// @ts-expect-error\n\t\telement_prototype.__className = undefined;\n\t\t// @ts-expect-error\n\t\telement_prototype.__attributes = null;\n\t\t// @ts-expect-error\n\t\telement_prototype.__style = undefined;\n\t\t// @ts-expect-error\n\t\telement_prototype.__e = undefined;\n\t}\n\n\tif (is_extensible(text_prototype)) {\n\t\t// @ts-expect-error\n\t\ttext_prototype.__t = undefined;\n\t}\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/**\n * @param {string} value\n * @returns {Text}\n */\nexport function create_text(value = '') {\n\treturn document.createTextNode(value);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_first_child(node) {\n\treturn first_child_getter.call(node);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_next_sibling(node) {\n\treturn next_sibling_getter.call(node);\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function child(node, is_text) {\n\tif (!hydrating) {\n\t\treturn get_first_child(node);\n\t}\n\n\tvar child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\tchild = hydrate_node.appendChild(create_text());\n\t} else if (is_text && child.nodeType !== 3) {\n\t\tvar text = create_text();\n\t\tchild?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(child);\n\treturn child;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {DocumentFragment | TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\tvar first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));\n\n\t\t// TODO prevent user comments with the empty string when preserveComments is true\n\t\tif (first instanceof Comment && first.data === '') return get_next_sibling(first);\n\n\t\treturn first;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && hydrate_node?.nodeType !== 3) {\n\t\tvar text = create_text();\n\n\t\thydrate_node?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\treturn hydrate_node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {TemplateNode} node\n * @param {number} count\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function sibling(node, count = 1, is_text = false) {\n\tlet next_sibling = hydrating ? hydrate_node : node;\n\tvar last_sibling;\n\n\twhile (count--) {\n\t\tlast_sibling = next_sibling;\n\t\tnext_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));\n\t}\n\n\tif (!hydrating) {\n\t\treturn next_sibling;\n\t}\n\n\tvar type = next_sibling?.nodeType;\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = create_text();\n\t\t// If the next sibling is `null` and we're handling text then it's because\n\t\t// the SSR content was empty for the text, so we need to generate a new text\n\t\t// node and insert it after the last sibling\n\t\tif (next_sibling === null) {\n\t\t\tlast_sibling?.after(text);\n\t\t} else {\n\t\t\tnext_sibling.before(text);\n\t\t}\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(next_sibling);\n\treturn /** @type {TemplateNode} */ (next_sibling);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n","/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */\nimport {\n\tcheck_dirtiness,\n\tactive_effect,\n\tactive_reaction,\n\tupdate_effect,\n\tget,\n\tis_destroying_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_active_reaction,\n\tset_is_destroying_effect,\n\tset_signal_status,\n\tuntrack,\n\tuntracking\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT,\n\tHEAD_EFFECT,\n\tMAYBE_DIRTY,\n\tEFFECT_HAS_DERIVED,\n\tBOUNDARY_EFFECT\n} from '../constants.js';\nimport { set } from './sources.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../../shared/utils.js';\nimport { get_next_sibling } from '../dom/operations.js';\nimport { derived } from './deriveds.js';\nimport { component_context, dev_current_component_function } from '../context.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (active_effect === null && active_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect} parent_effect\n */\nfunction push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @param {boolean} push\n * @returns {Effect}\n */\nfunction create_effect(type, fn, sync, push = true) {\n\tvar parent = active_effect;\n\n\tif (DEV) {\n\t\t// Ensure the parent is never an inspect effect\n\t\twhile (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {\n\t\t\tparent = parent.parent;\n\t\t}\n\t}\n\n\t/** @type {Effect} */\n\tvar effect = {\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\tnodes_start: null,\n\t\tnodes_end: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null,\n\t\twv: 0\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\ttry {\n\t\t\tupdate_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} catch (e) {\n\t\t\tdestroy_effect(effect);\n\t\t\tthrow e;\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.nodes_start === null &&\n\t\teffect.teardown === null &&\n\t\t(effect.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;\n\n\tif (!inert && push) {\n\t\tif (parent !== null) {\n\t\t\tpush_effect(effect, parent);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t\t(derived.effects ??= []).push(effect);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\treturn active_reaction !== null && !untracking;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tactive_effect !== null &&\n\t\t(active_effect.f & BRANCH_EFFECT) !== 0 &&\n\t\tcomponent_context !== null &&\n\t\t!component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {ComponentContext} */ (component_context);\n\t\t(context.e ??= []).push({\n\t\t\tfn,\n\t\t\teffect: active_effect,\n\t\t\treaction: active_reaction\n\t\t});\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * An effect root whose children can transition out\n * @param {() => void} fn\n * @returns {(options?: { outro?: boolean }) => Promise<void>}\n */\nexport function component_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\n\treturn (options = {}) => {\n\t\treturn new Promise((fulfil) => {\n\t\t\tif (options.outro) {\n\t\t\t\tpause_effect(effect, () => {\n\t\t\t\t\tdestroy_effect(effect);\n\t\t\t\t\tfulfil(undefined);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdestroy_effect(effect);\n\t\t\t\tfulfil(undefined);\n\t\t\t}\n\t\t});\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\t/** @type {{ effect: null | Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\t// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through\n\t\t\t// the effects dependencies and correctly ensure each dependency is up-to-date.\n\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t}\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\tupdate_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {(...expressions: any) => void | (() => void)} fn\n * @param {Array<() => any>} thunks\n * @returns {Effect}\n */\nexport function template_effect(fn, thunks = [], d = derived) {\n\tconst deriveds = thunks.map(d);\n\tconst effect = () => fn(...deriveds.map(get));\n\n\tif (DEV) {\n\t\tdefine_property(effect, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\n\treturn block(effect);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {boolean} [push]\n */\nexport function branch(fn, push = true) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);\n}\n\n/**\n * @param {Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = active_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_active_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_active_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @param {boolean} remove_dom\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = false) {\n\tvar effect = signal.first;\n\tsignal.first = signal.last = null;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\n\t\tif ((effect.f & ROOT_EFFECT) !== 0) {\n\t\t\t// this is now an independent root\n\t\t\teffect.parent = null;\n\t\t} else {\n\t\t\tdestroy_effect(effect, remove_dom);\n\t\t}\n\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_block_effect_children(signal) {\n\tvar effect = signal.first;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tif ((effect.f & BRANCH_EFFECT) === 0) {\n\t\t\tdestroy_effect(effect);\n\t\t}\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar removed = false;\n\n\tif ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {\n\t\t/** @type {TemplateNode | null} */\n\t\tvar node = effect.nodes_start;\n\t\tvar end = effect.nodes_end;\n\n\t\twhile (node !== null) {\n\t\t\t/** @type {TemplateNode | null} */\n\t\t\tvar next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));\n\n\t\t\tnode.remove();\n\t\t\tnode = next;\n\t\t}\n\n\t\tremoved = true;\n\t}\n\n\tdestroy_effect_children(effect, remove_dom && !removed);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tvar transitions = effect.transitions;\n\n\tif (transitions !== null) {\n\t\tfor (const transition of transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\tif (DEV) {\n\t\teffect.component_function = null;\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\t// we don't null out `parent` so that error propagation can work correctly\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.deps =\n\t\teffect.fn =\n\t\teffect.nodes_start =\n\t\teffect.nodes_end =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\teffect.f ^= INERT;\n\n\t// Ensure the effect is marked as clean again so that any dirty child\n\t// effects can schedule themselves for execution\n\tif ((effect.f & CLEAN) === 0) {\n\t\teffect.f ^= CLEAN;\n\t}\n\n\t// If a dependency of this effect changed while it was paused,\n\t// schedule the effect to update\n\tif (check_dirtiness(effect)) {\n\t\tset_signal_status(effect, DIRTY);\n\t\tschedule_effect(effect);\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead\n * @returns {never}\n */\nexport function invalid_default_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_default_snippet\\nCannot use \\`{@render children(...)}\\` if the parent component uses \\`let:\\` directives. Consider using a named snippet instead\\nhttps://svelte.dev/e/invalid_default_snippet`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/invalid_default_snippet`);\n\t}\n}\n\n/**\n * `%name%(...)` can only be used during component initialisation\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_outside_component(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_outside_component\\n\\`${name}(...)\\` can only be used during component initialisation\\nhttps://svelte.dev/e/lifecycle_outside_component`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/lifecycle_outside_component`);\n\t}\n}\n\n/**\n * `%name%` is not a store with a `subscribe` method\n * @param {string} name\n * @returns {never}\n */\nexport function store_invalid_shape(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`store_invalid_shape\\n\\`${name}\\` is not a store with a \\`subscribe\\` method\\nhttps://svelte.dev/e/store_invalid_shape`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/store_invalid_shape`);\n\t}\n}\n\n/**\n * The `this` prop on `<svelte:element>` must be a string, if defined\n * @returns {never}\n */\nexport function svelte_element_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_element_invalid_this_value\\nThe \\`this\\` prop on \\`<svelte:element>\\` must be a string, if defined\\nhttps://svelte.dev/e/svelte_element_invalid_this_value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);\n\t}\n}","/** @import { ComponentContext } from '#client' */\n\nimport { DEV } from 'esm-env';\nimport { add_owner } from './dev/ownership.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\nimport { source } from './reactivity/sources.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction,\n\tuntrack\n} from './runtime.js';\nimport { effect, teardown } from './reactivity/effects.js';\nimport { legacy_mode_flag } from '../flags/index.js';\n\n/** @type {ComponentContext | null} */\nexport let component_context = null;\n\n/** @param {ComponentContext | null} context */\nexport function set_component_context(context) {\n\tcomponent_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\n\tif (DEV) {\n\t\t// When state is put into context, we treat as if it's global from now on.\n\t\t// We do for performance reasons (it's for example very expensive to call\n\t\t// getContext on a big object many times when part of a list component)\n\t\t// and danger of false positives.\n\t\tuntrack(() => add_owner(context, null, true));\n\t}\n\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tvar ctx = (component_context = {\n\t\tp: component_context,\n\t\tc: null,\n\t\td: false,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t});\n\n\tif (legacy_mode_flag && !runes) {\n\t\tcomponent_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tteardown(() => {\n\t\t/** @type {ComponentContext} */ (ctx).d = true;\n\t});\n\n\tif (DEV) {\n\t\t// component function\n\t\tcomponent_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst component_effects = context_stack_item.e;\n\t\tif (component_effects !== null) {\n\t\t\tvar previous_effect = active_effect;\n\t\t\tvar previous_reaction = active_reaction;\n\t\t\tcontext_stack_item.e = null;\n\t\t\ttry {\n\t\t\t\tfor (var i = 0; i < component_effects.length; i++) {\n\t\t\t\t\tvar component_effect = component_effects[i];\n\t\t\t\t\tset_active_effect(component_effect.effect);\n\t\t\t\t\tset_active_reaction(component_effect.reaction);\n\t\t\t\t\teffect(component_effect.fn);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t\tset_active_reaction(previous_reaction);\n\t\t\t}\n\t\t}\n\t\tcomponent_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn !legacy_mode_flag || (component_context !== null && component_context.l === null);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (component_context.c ??= new Map(get_parent_context(component_context) || undefined));\n}\n\n/**\n * @param {ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n","const regex_return_characters = /\\r/g;\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport function hash(str) {\n\tstr = str.replace(regex_return_characters, '');\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn (hash >>> 0).toString(36);\n}\n\nconst VOID_ELEMENT_NAMES = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr'\n];\n\n/**\n * Returns `true` if `name` is of a void element\n * @param {string} name\n */\nexport function is_void(name) {\n\treturn VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';\n}\n\nconst RESERVED_WORDS = [\n\t'arguments',\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n];\n\n/**\n * Returns `true` if `word` is a reserved JavaScript keyword\n * @param {string} word\n */\nexport function is_reserved(word) {\n\treturn RESERVED_WORDS.includes(word);\n}\n\n/**\n * @param {string} name\n */\nexport function is_capture_event(name) {\n\treturn name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';\n}\n\n/** List of Element events that will be delegated */\nconst DELEGATED_EVENTS = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/**\n * Returns `true` if `event_name` is a delegated event\n * @param {string} event_name\n */\nexport function is_delegated(event_name) {\n\treturn DELEGATED_EVENTS.includes(event_name);\n}\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nconst DOM_BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'inert',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory',\n\t'defer',\n\t'disablepictureinpicture',\n\t'disableremoteplayback'\n];\n\n/**\n * Returns `true` if `name` is a boolean attribute\n * @param {string} name\n */\nexport function is_boolean_attribute(name) {\n\treturn DOM_BOOLEAN_ATTRIBUTES.includes(name);\n}\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nconst ATTRIBUTE_ALIASES = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly',\n\tdefaultvalue: 'defaultValue',\n\tdefaultchecked: 'defaultChecked',\n\tsrcobject: 'srcObject',\n\tnovalidate: 'noValidate',\n\tallowfullscreen: 'allowFullscreen',\n\tdisablepictureinpicture: 'disablePictureInPicture',\n\tdisableremoteplayback: 'disableRemotePlayback'\n};\n\n/**\n * @param {string} name\n */\nexport function normalize_attribute(name) {\n\tname = name.toLowerCase();\n\treturn ATTRIBUTE_ALIASES[name] ?? name;\n}\n\nconst DOM_PROPERTIES = [\n\t...DOM_BOOLEAN_ATTRIBUTES,\n\t'formNoValidate',\n\t'isMap',\n\t'noModule',\n\t'playsInline',\n\t'readOnly',\n\t'value',\n\t'volume',\n\t'defaultValue',\n\t'defaultChecked',\n\t'srcObject',\n\t'noValidate',\n\t'allowFullscreen',\n\t'disablePictureInPicture',\n\t'disableRemotePlayback'\n];\n\n/**\n * @param {string} name\n */\nexport function is_dom_property(name) {\n\treturn DOM_PROPERTIES.includes(name);\n}\n\nconst NON_STATIC_PROPERTIES = ['autofocus', 'muted', 'defaultValue', 'defaultChecked'];\n\n/**\n * Returns `true` if the given attribute cannot be set through the template\n * string, i.e. needs some kind of JavaScript handling to work.\n * @param {string} name\n */\nexport function cannot_be_set_statically(name) {\n\treturn NON_STATIC_PROPERTIES.includes(name);\n}\n\n/**\n * Subset of delegated events which should be passive by default.\n * These two are already passive via browser defaults on window, document and body.\n * But since\n * - we're delegating them\n * - they happen often\n * - they apply to mobile which is generally less performant\n * we're marking them as passive by default for other elements, too.\n */\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove'];\n\n/**\n * Returns `true` if `name` is a passive event\n * @param {string} name\n */\nexport function is_passive_event(name) {\n\treturn PASSIVE_EVENTS.includes(name);\n}\n\nconst CONTENT_EDITABLE_BINDINGS = ['textContent', 'innerHTML', 'innerText'];\n\n/** @param {string} name */\nexport function is_content_editable_binding(name) {\n\treturn CONTENT_EDITABLE_BINDINGS.includes(name);\n}\n\nconst LOAD_ERROR_ELEMENTS = [\n\t'body',\n\t'embed',\n\t'iframe',\n\t'img',\n\t'link',\n\t'object',\n\t'script',\n\t'style',\n\t'track'\n];\n\n/**\n * Returns `true` if the element emits `load` and `error` events\n * @param {string} name\n */\nexport function is_load_error_element(name) {\n\treturn LOAD_ERROR_ELEMENTS.includes(name);\n}\n\nconst SVG_ELEMENTS = [\n\t'altGlyph',\n\t'altGlyphDef',\n\t'altGlyphItem',\n\t'animate',\n\t'animateColor',\n\t'animateMotion',\n\t'animateTransform',\n\t'circle',\n\t'clipPath',\n\t'color-profile',\n\t'cursor',\n\t'defs',\n\t'desc',\n\t'discard',\n\t'ellipse',\n\t'feBlend',\n\t'feColorMatrix',\n\t'feComponentTransfer',\n\t'feComposite',\n\t'feConvolveMatrix',\n\t'feDiffuseLighting',\n\t'feDisplacementMap',\n\t'feDistantLight',\n\t'feDropShadow',\n\t'feFlood',\n\t'feFuncA',\n\t'feFuncB',\n\t'feFuncG',\n\t'feFuncR',\n\t'feGaussianBlur',\n\t'feImage',\n\t'feMerge',\n\t'feMergeNode',\n\t'feMorphology',\n\t'feOffset',\n\t'fePointLight',\n\t'feSpecularLighting',\n\t'feSpotLight',\n\t'feTile',\n\t'feTurbulence',\n\t'filter',\n\t'font',\n\t'font-face',\n\t'font-face-format',\n\t'font-face-name',\n\t'font-face-src',\n\t'font-face-uri',\n\t'foreignObject',\n\t'g',\n\t'glyph',\n\t'glyphRef',\n\t'hatch',\n\t'hatchpath',\n\t'hkern',\n\t'image',\n\t'line',\n\t'linearGradient',\n\t'marker',\n\t'mask',\n\t'mesh',\n\t'meshgradient',\n\t'meshpatch',\n\t'meshrow',\n\t'metadata',\n\t'missing-glyph',\n\t'mpath',\n\t'path',\n\t'pattern',\n\t'polygon',\n\t'polyline',\n\t'radialGradient',\n\t'rect',\n\t'set',\n\t'solidcolor',\n\t'stop',\n\t'svg',\n\t'switch',\n\t'symbol',\n\t'text',\n\t'textPath',\n\t'tref',\n\t'tspan',\n\t'unknown',\n\t'use',\n\t'view',\n\t'vkern'\n];\n\n/** @param {string} name */\nexport function is_svg(name) {\n\treturn SVG_ELEMENTS.includes(name);\n}\n\nconst MATHML_ELEMENTS = [\n\t'annotation',\n\t'annotation-xml',\n\t'maction',\n\t'math',\n\t'merror',\n\t'mfrac',\n\t'mi',\n\t'mmultiscripts',\n\t'mn',\n\t'mo',\n\t'mover',\n\t'mpadded',\n\t'mphantom',\n\t'mprescripts',\n\t'mroot',\n\t'mrow',\n\t'ms',\n\t'mspace',\n\t'msqrt',\n\t'mstyle',\n\t'msub',\n\t'msubsup',\n\t'msup',\n\t'mtable',\n\t'mtd',\n\t'mtext',\n\t'mtr',\n\t'munder',\n\t'munderover',\n\t'semantics'\n];\n\n/** @param {string} name */\nexport function is_mathml(name) {\n\treturn MATHML_ELEMENTS.includes(name);\n}\n\nconst RUNES = /** @type {const} */ ([\n\t'$state',\n\t'$state.raw',\n\t'$state.snapshot',\n\t'$props',\n\t'$props.id',\n\t'$bindable',\n\t'$derived',\n\t'$derived.by',\n\t'$effect',\n\t'$effect.pre',\n\t'$effect.tracking',\n\t'$effect.root',\n\t'$inspect',\n\t'$inspect().with',\n\t'$inspect.trace',\n\t'$host'\n]);\n\n/**\n * @param {string} name\n * @returns {name is RUNES[number]}\n */\nexport function is_rune(name) {\n\treturn RUNES.includes(/** @type {RUNES[number]} */ (name));\n}\n\n/** List of elements that require raw contents and should not have SSR comments put in them */\nconst RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);\n\n/** @param {string} name */\nexport function is_raw_text_element(name) {\n\treturn RAW_TEXT_ELEMENTS.includes(/** @type {RAW_TEXT_ELEMENTS[number]} */ (name));\n}\n\n/**\n * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space\n * @param {string | undefined} location\n */\nexport function sanitize_location(location) {\n\treturn location?.replace(/\\//g, '/\\u200b');\n}\n","import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { teardown } from '../../../reactivity/effects.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../../runtime.js';\nimport { add_form_reset_listener } from '../misc.js';\n\n/**\n * Fires the handler once immediately (unless corresponding arg is set to `false`),\n * then listens to the given events until the render effect context is destroyed\n * @param {EventTarget} target\n * @param {Array<string>} events\n * @param {(event?: Event) => void} handler\n * @param {any} call_handler_immediately\n */\nexport function listen(target, events, handler, call_handler_immediately = true) {\n\tif (call_handler_immediately) {\n\t\thandler();\n\t}\n\n\tfor (var name of events) {\n\t\ttarget.addEventListener(name, handler);\n\t}\n\n\tteardown(() => {\n\t\tfor (var name of events) {\n\t\t\ttarget.removeEventListener(name, handler);\n\t\t}\n\t});\n}\n\n/**\n * @template T\n * @param {() => T} fn\n */\nexport function without_reactive_context(fn) {\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * Listen to the given event, and then instantiate a global form reset listener if not already done,\n * to notify all bindings when the form is reset\n * @param {HTMLElement} element\n * @param {string} event\n * @param {(is_reset?: true) => void} handler\n * @param {(is_reset?: true) => void} [on_reset]\n */\nexport function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {\n\telement.addEventListener(event, () => without_reactive_context(handler));\n\t// @ts-expect-error\n\tconst prev = element.__on_r;\n\tif (prev) {\n\t\t// special case for checkbox that can have multiple binds (group & checked)\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => {\n\t\t\tprev();\n\t\t\ton_reset(true);\n\t\t};\n\t} else {\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => on_reset(true);\n\t}\n\n\tadd_form_reset_listener();\n}\n","/** @import { Location } from 'locate-character' */\nimport { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { without_reactive_context } from './bindings/shared.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} [handler]\n * @param {AddEventListenerOptions} [options]\n */\nexport function create_event(event_name, dom, handler, options = {}) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn without_reactive_context(() => {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} [handler]\n * @param {boolean} [capture]\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (\n\t\t\t\t\tdelegated != null &&\n\t\t\t\t\t(!(/** @type {any} */ (current_target).disabled) ||\n\t\t\t\t\t\t// DOM could've been updated already by the time this is reached, so we check this as well\n\t\t\t\t\t\t// -> the target could not have been disabled because it emits the event in the first place\n\t\t\t\t\t\tevent.target === current_target)\n\t\t\t\t) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler !== 'function' && (has_side_effects || handler != null || error)) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\t\tconst phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? 'capture' : '';\n\t\tconst event_name = args[0]?.type + phase;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n\thandler?.apply(element, args);\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { create_text, get_first_child, is_firefox } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar fn = template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar fn = ns_template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case — void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n\n/**\n * Create (or hydrate) an unique UID for the component instance.\n */\nexport function props_id() {\n\tif (\n\t\thydrating &&\n\t\thydrate_node &&\n\t\thydrate_node.nodeType === 8 &&\n\t\thydrate_node.textContent?.startsWith(`#`)\n\t) {\n\t\tconst id = hydrate_node.textContent.substring(1);\n\t\thydrate_next();\n\t\treturn id;\n\t}\n\n\t// @ts-expect-error This way we ensure the id is unique even across Svelte runtimes\n\t(window.__svelte ??= {}).uid ??= 1;\n\n\t// @ts-expect-error\n\treturn `c${window.__svelte.uid++}`;\n}\n","/** @import { ComponentContext, Effect, TemplateNode } from '#client' */\n/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tinit_operations\n} from './dom/operations.js';\nimport { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js';\nimport { active_effect } from './runtime.js';\nimport { push, pop, component_context } from './context.js';\nimport { component_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tset_hydrate_node,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from '../shared/utils.js';\nimport {\n\tall_registered_events,\n\thandle_event_propagation,\n\troot_event_handles\n} from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { assign_nodes } from './dom/template.js';\nimport { is_passive_event } from '../../utils.js';\n\n/**\n * This is normally true — block effects should run their intro transitions —\n * but is false during hydration (unless `options.intro` is `true`) and\n * when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\n\t// @ts-expect-error\n\tif (str !== (text.__t ??= text.nodeValue)) {\n\t\t// @ts-expect-error\n\t\ttext.__t = str;\n\t\ttext.nodeValue = str + '';\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.\n * Transitions will play during the initial render unless the `intro` option is set to `false`.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {MountOptions<Props>} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\treturn _mount(component, options);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tinit_operations();\n\toptions.intro = options.intro ?? false;\n\tconst target = options.target;\n\tconst was_hydrating = hydrating;\n\tconst previous_hydrate_node = hydrate_node;\n\n\ttry {\n\t\tvar anchor = /** @type {TemplateNode} */ (get_first_child(target));\n\t\twhile (\n\t\t\tanchor &&\n\t\t\t(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)\n\t\t) {\n\t\t\tanchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));\n\t\t}\n\n\t\tif (!anchor) {\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(true);\n\t\tset_hydrate_node(/** @type {Comment} */ (anchor));\n\t\thydrate_next();\n\n\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\tif (\n\t\t\thydrate_node === null ||\n\t\t\thydrate_node.nodeType !== 8 ||\n\t\t\t/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END\n\t\t) {\n\t\t\tw.hydration_mismatch();\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(false);\n\n\t\treturn /**  @type {Exports} */ (instance);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(was_hydrating);\n\t\tset_hydrate_node(previous_hydrate_node);\n\t\treset_head_anchor();\n\t}\n}\n\n/** @type {Map<string, number>} */\nconst document_listeners = new Map();\n\n/**\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component\n * @param {MountOptions} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\n\tinit_operations();\n\n\tvar registered_events = new Set();\n\n\t/** @param {Array<string>} events */\n\tvar event_handle = (events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t// Add the event listener to both the container and the document.\n\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t// the outer content stops propagation of the event.\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\n\n\t\t\tvar n = document_listeners.get(event_name);\n\n\t\t\tif (n === undefined) {\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\n\t\t\t\tdocument_listeners.set(event_name, 1);\n\t\t\t} else {\n\t\t\t\tdocument_listeners.set(event_name, n + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tvar component = undefined;\n\n\tvar unmount = component_root(() => {\n\t\tvar anchor_node = anchor ?? target.appendChild(create_text());\n\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {ComponentContext} */ (component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tif (hydrating) {\n\t\t\t\tassign_nodes(/** @type {TemplateNode} */ (anchor_node), null);\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor_node, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (hydrating) {\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (var event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\n\t\t\t\tvar n = /** @type {number} */ (document_listeners.get(event_name));\n\n\t\t\t\tif (--n === 0) {\n\t\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\n\t\t\t\t\tdocument_listeners.delete(event_name);\n\t\t\t\t} else {\n\t\t\t\t\tdocument_listeners.set(event_name, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\troot_event_handles.delete(event_handle);\n\n\t\t\tif (anchor_node !== anchor) {\n\t\t\t\tanchor_node.parentNode?.removeChild(anchor_node);\n\t\t\t}\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n *\n * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.\n *\n * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).\n *\n * ```js\n * import { mount, unmount } from 'svelte';\n * import App from './App.svelte';\n *\n * const app = mount(App, { target: document.body });\n *\n * // later...\n * unmount(app, { outro: true });\n * ```\n * @param {Record<string, any>} component\n * @param {{ outro?: boolean }} [options]\n * @returns {Promise<void>}\n */\nexport function unmount(component, options) {\n\tconst fn = mounted_components.get(component);\n\n\tif (fn) {\n\t\tmounted_components.delete(component);\n\t\treturn fn(options);\n\t}\n\n\tif (DEV) {\n\t\tw.lifecycle_double_unmount();\n\t}\n\n\treturn Promise.resolve();\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn\n * @param {[number,number]} [elseif]\n * @returns {void}\n */\nexport function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {\n\tif (hydrating && root_index === 0) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (\n\t\t/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,\n\t\tflag = true\n\t) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating && hydrate_index !== -1) {\n\t\t\tif (root_index === 0) {\n\t\t\t\tconst data = /** @type {Comment} */ (anchor).data;\n\t\t\t\tif (data === HYDRATION_START) {\n\t\t\t\t\thydrate_index = 0;\n\t\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\t\thydrate_index = Infinity;\n\t\t\t\t} else {\n\t\t\t\t\thydrate_index = parseInt(data.substring(1));\n\t\t\t\t\tif (hydrate_index !== hydrate_index) {\n\t\t\t\t\t\t// if hydrate_index is NaN\n\t\t\t\t\t\t// we set an invalid index to force mismatch\n\t\t\t\t\t\thydrate_index = condition ? Infinity : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is_else = hydrate_index > root_index;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t\thydrate_index = -1; // ignore hydration in next else if\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { UNINITIALIZED } from '../../../../constants.js';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { not_equal, safe_not_equal } from '../../reactivity/equality.js';\nimport { is_runes } from '../../context.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template V\n * @param {TemplateNode} node\n * @param {() => V} get_key\n * @param {(anchor: Node) => TemplateNode | void} render_fn\n * @returns {void}\n */\nexport function key_block(node, get_key, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {V | typeof UNINITIALIZED} */\n\tvar key = UNINITIALIZED;\n\n\t/** @type {Effect} */\n\tvar effect;\n\n\tvar changed = is_runes() ? not_equal : safe_not_equal;\n\n\tblock(() => {\n\t\tif (changed(key, (key = get_key()))) {\n\t\t\tif (effect) {\n\t\t\t\tpause_effect(effect);\n\t\t\t}\n\n\t\t\teffect = branch(() => render_fn(anchor));\n\t\t}\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect, active_reaction, get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\tblock(() => {\n\t\tvar array = get(each_array);\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(\n\t\t\t\t\thydrate_node,\n\t\t\t\t\tstate,\n\t\t\t\t\tprev,\n\t\t\t\t\tnull,\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\ti,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key, get_collection);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @param {() => V[]} get_collection\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags,\n\t\t\t\tget_collection\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the each block isn't inert and an item has an effect that is already inert,\n\t\t\t\t// skip over adding it to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @returns {EachItem}\n */\nfunction create_item(\n\tanchor,\n\tstate,\n\tprev,\n\tnext,\n\tvalue,\n\tkey,\n\tindex,\n\trender_fn,\n\tflags,\n\tget_collection\n) {\n\tvar previous_each_item = current_each_item;\n\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\tif (DEV && reactive) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\t/** @type {Value} */ (v).debug = () => {\n\t\t\tvar collection_index = typeof i === 'number' ? index : i.v;\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[collection_index];\n\t\t};\n\t}\n\n\t/** @type {EachItem} */\n\tvar item = {\n\t\ti,\n\t\tv,\n\t\tk: key,\n\t\ta: null,\n\t\t// @ts-expect-error\n\t\te: null,\n\t\tprev,\n\t\tnext\n\t};\n\n\tcurrent_each_item = item;\n\n\ttry {\n\t\titem.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { FILENAME, HYDRATION_ERROR } from '../../../../constants.js';\nimport { block, branch, destroy_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from '../hydration.js';\nimport { create_fragment_from_html } from '../reconciler.js';\nimport { assign_nodes } from '../template.js';\nimport * as w from '../../warnings.js';\nimport { hash, sanitize_location } from '../../../../utils.js';\nimport { DEV } from 'esm-env';\nimport { dev_current_component_function } from '../../context.js';\nimport { get_first_child, get_next_sibling } from '../operations.js';\n\n/**\n * @param {Element} element\n * @param {string | null} server_hash\n * @param {string} value\n */\nfunction check_hash(element, server_hash, value) {\n\tif (!server_hash || server_hash === hash(String(value ?? ''))) return;\n\n\tlet location;\n\n\t// @ts-expect-error\n\tconst loc = element.__svelte_meta?.loc;\n\tif (loc) {\n\t\tlocation = `near ${loc.file}:${loc.line}:${loc.column}`;\n\t} else if (dev_current_component_function?.[FILENAME]) {\n\t\tlocation = `in ${dev_current_component_function[FILENAME]}`;\n\t}\n\n\tw.hydration_html_changed(sanitize_location(location));\n}\n\n/**\n * @param {Element | Text | Comment} node\n * @param {() => string} get_value\n * @param {boolean} svg\n * @param {boolean} mathml\n * @param {boolean} [skip_warning]\n * @returns {void}\n */\nexport function html(node, get_value, svg, mathml, skip_warning) {\n\tvar anchor = node;\n\n\tvar value = '';\n\n\t/** @type {Effect | undefined} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (value === (value = get_value() ?? '')) {\n\t\t\tif (hydrating) {\n\t\t\t\thydrate_next();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (effect !== undefined) {\n\t\t\tdestroy_effect(effect);\n\t\t\teffect = undefined;\n\t\t}\n\n\t\tif (value === '') return;\n\n\t\teffect = branch(() => {\n\t\t\tif (hydrating) {\n\t\t\t\t// We're deliberately not trying to repair mismatches between server and client,\n\t\t\t\t// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)\n\t\t\t\tvar hash = /** @type {Comment} */ (hydrate_node).data;\n\t\t\t\tvar next = hydrate_next();\n\t\t\t\tvar last = next;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext !== null &&\n\t\t\t\t\t(next.nodeType !== 8 || /** @type {Comment} */ (next).data !== '')\n\t\t\t\t) {\n\t\t\t\t\tlast = next;\n\t\t\t\t\tnext = /** @type {TemplateNode} */ (get_next_sibling(next));\n\t\t\t\t}\n\n\t\t\t\tif (next === null) {\n\t\t\t\t\tw.hydration_mismatch();\n\t\t\t\t\tthrow HYDRATION_ERROR;\n\t\t\t\t}\n\n\t\t\t\tif (DEV && !skip_warning) {\n\t\t\t\t\tcheck_hash(/** @type {Element} */ (next.parentNode), hash, value);\n\t\t\t\t}\n\n\t\t\t\tassign_nodes(hydrate_node, last);\n\t\t\t\tanchor = set_hydrate_node(next);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar html = value + '';\n\t\t\tif (svg) html = `<svg>${html}</svg>`;\n\t\t\telse if (mathml) html = `<math>${html}</math>`;\n\n\t\t\t// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.\n\t\t\t// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.\n\t\t\t/** @type {DocumentFragment | Element} */\n\t\t\tvar node = create_fragment_from_html(html);\n\n\t\t\tif (svg || mathml) {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(node));\n\t\t\t}\n\n\t\t\tassign_nodes(\n\t\t\t\t/** @type {TemplateNode} */ (get_first_child(node)),\n\t\t\t\t/** @type {TemplateNode} */ (node.lastChild)\n\t\t\t);\n\n\t\t\tif (svg || mathml) {\n\t\t\t\twhile (get_first_child(node)) {\n\t\t\t\t\tanchor.before(/** @type {Node} */ (get_first_child(node)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanchor.before(node);\n\t\t\t}\n\t\t});\n\t});\n}\n","import { hydrate_next, hydrating } from '../hydration.js';\n\n/**\n * @param {Comment} anchor\n * @param {Record<string, any>} $$props\n * @param {string} name\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor, $$props, name, slot_props, fallback_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar slot_fn = $$props.$$slots?.[name];\n\t// Interop: Can use snippets to fill slots\n\tvar is_interop = false;\n\tif (slot_fn === true) {\n\t\tslot_fn = $$props[name === 'default' ? 'children' : name];\n\t\tis_interop = true;\n\t}\n\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor, is_interop ? () => slot_props : slot_props);\n\t}\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, boolean>}\n */\nexport function sanitize_slots(props) {\n\t/** @type {Record<string, boolean>} */\n\tconst sanitized = {};\n\tif (props.children) sanitized.default = true;\n\tfor (const key in props.$$slots) {\n\t\tsanitized[key] = true;\n\t}\n\treturn sanitized;\n}\n","/** @import { TemplateNode, Dom, Effect } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template P\n * @template {(props: P) => void} C\n * @param {TemplateNode} node\n * @param {() => C} get_component\n * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn\n * @returns {void}\n */\nexport function component(node, get_component, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {C} */\n\tvar component;\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (component === (component = get_component())) return;\n\n\t\tif (effect) {\n\t\t\tpause_effect(effect);\n\t\t\teffect = null;\n\t\t}\n\n\t\tif (component) {\n\t\t\teffect = branch(() => render_fn(anchor, component));\n\t\t}\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { ActionPayload } from '#client' */\nimport { effect, render_effect } from '../../reactivity/effects.js';\nimport { safe_not_equal } from '../../reactivity/equality.js';\nimport { deep_read_state, untrack } from '../../runtime.js';\n\n/**\n * @template P\n * @param {Element} dom\n * @param {(dom: Element, value?: P) => ActionPayload<P>} action\n * @param {() => P} [get_value]\n * @returns {void}\n */\nexport function action(dom, action, get_value) {\n\teffect(() => {\n\t\tvar payload = untrack(() => action(dom, get_value?.()) || {});\n\n\t\tif (get_value && payload?.update) {\n\t\t\tvar inited = false;\n\t\t\t/** @type {P} */\n\t\t\tvar prev = /** @type {any} */ ({}); // initialize with something so it's never equal on first run\n\n\t\t\trender_effect(() => {\n\t\t\t\tvar value = get_value();\n\n\t\t\t\t// Action's update method is coarse-grained, i.e. when anything in the passed value changes, update.\n\t\t\t\t// This works in legacy mode because of mutable_source being updated as a whole, but when using $state\n\t\t\t\t// together with actions and mutation, it wouldn't notice the change without a deep read.\n\t\t\t\tdeep_read_state(value);\n\n\t\t\t\tif (inited && safe_not_equal(prev, value)) {\n\t\t\t\t\tprev = value;\n\t\t\t\t\t/** @type {Function} */ (payload.update)(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tinited = true;\n\t\t}\n\n\t\tif (payload?.destroy) {\n\t\t\treturn () => /** @type {Function} */ (payload.destroy)();\n\t\t}\n\t});\n}\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","import { escape_html } from '../../escaping.js';\nimport { clsx as _clsx } from 'clsx';\n\n/**\n * `<div translate={false}>` should be rendered as `<div translate=\"no\">` and _not_\n * `<div translate=\"false\">`, which is equivalent to `<div translate=\"yes\">`. There\n * may be other odd cases that need to be added to this list in future\n * @type {Record<string, Map<any, string>>}\n */\nconst replacements = {\n\ttranslate: new Map([\n\t\t[true, 'yes'],\n\t\t[false, 'no']\n\t])\n};\n\n/**\n * @template V\n * @param {string} name\n * @param {V} value\n * @param {boolean} [is_boolean]\n * @returns {string}\n */\nexport function attr(name, value, is_boolean = false) {\n\tif (value == null || (!value && is_boolean)) return '';\n\tconst normalized = (name in replacements && replacements[name].get(value)) || value;\n\tconst assignment = is_boolean ? '' : `=\"${escape_html(normalized, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/**\n * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.\n * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)\n * @param  {any} value\n */\nexport function clsx(value) {\n\tif (typeof value === 'object') {\n\t\treturn _clsx(value);\n\t} else {\n\t\treturn value ?? '';\n\t}\n}\n\nconst whitespace = [...' \\t\\n\\r\\f\\u00a0\\u000b\\ufeff'];\n\n/**\n * @param {any} value\n * @param {string | null} [hash]\n * @param {Record<string, boolean>} [directives]\n * @returns {string | null}\n */\nexport function to_class(value, hash, directives) {\n\tvar classname = value == null ? '' : '' + value;\n\n\tif (hash) {\n\t\tclassname = classname ? classname + ' ' + hash : hash;\n\t}\n\n\tif (directives) {\n\t\tfor (var key in directives) {\n\t\t\tif (directives[key]) {\n\t\t\t\tclassname = classname ? classname + ' ' + key : key;\n\t\t\t} else if (classname.length) {\n\t\t\t\tvar len = key.length;\n\t\t\t\tvar a = 0;\n\n\t\t\t\twhile ((a = classname.indexOf(key, a)) >= 0) {\n\t\t\t\t\tvar b = a + len;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(a === 0 || whitespace.includes(classname[a - 1])) &&\n\t\t\t\t\t\t(b === classname.length || whitespace.includes(classname[b]))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclassname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn classname === '' ? null : classname;\n}\n\n/**\n *\n * @param {Record<string,any>} styles\n * @param {boolean} important\n */\nfunction append_styles(styles, important = false) {\n\tvar separator = important ? ' !important;' : ';';\n\tvar css = '';\n\n\tfor (var key in styles) {\n\t\tvar value = styles[key];\n\t\tif (value != null && value !== '') {\n\t\t\tcss += ' ' + key + ': ' + value + separator;\n\t\t}\n\t}\n\n\treturn css;\n}\n\n/**\n * @param {string} name\n * @returns {string}\n */\nfunction to_css_name(name) {\n\tif (name[0] !== '-' || name[1] !== '-') {\n\t\treturn name.toLowerCase();\n\t}\n\treturn name;\n}\n\n/**\n * @param {any} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]\n * @returns {string | null}\n */\nexport function to_style(value, styles) {\n\tif (styles) {\n\t\tvar new_style = '';\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar normal_styles;\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar important_styles;\n\n\t\tif (Array.isArray(styles)) {\n\t\t\tnormal_styles = styles[0];\n\t\t\timportant_styles = styles[1];\n\t\t} else {\n\t\t\tnormal_styles = styles;\n\t\t}\n\n\t\tif (value) {\n\t\t\tvalue = String(value)\n\t\t\t\t.replaceAll(/\\s*\\/\\*.*?\\*\\/\\s*/g, '')\n\t\t\t\t.trim();\n\n\t\t\t/** @type {boolean | '\"' | \"'\"} */\n\t\t\tvar in_str = false;\n\t\t\tvar in_apo = 0;\n\t\t\tvar in_comment = false;\n\n\t\t\tvar reserved_names = [];\n\n\t\t\tif (normal_styles) {\n\t\t\t\treserved_names.push(...Object.keys(normal_styles).map(to_css_name));\n\t\t\t}\n\t\t\tif (important_styles) {\n\t\t\t\treserved_names.push(...Object.keys(important_styles).map(to_css_name));\n\t\t\t}\n\n\t\t\tvar start_index = 0;\n\t\t\tvar name_index = -1;\n\n\t\t\tconst len = value.length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar c = value[i];\n\n\t\t\t\tif (in_comment) {\n\t\t\t\t\tif (c === '/' && value[i - 1] === '*') {\n\t\t\t\t\t\tin_comment = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (in_str) {\n\t\t\t\t\tif (in_str === c) {\n\t\t\t\t\t\tin_str = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (c === '/' && value[i + 1] === '*') {\n\t\t\t\t\tin_comment = true;\n\t\t\t\t} else if (c === '\"' || c === \"'\") {\n\t\t\t\t\tin_str = c;\n\t\t\t\t} else if (c === '(') {\n\t\t\t\t\tin_apo++;\n\t\t\t\t} else if (c === ')') {\n\t\t\t\t\tin_apo--;\n\t\t\t\t}\n\n\t\t\t\tif (!in_comment && in_str === false && in_apo === 0) {\n\t\t\t\t\tif (c === ':' && name_index === -1) {\n\t\t\t\t\t\tname_index = i;\n\t\t\t\t\t} else if (c === ';' || i === len - 1) {\n\t\t\t\t\t\tif (name_index !== -1) {\n\t\t\t\t\t\t\tvar name = to_css_name(value.substring(start_index, name_index).trim());\n\n\t\t\t\t\t\t\tif (!reserved_names.includes(name)) {\n\t\t\t\t\t\t\t\tif (c !== ';') {\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar property = value.substring(start_index, i).trim();\n\t\t\t\t\t\t\t\tnew_style += ' ' + property + ';';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart_index = i + 1;\n\t\t\t\t\t\tname_index = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (normal_styles) {\n\t\t\tnew_style += append_styles(normal_styles);\n\t\t}\n\n\t\tif (important_styles) {\n\t\t\tnew_style += append_styles(important_styles, true);\n\t\t}\n\n\t\tnew_style = new_style.trim();\n\t\treturn new_style === '' ? null : new_style;\n\t}\n\n\treturn value == null ? null : String(value);\n}\n","import { to_class } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element} dom\n * @param {boolean | number} is_html\n * @param {string | null} value\n * @param {string} [hash]\n * @param {Record<string, any>} [prev_classes]\n * @param {Record<string, any>} [next_classes]\n * @returns {Record<string, boolean> | undefined}\n */\nexport function set_class(dom, is_html, value, hash, prev_classes, next_classes) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev = dom.__className;\n\n\tif (\n\t\thydrating ||\n\t\tprev !== value ||\n\t\tprev === undefined // for edge case of `class={undefined}`\n\t) {\n\t\tvar next_class_name = to_class(value, hash, next_classes);\n\n\t\tif (!hydrating || next_class_name !== dom.getAttribute('class')) {\n\t\t\t// Removing the attribute when the value is only an empty string causes\n\t\t\t// performance issues vs simply making the className an empty string. So\n\t\t\t// we should only remove the class if the the value is nullish\n\t\t\t// and there no hash/directives :\n\t\t\tif (next_class_name == null) {\n\t\t\t\tdom.removeAttribute('class');\n\t\t\t} else if (is_html) {\n\t\t\t\tdom.className = next_class_name;\n\t\t\t} else {\n\t\t\t\tdom.setAttribute('class', next_class_name);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = value;\n\t} else if (next_classes && prev_classes !== next_classes) {\n\t\tfor (var key in next_classes) {\n\t\t\tvar is_present = !!next_classes[key];\n\n\t\t\tif (prev_classes == null || is_present !== !!prev_classes[key]) {\n\t\t\t\tdom.classList.toggle(key, is_present);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn next_classes;\n}\n","import { to_style } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {Record<string, any>} prev\n * @param {Record<string, any>} next\n * @param {string} [priority]\n */\nfunction update_styles(dom, prev = {}, next, priority) {\n\tfor (var key in next) {\n\t\tvar value = next[key];\n\n\t\tif (prev[key] !== value) {\n\t\t\tif (next[key] == null) {\n\t\t\t\tdom.style.removeProperty(key);\n\t\t\t} else {\n\t\t\t\tdom.style.setProperty(key, value, priority);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {string | null} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]\n */\nexport function set_style(dom, value, prev_styles, next_styles) {\n\t// @ts-expect-error\n\tvar prev = dom.__style;\n\n\tif (hydrating || prev !== value) {\n\t\tvar next_style_attr = to_style(value, next_styles);\n\n\t\tif (!hydrating || next_style_attr !== dom.getAttribute('style')) {\n\t\t\tif (next_style_attr == null) {\n\t\t\t\tdom.removeAttribute('style');\n\t\t\t} else {\n\t\t\t\tdom.style.cssText = next_style_attr;\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tdom.__style = value;\n\t} else if (next_styles) {\n\t\tif (Array.isArray(next_styles)) {\n\t\t\tupdate_styles(dom, prev_styles?.[0], next_styles[0]);\n\t\t\tupdate_styles(dom, prev_styles?.[1], next_styles[1], 'important');\n\t\t} else {\n\t\t\tupdate_styles(dom, prev_styles, next_styles);\n\t\t}\n\t}\n\n\treturn next_styles;\n}\n","import { DEV } from 'esm-env';\nimport { hydrating, set_hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '../../constants.js';\nimport { queue_idle_task } from '../task.js';\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { clsx } from '../../../shared/attributes.js';\nimport { set_class } from './class.js';\nimport { set_style } from './style.js';\nimport { NAMESPACE_HTML } from '../../../../constants.js';\n\nexport const CLASS = Symbol('class');\nexport const STYLE = Symbol('style');\n\nconst IS_CUSTOM_ELEMENT = Symbol('is custom element');\nconst IS_HTML = Symbol('is html');\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.value ===\n\t\t\t(attributes.value =\n\t\t\t\t// treat null and undefined the same for the initial value\n\t\t\t\tvalue ?? undefined) ||\n\t\t// @ts-expect-error\n\t\t// `progress` elements always need their value set when it's `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.value = value ?? '';\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.checked ===\n\t\t(attributes.checked =\n\t\t\t// treat null and undefined the same for the initial value\n\t\t\tchecked ?? undefined)\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * Sets the `selected` attribute on an `option` element.\n * Not set through the property because that doesn't reflect to the DOM,\n * which means it wouldn't be taken into account when a form is reset.\n * @param {HTMLOptionElement} element\n * @param {boolean} selected\n */\nexport function set_selected(element, selected) {\n\tif (selected) {\n\t\t// The selected option could've changed via user selection, and\n\t\t// setting the value without this check would set it back.\n\t\tif (!element.hasAttribute('selected')) {\n\t\t\telement.setAttribute('selected', '');\n\t\t}\n\t} else {\n\t\telement.removeAttribute('selected');\n\t}\n}\n\n/**\n * Applies the default checked property without influencing the current checked property.\n * @param {HTMLInputElement} element\n * @param {boolean} checked\n */\nexport function set_default_checked(element, checked) {\n\tconst existing_value = element.checked;\n\telement.defaultChecked = checked;\n\telement.checked = existing_value;\n}\n\n/**\n * Applies the default value property without influencing the current value property.\n * @param {HTMLInputElement | HTMLTextAreaElement} element\n * @param {string} value\n */\nexport function set_default_value(element, value) {\n\tconst existing_value = element.value;\n\telement.defaultValue = value;\n\telement.value = existing_value;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\tvar attributes = get_attributes(element);\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\t// We need to ensure that setting custom element props, which can\n\t// invoke lifecycle methods on other custom elements, does not also\n\t// associate those lifecycle methods with the current active reaction\n\t// or effect\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet was_hydrating = hydrating;\n\tif (hydrating) {\n\t\tset_hydrating(false);\n\t}\n\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\tif (\n\t\t\t// `style` should use `set_attribute` rather than the setter\n\t\t\tprop !== 'style' &&\n\t\t\t// Don't compute setters for custom elements while they aren't registered yet,\n\t\t\t// because during their upgrade/instantiation they might add more setters.\n\t\t\t// Instead, fall back to a simple \"an object, then set as property\" heuristic.\n\t\t\t(setters_cache.has(node.nodeName) ||\n\t\t\t// customElements may not be available in browser extension contexts\n\t\t\t!customElements ||\n\t\t\tcustomElements.get(node.tagName.toLowerCase())\n\t\t\t\t? get_setters(node).includes(prop)\n\t\t\t\t: value && typeof value === 'object')\n\t\t) {\n\t\t\t// @ts-expect-error\n\t\t\tnode[prop] = value;\n\t\t} else {\n\t\t\t// We did getters etc checks already, stringify before passing to set_attribute\n\t\t\t// to ensure it doesn't invoke the same logic again, and potentially populating\n\t\t\t// the setters cache too early.\n\t\t\tset_attribute(node, prop, value == null ? value : String(value));\n\t\t}\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t\tif (was_hydrating) {\n\t\t\tset_hydrating(true);\n\t\t}\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string | symbol, any> | undefined} prev\n * @param {Record<string | symbol, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nexport function set_attributes(element, prev, next, css_hash, skip_warning = false) {\n\tvar attributes = get_attributes(element);\n\n\tvar is_custom_element = attributes[IS_CUSTOM_ELEMENT];\n\tvar preserve_attribute_case = !attributes[IS_HTML];\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet is_hydrating_custom_element = hydrating && is_custom_element;\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(false);\n\t}\n\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (next.class) {\n\t\tnext.class = clsx(next.class);\n\t} else if (css_hash || next[CLASS]) {\n\t\tnext.class = null; /* force call to set_class() */\n\t}\n\n\tif (next[STYLE]) {\n\t\tnext.style ??= null; /* force call to set_style() */\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'class') {\n\t\t\tvar is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';\n\t\t\tset_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[CLASS] = next[CLASS];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'style') {\n\t\t\tset_style(element, value, prev?.[STYLE], next[STYLE]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[STYLE] = next[STYLE];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = is_delegated(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t} else if (delegated) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[`__${event_name}`] = undefined;\n\t\t\t}\n\t\t} else if (key === 'style') {\n\t\t\t// avoid using the setter\n\t\t\tset_attribute(element, key, value);\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {\n\t\t\t// @ts-ignore We're not running this for custom elements because __value is actually\n\t\t\t// how Lit stores the current value on the element, and messing with that would break things.\n\t\t\telement.value = element.__value = value;\n\t\t} else if (key === 'selected' && is_option_element) {\n\t\t\tset_selected(/** @type {HTMLOptionElement} */ (element), value);\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tvar is_default = name === 'defaultValue' || name === 'defaultChecked';\n\n\t\t\tif (value == null && !is_custom_element && !is_default) {\n\t\t\t\tattributes[key] = null;\n\n\t\t\t\tif (name === 'value' || name === 'checked') {\n\t\t\t\t\t// removing value/checked also removes defaultValue/defaultChecked — preserve\n\t\t\t\t\tlet input = /** @type {HTMLInputElement} */ (element);\n\t\t\t\t\tconst use_default = prev === undefined;\n\t\t\t\t\tif (name === 'value') {\n\t\t\t\t\t\tlet previous = input.defaultValue;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultValue = previous;\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tinput.value = input.__value = use_default ? previous : null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet previous = input.defaultChecked;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultChecked = previous;\n\t\t\t\t\t\tinput.checked = use_default ? previous : false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.removeAttribute(key);\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tis_default ||\n\t\t\t\t(setters.includes(name) && (is_custom_element || typeof value !== 'string'))\n\t\t\t) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tset_attribute(element, name, value, skip_warning);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(true);\n\t}\n\n\treturn current;\n}\n\n/**\n *\n * @param {Element} element\n */\nfunction get_attributes(element) {\n\treturn /** @type {Record<string | symbol, unknown>} **/ (\n\t\t// @ts-expect-error\n\t\telement.__attributes ??= {\n\t\t\t[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),\n\t\t\t[IS_HTML]: element.namespaceURI === NAMESPACE_HTML\n\t\t}\n\t);\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\n\tvar descriptors;\n\tvar proto = element; // In the case of custom elements there might be setters on the instance\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n","import { DEV } from 'esm-env';\nimport { render_effect, teardown } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport * as e from '../../../errors.js';\nimport { is } from '../../../proxy.js';\nimport { queue_micro_task } from '../../task.js';\nimport { hydrating } from '../../hydration.js';\nimport { untrack } from '../../../runtime.js';\nimport { is_runes } from '../../../context.js';\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_value(input, get, set = get) {\n\tvar runes = is_runes();\n\n\tlisten_to_event_and_reset_event(input, 'input', (is_reset) => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\t/** @type {any} */\n\t\tvar value = is_reset ? input.defaultValue : input.value;\n\t\tvalue = is_numberlike_input(input) ? to_number(value) : value;\n\t\tset(value);\n\n\t\t// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,\n\t\t// because we use mutable state which ensures the render effect always runs)\n\t\tif (runes && value !== (value = get())) {\n\t\t\tvar start = input.selectionStart;\n\t\t\tvar end = input.selectionEnd;\n\n\t\t\t// the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\n\t\t\t// Restore selection\n\t\t\tif (end !== null) {\n\t\t\t\tinput.selectionStart = start;\n\t\t\t\tinput.selectionEnd = Math.min(end, input.value.length);\n\t\t\t}\n\t\t}\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\t(hydrating && input.defaultValue !== input.value) ||\n\t\t// If defaultValue is set, then value == defaultValue\n\t\t// TODO Svelte 6: remove input.value check and set to empty string?\n\t\t(untrack(get) == null && input.value)\n\t) {\n\t\tset(is_numberlike_input(input) ? to_number(input.value) : input.value);\n\t}\n\n\trender_effect(() => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\tvar value = get();\n\n\t\tif (is_numberlike_input(input) && value === to_number(input.value)) {\n\t\t\t// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)\n\t\t\treturn;\n\t\t}\n\n\t\tif (input.type === 'date' && !value && !input.value) {\n\t\t\t// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)\n\t\t\t// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)\n\t\t\treturn;\n\t\t}\n\n\t\t// don't set the value of the input if it's the same to allow\n\t\t// minlength to work properly\n\t\tif (value !== input.value) {\n\t\t\t// @ts-expect-error the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\t\t}\n\t});\n}\n\n/** @type {Set<HTMLInputElement[]>} */\nconst pending = new Set();\n\n/**\n * @param {HTMLInputElement[]} inputs\n * @param {null | [number]} group_index\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_group(inputs, group_index, input, get, set = get) {\n\tvar is_checkbox = input.getAttribute('type') === 'checkbox';\n\tvar binding_group = inputs;\n\n\t// needs to be let or related code isn't treeshaken out if it's always false\n\tlet hydration_mismatch = false;\n\n\tif (group_index !== null) {\n\t\tfor (var index of group_index) {\n\t\t\t// @ts-expect-error\n\t\t\tbinding_group = binding_group[index] ??= [];\n\t\t}\n\t}\n\n\tbinding_group.push(input);\n\n\tlisten_to_event_and_reset_event(\n\t\tinput,\n\t\t'change',\n\t\t() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = input.__value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t}\n\n\t\t\tset(value);\n\t\t},\n\t\t// TODO better default value handling\n\t\t() => set(is_checkbox ? [] : null)\n\t);\n\n\trender_effect(() => {\n\t\tvar value = get();\n\n\t\t// If we are hydrating and the value has since changed, then use the update value\n\t\t// from the input instead.\n\t\tif (hydrating && input.defaultChecked !== input.checked) {\n\t\t\thydration_mismatch = true;\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_checkbox) {\n\t\t\tvalue = value || [];\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = value.includes(input.__value);\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = is(input.__value, value);\n\t\t}\n\t});\n\n\tteardown(() => {\n\t\tvar index = binding_group.indexOf(input);\n\n\t\tif (index !== -1) {\n\t\t\tbinding_group.splice(index, 1);\n\t\t}\n\t});\n\n\tif (!pending.has(binding_group)) {\n\t\tpending.add(binding_group);\n\n\t\tqueue_micro_task(() => {\n\t\t\t// necessary to maintain binding group order in all insertion scenarios\n\t\t\tbinding_group.sort((a, b) => (a.compareDocumentPosition(b) === 4 ? -1 : 1));\n\t\t\tpending.delete(binding_group);\n\t\t});\n\t}\n\n\tqueue_micro_task(() => {\n\t\tif (hydration_mismatch) {\n\t\t\tvar value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t} else {\n\t\t\t\tvar hydration_input = binding_group.find((input) => input.checked);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvalue = hydration_input?.__value;\n\t\t\t}\n\n\t\t\tset(value);\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_checked(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', (is_reset) => {\n\t\tvar value = is_reset ? input.defaultChecked : input.checked;\n\t\tset(value);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the update value from the input instead.\n\t\t(hydrating && input.defaultChecked !== input.checked) ||\n\t\t// If defaultChecked is set, then checked == defaultChecked\n\t\tuntrack(get) == null\n\t) {\n\t\tset(input.checked);\n\t}\n\n\trender_effect(() => {\n\t\tvar value = get();\n\t\tinput.checked = Boolean(value);\n\t});\n}\n\n/**\n * @template V\n * @param {Array<HTMLInputElement>} group\n * @param {V} __value\n * @param {boolean} checked\n * @returns {V[]}\n */\nfunction get_binding_group_value(group, __value, checked) {\n\tvar value = new Set();\n\n\tfor (var i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) {\n\t\t\t// @ts-ignore\n\t\t\tvalue.add(group[i].__value);\n\t\t}\n\t}\n\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement} input\n */\nfunction is_numberlike_input(input) {\n\tvar type = input.type;\n\treturn type === 'number' || type === 'range';\n}\n\n/**\n * @param {string} value\n */\nfunction to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => FileList | null} get\n * @param {(value: FileList | null) => void} set\n */\nexport function bind_files(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', () => {\n\t\tset(input.files);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\thydrating &&\n\t\tinput.files\n\t) {\n\t\tset(input.files);\n\t}\n\n\trender_effect(() => {\n\t\tinput.files = get();\n\t});\n}\n","import { teardown } from '../../../reactivity/effects.js';\nimport { get_descriptor } from '../../../../shared/utils.js';\n\n/**\n * Makes an `export`ed (non-prop) variable available on the `$$props` object\n * so that consumers can do `bind:x` on the component.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {V} value\n * @returns {void}\n */\nexport function bind_prop(props, prop, value) {\n\tvar desc = get_descriptor(props, prop);\n\n\tif (desc && desc.set) {\n\t\tprops[prop] = value;\n\t\tteardown(() => {\n\t\t\tprops[prop] = null;\n\t\t});\n\t}\n}\n","import { effect } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { untrack } from '../../../runtime.js';\nimport { is } from '../../../proxy.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} [mounting]\n */\nexport function select_option(select, value, mounting) {\n\tif (select.multiple) {\n\t\treturn select_options(select, value);\n\t}\n\n\tfor (var option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @template V\n * @param {HTMLSelectElement} select\n * @param {() => V} [get_value]\n */\nexport function init_select(select, get_value) {\n\tlet mounting = true;\n\teffect(() => {\n\t\tif (get_value) {\n\t\t\tselect_option(select, untrack(get_value), mounting);\n\t\t}\n\t\tmounting = false;\n\n\t\tvar observer = new MutationObserver(() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = select.__value;\n\t\t\tselect_option(select, value);\n\t\t\t// Deliberately don't update the potential binding value,\n\t\t\t// the model should be preserved unless explicitly changed\n\t\t});\n\n\t\tobserver.observe(select, {\n\t\t\t// Listen to option element changes\n\t\t\tchildList: true,\n\t\t\tsubtree: true, // because of <optgroup>\n\t\t\t// Listen to option element value attribute changes\n\t\t\t// (doesn't get notified of select value changes,\n\t\t\t// because that property is not reflected as an attribute)\n\t\t\tattributes: true,\n\t\t\tattributeFilter: ['value']\n\t\t});\n\n\t\treturn () => {\n\t\t\tobserver.disconnect();\n\t\t};\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_select_value(select, get, set = get) {\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', (is_reset) => {\n\t\tvar query = is_reset ? '[selected]' : ':checked';\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option =\n\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tset(value);\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get();\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tset(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\t// don't pass get_value, we already initialize it in the effect above\n\tinit_select(select);\n}\n\n/**\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n */\nfunction select_options(select, value) {\n\tfor (var option of select.options) {\n\t\t// @ts-ignore\n\t\toption.selected = ~value.indexOf(get_option_value(option));\n\t}\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n","import { STATE_SYMBOL } from '../../../constants.js';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\treturn (\n\t\tbound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component\n\t);\n}\n\n/**\n * @param {any} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component = {}, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n\n\treturn element_or_component;\n}\n","/** @import { ActionReturn } from 'svelte/action' */\nimport { noop } from '../../../shared/utils.js';\nimport { user_pre_effect } from '../../reactivity/effects.js';\nimport { on } from '../elements/events.js';\n\n/**\n * Substitute for the `trusted` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function trusted(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tif (event.isTrusted) {\n\t\t\t// @ts-ignore\n\t\t\tfn?.apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * Substitute for the `self` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function self(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\t// @ts-ignore\n\t\tif (event.target === this) {\n\t\t\t// @ts-ignore\n\t\t\tfn?.apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * Substitute for the `stopPropagation` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopPropagation(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `once` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function once(fn) {\n\tvar ran = false;\n\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `stopImmediatePropagation` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopImmediatePropagation(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `preventDefault` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function preventDefault(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `passive` event modifier, implemented as an action\n * @deprecated\n * @param {HTMLElement} node\n * @param {[event: string, handler: () => EventListener]} options\n */\nexport function passive(node, [event, handler]) {\n\tuser_pre_effect(() => {\n\t\treturn on(node, event, handler() ?? noop, {\n\t\t\tpassive: true\n\t\t});\n\t});\n}\n\n/**\n * Substitute for the `nonpassive` event modifier, implemented as an action\n * @deprecated\n * @param {HTMLElement} node\n * @param {[event: string, handler: () => EventListener]} options\n */\nexport function nonpassive(node, [event, handler]) {\n\tuser_pre_effect(() => {\n\t\treturn on(node, event, handler() ?? noop, {\n\t\t\tpassive: false\n\t\t});\n\t});\n}\n","/** @import { ComponentContextLegacy } from '#client' */\nimport { run, run_all } from '../../../shared/utils.js';\nimport { component_context } from '../../context.js';\nimport { derived } from '../../reactivity/deriveds.js';\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\nimport { deep_read_state, get, untrack } from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n * @param {boolean} [immutable]\n */\nexport function init(immutable = false) {\n\tconst context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\tconst callbacks = context.l.u;\n\tif (!callbacks) return;\n\n\tlet props = () => deep_read_state(context.s);\n\n\tif (immutable) {\n\t\tlet version = 0;\n\t\tlet prev = /** @type {Record<string, any>} */ ({});\n\n\t\t// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes\n\t\tconst d = derived(() => {\n\t\t\tlet changed = false;\n\t\t\tconst props = context.s;\n\t\t\tfor (const key in props) {\n\t\t\t\tif (props[key] !== prev[key]) {\n\t\t\t\t\tprev[key] = props[key];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (changed) version++;\n\t\t\treturn version;\n\t\t});\n\n\t\tprops = () => get(d);\n\t}\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tuser_pre_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.b);\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.a);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {ComponentContextLegacy} context\n * @param {(() => void)} props\n */\nfunction observe_all(context, props) {\n\tif (context.l.s) {\n\t\tfor (const signal of context.l.s) get(signal);\n\t}\n\n\tprops();\n}\n","import { set, source } from '../../reactivity/sources.js';\nimport { get } from '../../runtime.js';\nimport { is_array } from '../../../shared/utils.js';\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tvar s = source(0);\n\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @this {any}\n * @param {Record<string, unknown>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tvar events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[\n\t\tevent.type\n\t];\n\n\tvar callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];\n\n\tfor (var fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tfn.call(this, event);\n\t}\n}\n\n/**\n * Used to simulate `$on` on a component instance when `compatibility.componentApi === 4`\n * @param {Record<string, any>} $$props\n * @param {string} event_name\n * @param {Function} event_callback\n */\nexport function add_legacy_event_listener($$props, event_name, event_callback) {\n\t$$props.$$events ||= {};\n\t$$props.$$events[event_name] ||= [];\n\t$$props.$$events[event_name].push(event_callback);\n}\n\n/**\n * Used to simulate `$set` on a component instance when `compatibility.componentApi === 4`.\n * Needs component accessors so that it can call the setter of the prop. Therefore doesn't\n * work for updating props in `$$props` or `$$restProps`.\n * @this {Record<string, any>}\n * @param {Record<string, any>} $$new_props\n */\nexport function update_legacy_props($$new_props) {\n\tfor (var key in $$new_props) {\n\t\tif (key in this) {\n\t\t\tthis[key] = $$new_props[key];\n\t\t}\n\t}\n}\n","/** @import { ComponentContext, ComponentContextLegacy } from '#client' */\n/** @import { EventDispatcher } from './index.js' */\n/** @import { NotFunction } from './internal/types.js' */\nimport { untrack } from './internal/client/runtime.js';\nimport { is_array } from './internal/shared/utils.js';\nimport { user_effect } from './internal/client/index.js';\nimport * as e from './internal/client/errors.js';\nimport { lifecycle_outside_component } from './internal/shared/errors.js';\nimport { legacy_mode_flag } from './internal/flags/index.js';\nimport { component_context } from './internal/client/context.js';\nimport { DEV } from 'esm-env';\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n\n/**\n * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.\n * Unlike `$effect`, the provided function only runs once.\n *\n * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;\n * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,\n * it will be called when the component is unmounted.\n *\n * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).\n *\n * @template T\n * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onMount');\n\t}\n\n\tif (legacy_mode_flag && component_context.l !== null) {\n\t\tinit_update_callbacks(component_context).m.push(fn);\n\t} else {\n\t\tuser_effect(() => {\n\t\t\tconst cleanup = untrack(fn);\n\t\t\tif (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);\n\t\t});\n\t}\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onDestroy');\n\t}\n\n\tonMount(() => () => untrack(fn));\n}\n\n/**\n * @template [T=any]\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {CustomEvent<T>}\n */\nfunction create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * @deprecated Use callback props and/or the `$host()` rune instead — see [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events)\n * @template {Record<string, any>} [EventMap = any]\n * @returns {EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\tlifecycle_outside_component('createEventDispatcher');\n\t}\n\n\treturn (type, detail, options) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = create_custom_event(/** @type {string} */ (type), detail, options);\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`.\n *\n * In runes mode use `$effect.pre` instead.\n *\n * @deprecated Use [`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead\n * @param {() => void} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('beforeUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('beforeUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).b.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`.\n *\n * In runes mode use `$effect` instead.\n *\n * @deprecated Use [`$effect`](https://svelte.dev/docs/svelte/$effect) instead\n * @param {() => void} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('afterUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('afterUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).a.push(fn);\n}\n\n/**\n * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate\n * @param {ComponentContext} context\n */\nfunction init_update_callbacks(context) {\n\tvar l = /** @type {ComponentContextLegacy} */ (context).l;\n\treturn (l.u ??= { a: [], b: [], m: [] });\n}\n\nexport { flushSync } from './internal/client/runtime.js';\nexport { getContext, getAllContexts, hasContext, setContext } from './internal/client/context.js';\nexport { hydrate, mount, unmount } from './internal/client/render.js';\nexport { tick, untrack } from './internal/client/runtime.js';\nexport { createRawSnippet } from './internal/client/dom/blocks/snippet.js';\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, captured_signals, untrack } from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { LEGACY_DERIVED_PROP, LEGACY_PROPS, STATE_SYMBOL } from '../constants.js';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @param {Derived} current_value\n * @returns {boolean}\n */\nfunction has_destroyed_component_ctx(current_value) {\n\treturn current_value.ctx?.d ?? false;\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\n\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t// or `createClassComponent(Component, props)`\n\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\tvar setter =\n\t\t(bindable &&\n\t\t\t(get_descriptor(props, key)?.set ??\n\t\t\t\t(is_entry_props && key in props && ((v) => (props[key] = v))))) ||\n\t\tundefined;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\t// Ensure we eagerly capture the initial value if it's bindable\n\tif (bindable) {\n\t\tget(current_value);\n\t}\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (captured_signals !== null) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\treturn current_value.v;\n\t\t}\n\n\t\treturn get(current_value);\n\t};\n}\n","/**\n * Create a lightweight debug function to log output into the browser console.\n *\n * Inspired by https://github.com/visionmedia/debug (some code is copied below)\n *\n * Usage:\n *\n *     import { createDebug } from './debug.js'\n *\n *     const debug = createDebug('my:namespace')\n *\n *     debug('testing:', 2 + 2)\n *\n * By default, logging is only enabled when a property DEBUG is set in the\n * localStorage of your browser:\n *\n *     localStorage['debug'] = '*'\n *     localStorage['debug'] = 'jsoneditor:*'\n *     localStorage['debug'] = 'jsoneditor:TreeMode'\n *\n * The actual value of 'debug' is used to filter the debug messages.\n * The value can end with a '*' wild card to match any remaining text.\n *\n * By providing a value for `enabled`, you can choose conditions to\n * enable/disable debugging if you want, for example some flag determining\n * whether in development or production.\n */\nexport function createDebug(\n  namespace: string,\n  enabled = enableDebug(namespace)\n): (...args: unknown[]) => void {\n  if (!enabled) {\n    return noop\n  }\n\n  const color = selectColor(namespace)\n\n  return function debug(...args) {\n    console.log(`%c${namespace}`, `color:${color}`, ...args)\n  }\n}\n\nfunction enableDebug(namespace: string) {\n  const debug = tryReadLocalStorage('debug')\n\n  return debug?.endsWith('*') ? namespace.startsWith(debug.slice(0, -1)) : namespace === debug\n}\n\nfunction noop() {\n  // no operation\n}\n\n/**\n * Try read a specific key from localStorage\n */\nfunction tryReadLocalStorage(key: string): string | undefined {\n  try {\n    if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {\n      // reading local storage can fail for example because of security restrictions\n      return window.localStorage[key]\n    }\n  } catch {\n    // we do nothing with the error, not needed in this specific case\n  }\n\n  return undefined\n}\n\n/**\n * Selects a color for a debug namespace\n *\n * Code is copied from the following source: https://github.com/visionmedia/debug\n *\n * @param namespace The namespace string for the debug instance to be colored\n * @return An ANSI color code for the given namespace\n */\nfunction selectColor(namespace: string): string {\n  let hash = 0\n\n  for (let i = 0; i < namespace.length; i++) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i)\n    hash |= 0 // Convert to 32bit integer\n  }\n\n  return colors[Math.abs(hash) % colors.length]\n}\n\nconst colors = [\n  '#0000CC',\n  '#0099FF',\n  '#009400',\n  '#8dd200',\n  '#CCCC00',\n  '#CC9933',\n  '#ae04e7',\n  '#ff35d7',\n  '#FF3333',\n  '#FF6600',\n  '#FF9933',\n  '#FFCC33'\n]\n","let id = 0\n\nexport function uniqueId(): number {\n  id++\n  return id\n}\n","export function int(value: string): number {\n  return parseInt(value, 10)\n}\n\nexport function isDigit(char: string): boolean {\n  return DIGIT_REGEX.test(char)\n}\n\nconst DIGIT_REGEX = /^[0-9]$/\n\n// TODO: unit test\nexport function containsNumber(value: string): boolean {\n  return NUMBER_REGEX.test(value)\n}\n\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/\n","// TODO: unit test typeUtils.js\n\nimport { containsNumber } from './numberUtils.js'\nimport type { JSONParser } from '../types.js'\n\n/**\n * Test whether a value is an Object (and not an Array or Class)\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  // note that we check constructor.name, not constructor === Object,\n  // so we can use objects created in a different JS realm like an iframe.\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value.constructor === undefined || value.constructor.name === 'Object')\n  )\n}\n\n/**\n * Test whether a value is an Object or an Array (and not a Class)\n */\nexport function isObjectOrArray(value: unknown): value is object | Array<unknown> {\n  // Note that we check constructor.name, not constructor === Object,\n  // so we can use objects created in a different JS realm like an iframe.\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value.constructor === undefined ||\n      value.constructor.name === 'Object' ||\n      value.constructor.name === 'Array')\n  )\n}\n\n/**\n * Test whether a value is a boolean\n *\n * @param {*} value\n * @return {boolean}\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return value === true || value === false\n}\n\n/**\n * Test whether a value is a timestamp in milliseconds after the year 2000.\n */\nexport function isTimestamp(value: unknown): boolean {\n  const YEAR_2000 = 946684800000\n\n  if (typeof value === 'number') {\n    return (\n      value > YEAR_2000 &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      !isNaN(new Date(value).valueOf())\n    )\n  }\n\n  if (typeof value === 'bigint') {\n    return isTimestamp(Number(value))\n  }\n\n  // try getting the primitive value if that is different. For example when having a LosslessNumber\n  try {\n    const valueOf = value ? value.valueOf() : value\n    if (valueOf !== value) {\n      return isTimestamp(valueOf)\n    }\n  } catch {\n    return false\n  }\n\n  return false\n}\n\n/**\n * Get the applied color given a color name or code\n * Returns the color if the input is a valid color, and returns null otherwise.\n *\n * Example output:\n *\n *     'rgba(255,0,0,0.7)' or 'rgb(255,0,0)'\n *\n * Source: https://stackoverflow.com/questions/6386090/validating-css-color-names/33184805\n */\nexport function getColorCSS(color: string): string | undefined {\n  colorTestDiv = colorTestDiv || window.document.createElement('div')\n\n  colorTestDiv.style.color = ''\n  colorTestDiv.style.color = color\n\n  const applied = colorTestDiv.style.color\n  return applied !== '' ? applied.replace(/\\s+/g, '').toLowerCase() : undefined\n}\nlet colorTestDiv: HTMLDivElement | undefined = undefined\n\n/**\n * Test if a string contains a valid color name or code.\n * Returns true if a valid color, false otherwise\n */\nexport function isColor(value: unknown): boolean {\n  const maxColorLength = 99\n  return typeof value === 'string' && value.length < maxColorLength && !!getColorCSS(value)\n}\n\n/**\n * Get the type of the value\n */\nexport function valueType(value: unknown, parser: JSONParser): string {\n  // primitive types\n  if (\n    typeof value === 'number' ||\n    typeof value === 'string' ||\n    typeof value === 'boolean' ||\n    typeof value === 'undefined'\n  ) {\n    return typeof value\n  }\n  if (typeof value === 'bigint') {\n    return 'number' // we return number here, not bigint: all numeric types should return the same name\n  }\n  if (value === null) {\n    return 'null'\n  }\n\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  if (isObject(value)) {\n    // plain object only\n    return 'object'\n  }\n\n  // unknown type (like a LosslessNumber). Try out what stringfying results in\n  const valueStr = parser.stringify(value)\n  if (valueStr && containsNumber(valueStr)) {\n    return 'number'\n  }\n  if (valueStr === 'true' || valueStr === 'false') {\n    return 'boolean'\n  }\n  if (valueStr === 'null') {\n    return 'null'\n  }\n\n  return 'unknown'\n}\n\n/**\n * Test whether a text contains a url (matches when a string starts\n * with 'http://*' or 'https://*' and has no whitespace characters)\n */\nconst isUrlRegex = /^https?:\\/\\/\\S+$/\nexport function isUrl(text: unknown): boolean {\n  return typeof text === 'string' && isUrlRegex.test(text)\n}\n\n/**\n * Convert contents of a string to the correct JSON type. This can be a string,\n * a number, a boolean, etc\n */\nexport function stringConvert(str: string, parser: JSONParser): unknown {\n  if (str === '') {\n    return ''\n  }\n\n  const strTrim = str.trim()\n\n  if (strTrim === 'null') {\n    return null\n  }\n\n  if (strTrim === 'true') {\n    return true\n  }\n\n  if (strTrim === 'false') {\n    return false\n  }\n\n  if (containsNumber(strTrim)) {\n    return parser.parse(strTrim)\n  }\n\n  return str\n}\n\n/**\n * Test whether a string contains a numeric, boolean, or null value.\n * Returns true when the string contains a number, boolean, or null.\n */\nexport function isStringContainingPrimitiveValue(str: unknown): boolean {\n  // note that we can safely use JSON parser here instead of the configured JSONParser,\n  // since we do not actually use the parsed number, just want to check that it is not a string\n  return typeof str === 'string' && typeof stringConvert(str, JSON) !== 'string'\n}\n\n/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value: string): boolean {\n  return INTEGER_REGEX.test(value)\n}\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\n","import { isObject } from './typeUtils.js'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, parseJSONPointer } from 'immutable-json-patch'\nimport { isEqual } from 'lodash-es'\n\nconst MAX_ITEM_PATHS_COLLECTION = 10000\nconst ROOT_PATH: JSONPath = []\n\n/**\n * Comparator to sort an array in ascending order\n *\n * Usage:\n *     [4,2,5].sort(compareAsc)    // [2,4,5]\n */\nexport function compareAsc<T>(a: T, b: T): number {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\n/**\n * Comparator to sort an array in ascending order\n *\n * Usage:\n *     [4,2,5].sort(compareDesc)   // [5,4,2]\n */\nexport function compareDesc<T>(a: T, b: T): number {\n  return a > b ? -1 : a < b ? 1 : 0\n}\n\n/**\n * Test whether all items of an array are strictly equal\n */\nexport function strictShallowEqual<T>(a: Array<T>, b: Array<T>): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function compareArrays<T>(a: Array<T>, b: Array<T>): number {\n  const minLength = Math.min(a.length, b.length)\n\n  for (let i = 0; i < minLength; i++) {\n    if (a[i] < b[i]) {\n      return -1\n    }\n\n    if (a[i] > b[i]) {\n      return 1\n    }\n  }\n\n  return a.length - b.length\n}\n\n/**\n * Get the paths of all nested properties in the items of an array\n * @param array\n * @param includeObjects If true, object and array paths are returned as well\n */\nexport function getNestedPaths(array: unknown, includeObjects = false): JSONPath[] {\n  const pointersMap: Record<string, boolean> = {}\n\n  if (!Array.isArray(array)) {\n    throw new TypeError('Array expected')\n  }\n\n  function recurseNestedPaths(obj: unknown, path: JSONPath) {\n    const isValue = !Array.isArray(obj) && !isObject(obj)\n\n    if (isValue || (includeObjects && path.length > 0)) {\n      pointersMap[compileJSONPointer(path)] = true\n    }\n\n    if (isObject(obj)) {\n      Object.keys(obj).forEach((key) => {\n        recurseNestedPaths(obj[key], path.concat(key))\n      })\n    }\n  }\n\n  const max = Math.min(array.length, MAX_ITEM_PATHS_COLLECTION)\n  for (let i = 0; i < max; i++) {\n    const item = array[i]\n    recurseNestedPaths(item, ROOT_PATH)\n  }\n\n  const pathsArray = Object.keys(pointersMap).sort()\n\n  return pathsArray.map(parseJSONPointer)\n}\n\n/**\n * Invoke the callback with\n * @param start   Included start index\n * @param end       Excluded end index. End must be larger or equal to start\n * @param iteratee\n */\n// TODO: write tests\nexport function forEachIndex(start: number, end: number, iteratee: (index: number) => void) {\n  if (end <= start) {\n    return\n  }\n\n  for (let index = start; index < end; index++) {\n    iteratee(index)\n  }\n}\n\n/**\n * Limit the number of items in an array\n */\n// TODO: write unit test\nexport function limit<T>(array: Array<T>, max: number): Array<T> {\n  return array.length > max ? array.slice(0, max) : array\n}\n\n/**\n * Convert an array into an object having the array indices as keys\n */\nexport function arrayToObject<T>(array: Array<T>): Record<number, T> {\n  return {\n    ...array\n  }\n}\n\n/**\n * Get the values of an object as an array\n */\nexport function objectToArray<T>(object: Record<string, T>): Array<T> {\n  return Object.values(object)\n}\n\n/**\n * Test whether an array starts with a sub array\n */\nexport function arrayStartsWith<T>(\n  array: T[],\n  searchArray: T[],\n  equal: (a: T, b: T) => boolean = isEqual\n): boolean {\n  for (let i = 0; i < searchArray.length; i++) {\n    if (!equal(array[i], searchArray[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Move a set of items inside an array\n */\nexport function moveItems<T>(array: T[], index: number, count: number, offset: number): T[] {\n  // TODO: check boundaries: index+offset >= 0, index+offset+count<array.length, index+count<array.length, etc\n  const copy = array.slice(0)\n  const moving: T[] = copy.splice(index, count)\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  copy.splice.apply(copy, [index + offset, 0, ...moving])\n  return copy\n}\n\n/**\n * Take samples out of a large array, equally spread from start till end\n */\nexport function forEachSample<T>(\n  array: T[],\n  maxSampleCount: number,\n  callback: (item: T, index: number, array: T[]) => void\n) {\n  if (array.length < maxSampleCount) {\n    array.forEach(callback)\n  } else {\n    const step = maxSampleCount > 1 ? (array.length - 1) / (maxSampleCount - 1) : array.length\n    for (let i = 0; i < maxSampleCount; i++) {\n      const index = Math.floor(i * step)\n      callback(array[index], index, array)\n    }\n  }\n}\n\nexport function insertItemsAt<T>(array: T[], index: number, items: T[]): T[] {\n  return array.slice(0, index).concat(items).concat(array.slice(index))\n}\n\n/**\n * Remove duplicate entries from an array, keeping the last item in case of a duplicate.\n * This is similar to the `uniqWith` function of Lodash, but that function keeps the *first* item in case of a duplicate.\n */\nexport function dedupeKeepLast<T>(array: T[], comparator: (a: T, b: T) => boolean = isEqual): T[] {\n  return array.filter((item, index) => {\n    for (let i = index + 1; i < array.length; i++) {\n      if (comparator(item, array[i])) {\n        return false\n      }\n    }\n\n    return true\n  })\n}\n","import type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer } from 'immutable-json-patch'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport jsonSourceMap from 'json-source-map'\nimport { jsonrepair } from 'jsonrepair'\nimport { isObject, isObjectOrArray, valueType } from './typeUtils.js'\nimport { arrayToObject, objectToArray } from './arrayUtils.js'\nimport type {\n  Content,\n  JSONContent,\n  JSONParser,\n  ParseError,\n  TextContent,\n  TextLocation\n} from '../types'\nimport { int } from './numberUtils.js'\n\n/**\n * Parse the JSON. if this fails, try to repair and parse.\n * Throws an exception when the JSON is invalid and could not be parsed.\n */\nexport function parseAndRepair(jsonText: string, parser: JSONParser): unknown {\n  try {\n    return parser.parse(jsonText)\n  } catch {\n    // this can also throw\n    return parser.parse(jsonrepair(jsonText))\n  }\n}\n\n/**\n * Parse the JSON and if needed repair it.\n * When not valid, undefined is returned.\n */\nexport function parseAndRepairOrUndefined(\n  partialJson: string,\n  parser: JSONParser\n): unknown | undefined {\n  try {\n    return parseAndRepair(partialJson, parser)\n  } catch {\n    return undefined\n  }\n}\n\n// TODO: deduplicate the logic in repairPartialJson and parseAndRepairPartialJson ?\nexport function parsePartialJson(partialJson: string, parse: (text: string) => unknown): unknown {\n  // for now: dumb brute force approach: simply try out a few things...\n\n  // remove trailing comma\n  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '')\n\n  try {\n    return parse(partialJson)\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    return parse('{' + partialJson + '}')\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    return parse('[' + partialJson + ']')\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  throw new Error('Failed to parse partial JSON')\n}\n\n/**\n * Repair partial JSON\n */\nexport function repairPartialJson(partialJson: string): string {\n  // for now: dumb brute force approach: simply try out a few things...\n\n  // remove trailing comma\n  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '')\n\n  try {\n    return jsonrepair(partialJson)\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    const repaired = jsonrepair('[' + partialJson + ']')\n    return repaired.substring(1, repaired.length - 1) // remove the outer [...] again\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    const repaired = jsonrepair('{' + partialJson + '}')\n    return repaired.substring(1, repaired.length - 1) // remove the outer {...} again\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  throw new Error('Failed to repair partial JSON')\n}\n\n// test whether a string ends with a comma, followed by zero or more white space characters\nconst END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX = /,\\s*$/\n\n/**\n * Normalize a parse error message like\n *     \"Unexpected token i in JSON at position 4\"\n * or\n *     \"JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data\"\n * and return the line and column numbers in an object\n *\n * Note that the returned line and column number in the object are zero-based,\n * and in the message are one based (human-readable)\n */\nexport function normalizeJsonParseError(jsonText: string, parseErrorMessage: string): ParseError {\n  const positionMatch = POSITION_REGEX.exec(parseErrorMessage)\n\n  if (positionMatch) {\n    // a message from Chrome, like \"Unexpected token i in JSON at line 2 column 3\"\n    const position = int(positionMatch[2])\n\n    const line = countCharacterOccurrences(jsonText, '\\n', 0, position)\n    const lastIndex = jsonText.lastIndexOf('\\n', position)\n    const column = position - lastIndex - 1\n\n    return {\n      position,\n      line,\n      column,\n      message: parseErrorMessage.replace(POSITION_REGEX, () => {\n        return `line ${line + 1} column ${column + 1}`\n      })\n    }\n  } else {\n    // a message from Firefox, like \"JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data\"\n    const lineMatch = LINE_REGEX.exec(parseErrorMessage)\n    const lineOneBased = lineMatch ? int(lineMatch[1]) : undefined\n    const line = lineOneBased !== undefined ? lineOneBased - 1 : undefined\n\n    const columnMatch = COLUMN_REGEX.exec(parseErrorMessage)\n    const columnOneBased = columnMatch ? int(columnMatch[1]) : undefined\n    const column = columnOneBased !== undefined ? columnOneBased - 1 : undefined\n\n    const position =\n      line !== undefined && column !== undefined\n        ? calculatePosition(jsonText, line, column)\n        : undefined\n\n    // line and column are one based in the message\n    return {\n      position,\n      line,\n      column,\n      message: parseErrorMessage.replace(/^JSON.parse: /, '').replace(/ of the JSON data$/, '')\n    }\n  }\n}\n\n/**\n * Calculate the position in the text based on a line and column number\n * @param text\n * @param line     Zero-based line number\n * @param column   Zero-based column number\n */\nexport function calculatePosition(text: string, line: number, column: number): number | undefined {\n  let index = text.indexOf('\\n')\n  let i = 1\n\n  while (i < line && index !== -1) {\n    index = text.indexOf('\\n', index + 1)\n    i++\n  }\n\n  return index !== -1\n    ? index + column + 1 // +1 for the return character itself\n    : undefined\n}\n\nexport function countCharacterOccurrences(\n  text: string,\n  character: string,\n  start = 0,\n  end = text.length\n) {\n  let count = 0\n\n  for (let i = start; i < end; i++) {\n    if (text.charAt(i) === character) {\n      count++\n    }\n  }\n\n  return count\n}\n\n/**\n * Find the text location of a JSON path\n */\n// TODO: write unit tests\nexport function findTextLocation(text: string, path: JSONPath): TextLocation {\n  try {\n    const jsmap = jsonSourceMap.parse(text)\n\n    const pointerName = compileJSONPointer(path)\n    const pointer = jsmap.pointers[pointerName]\n    if (pointer) {\n      return {\n        path,\n        line: pointer.key ? pointer.key.line : pointer.value ? pointer.value.line : 0,\n        column: pointer.key ? pointer.key.column : pointer.value ? pointer.value.column : 0,\n        from: pointer.key ? pointer.key.pos : pointer.value ? pointer.value.pos : 0,\n        to: pointer.keyEnd ? pointer.keyEnd.pos : pointer.valueEnd ? pointer.valueEnd.pos : 0\n      }\n    }\n  } catch (err) {\n    console.error(err)\n  }\n\n  return {\n    path,\n    line: 0,\n    column: 0,\n    from: 0,\n    to: 0\n  }\n}\n\n/**\n * Convert a JSON object, array, or value to another type\n * If it cannot be converted, an error is thrown\n */\nexport function convertValue(\n  value: unknown,\n  type: 'value' | 'object' | 'array',\n  parser: JSONParser\n): unknown {\n  // FIXME: improve the TypeScript here, there are a couple of conversions\n  if (type === 'array') {\n    if (Array.isArray(value)) {\n      // nothing to do\n      return value\n    }\n\n    if (isObject(value)) {\n      return objectToArray(value)\n    }\n\n    if (typeof value === 'string') {\n      try {\n        const parsedValue = parser.parse(value)\n\n        if (Array.isArray(parsedValue)) {\n          return parsedValue\n        }\n\n        if (isObject(parsedValue)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          return objectToArray(parsedValue)\n        }\n      } catch {\n        //we could not parse the string, so we return the string as the first key of the array\n        return [value]\n      }\n    }\n\n    //all other cases, we return the value as the first key of the array, same as the parsing error under the string case\n    return [value]\n  }\n\n  if (type === 'object') {\n    if (Array.isArray(value)) {\n      return arrayToObject(value)\n    }\n\n    if (isObject(value)) {\n      // nothing to do\n      return value\n    }\n\n    if (typeof value === 'string') {\n      try {\n        const parsedValue = parser.parse(value)\n\n        if (isObject(parsedValue)) {\n          return parsedValue\n        }\n\n        if (Array.isArray(parsedValue)) {\n          return arrayToObject(parsedValue)\n        }\n      } catch {\n        //we could not parse the string, so we return the string as the first value of the object with key 'value'\n        return { value: value }\n      }\n    }\n\n    //all other cases, we return the value keyed under \"value\", same as the parsing error under the string case\n    return { value: value }\n  }\n\n  if (type === 'value') {\n    if (isObjectOrArray(value)) {\n      return parser.stringify(value)\n    }\n\n    // nothing to do\n    return value\n  }\n\n  throw new Error(`Cannot convert ${valueType(value, parser)} to ${type}`)\n}\n\n/**\n * Check whether provided value is valid a content type for JSONEditor\n * Returns a string with validation error message when there is an issue,\n * or null otherwise\n */\nexport function validateContentType(content: unknown): string | undefined {\n  if (!isObject(content)) {\n    return 'Content must be an object'\n  }\n\n  if (content.json !== undefined) {\n    if (content.text !== undefined) {\n      return 'Content must contain either a property \"json\" or a property \"text\" but not both'\n    } else {\n      return undefined\n    }\n  } else {\n    if (content.text === undefined) {\n      return 'Content must contain either a property \"json\" or a property \"text\"'\n    } else if (typeof content.text !== 'string') {\n      return (\n        'Content \"text\" property must be a string containing a JSON document. ' +\n        'Did you mean to use the \"json\" property instead?'\n      )\n    } else {\n      return undefined\n    }\n  }\n}\n\n/**\n * Check whether a value is Content (TextContent or JSONContent)\n */\nexport function isContent(content: unknown): content is Content {\n  return (\n    isObject(content) && (typeof content.json !== 'undefined' || typeof content.text === 'string')\n  )\n}\n\n/**\n * Check whether content contains text (and not JSON)\n */\nexport function isTextContent(content: unknown): content is TextContent {\n  return isObject(content) && typeof content.text === 'string'\n}\n\n/**\n * Check whether content contains json\n */\nexport function isJSONContent(content: unknown): content is JSONContent {\n  return isObject(content) && typeof content.json !== 'undefined'\n}\n\n/**\n * Convert Content into TextContent if it is JSONContent, else leave it as is\n */\nexport function toTextContent(\n  content: Content,\n  indentation: number | string | undefined = undefined,\n  parser: JSONParser = JSON\n): TextContent {\n  return isTextContent(content)\n    ? content\n    : { text: parser.stringify(content.json, null, indentation) as string }\n}\n\n/**\n * Convert Content into TextContent if it is JSONContent, else leave it as is\n * @throws {SyntaxError} Will throw a parse error when the text contents does not contain valid JSON\n */\nexport function toJSONContent(content: Content, parser: JSONParser = JSON): JSONContent {\n  return isJSONContent(content) ? content : { json: parser.parse(content.text) }\n}\n\n/**\n * Get the contents as Text. If the contents is JSON, the JSON will be parsed.\n */\nexport function getText(content: Content, indentation: number | string, parser: JSONParser) {\n  return toTextContent(content, indentation, parser).text\n}\n\n/**\n * Returns true when the (estimated) size of the contents exceeds the\n * provided maxSize.\n * @param content\n * @param maxSize  Maximum content size in bytes\n */\nexport function isLargeContent(content: Content, maxSize: number): boolean {\n  return estimateSerializedSize(content, maxSize) > maxSize\n}\n\n/**\n * A rough, fast estimation on whether a document is larger than given size\n * when serialized.\n *\n * maxSize is an optional max size in bytes. When reached, size estimation will\n * be cancelled. This is useful when you're only interested in knowing whether\n * the size exceeds a certain maximum size.\n */\nexport function estimateSerializedSize(content: Content, maxSize = Infinity): number {\n  if (isTextContent(content)) {\n    return content.text.length\n  }\n\n  const json = content.json\n\n  let estimatedSize = 0\n\n  function recurse(json: unknown) {\n    if (Array.isArray(json)) {\n      // open and close bracket, commas between items\n      estimatedSize += 2 + (json.length - 1)\n\n      if (estimatedSize > maxSize) {\n        return\n      }\n\n      for (let i = 0; i < json.length; i++) {\n        const item = json[i]\n\n        recurse(item)\n\n        if (estimatedSize > maxSize) {\n          return\n        }\n      }\n    } else if (isObject(json)) {\n      const keys = Object.keys(json)\n\n      // open and close brackets, separators between all keys and values, comma's between key/value pairs\n      estimatedSize += 2 + keys.length + (keys.length - 1)\n\n      for (let k = 0; k < keys.length; k++) {\n        const key = keys[k]\n        const value = json[key]\n\n        // key length and double quotes around it\n        estimatedSize += key.length + 2\n\n        recurse(value)\n      }\n    } else if (typeof json === 'string') {\n      estimatedSize += json.length + 2 // string length plus two for the double quote characters\n    } else {\n      // true, false, null, number\n      estimatedSize += String(json).length\n    }\n  }\n\n  recurse(json)\n\n  return estimatedSize\n}\n\nconst POSITION_REGEX = /(position|char) (\\d+)/\nconst LINE_REGEX = /line (\\d+)/\nconst COLUMN_REGEX = /column (\\d+)/\n\n/**\n * Check whether the actual functions of parse and stringify are strictly equal.\n * The object holding the functions may be a differing instance.\n */\nexport function isEqualParser(a: JSONParser, b: JSONParser): boolean {\n  return a.parse === b.parse && a.stringify === b.stringify\n}\n\n/**\n * Apply a fast and cheap heuristic to determine whether the content needs formatting (i.e. is compact).\n */\nexport function needsFormatting(jsonText: string): boolean {\n  const maxLength = 999\n  const head = jsonText.substring(0, maxLength).trim()\n  return !head.includes('\\n') && DELIMITER_WITHOUT_SPACING_REGEX.test(head)\n}\n\n// This regex matches cases of a comma or colon NOT followed by a whitespace\nconst DELIMITER_WITHOUT_SPACING_REGEX = /[,:]\\S/\n","import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\nimport type { Component, SvelteComponent } from 'svelte'\nimport type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\nimport type { Action } from 'svelte/action'\n\nexport type TextContent = { text: string }\n\nexport type JSONContent = { json: unknown }\n\nexport type Content = JSONContent | TextContent\n\n// The `JSONParser` interface is compatible with `JSON`,\n// except that JSON.stringify is wrongly defined to return a string whilst it can return a string or undefined\n// see: https://stackoverflow.com/questions/74461780/is-the-official-type-definition-for-json-stringify-wrong\nexport interface JSONParser {\n  parse(\n    text: string,\n    reviver?: ((this: unknown, key: string, value: unknown) => unknown) | null\n  ): unknown\n\n  stringify(\n    value: unknown,\n    replacer?:\n      | ((this: unknown, key: string, value: unknown) => unknown)\n      | Array<number | string>\n      | null,\n    space?: string | number\n  ): string | undefined\n}\n\nexport interface JSONPathParser {\n  parse: (pathStr: string) => JSONPath\n  stringify: (path: JSONPath) => string\n}\n\nexport interface VisibleSection {\n  start: number\n  end: number\n}\n\nexport enum Mode {\n  text = 'text',\n  tree = 'tree',\n  table = 'table'\n}\n\nexport enum SelectionType {\n  after = 'after',\n  inside = 'inside',\n  key = 'key',\n  value = 'value',\n  multi = 'multi',\n  text = 'text' // in text mode\n}\n\nexport enum CaretType {\n  after = 'after',\n  key = 'key',\n  value = 'value',\n  inside = 'inside'\n}\n\nexport interface PathOption {\n  value: JSONPath\n  label: string\n}\n\nexport interface NumberOption {\n  value: 1 | -1\n  label: string\n}\n\nexport interface CaretPosition {\n  path: JSONPath\n  type: CaretType // TODO: refactor this to use SelectionType here, then we can simplify the util functions to turn this into a selection\n}\n\nexport interface ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, RecursiveState | undefined>\n}\n\nexport interface ArrayRecursiveState {\n  type: 'array'\n  items: Array<RecursiveState | undefined>\n}\n\nexport interface ValueRecursiveState {\n  type: 'value'\n}\n\nexport type RecursiveState = ObjectRecursiveState | ArrayRecursiveState | ValueRecursiveState\n\nexport interface RecursiveStateFactory {\n  createObjectDocumentState: () => ObjectRecursiveState\n  createArrayDocumentState: () => ArrayRecursiveState\n  createValueDocumentState: () => ValueRecursiveState\n}\n\nexport interface ObjectDocumentState extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, DocumentState | undefined>\n  expanded: boolean\n}\n\nexport interface ArrayDocumentState extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<DocumentState | undefined>\n  expanded: boolean\n  visibleSections: VisibleSection[]\n}\n\nexport interface ValueDocumentState extends ValueRecursiveState {\n  type: 'value'\n  enforceString?: boolean\n}\n\nexport type DocumentState = ObjectDocumentState | ArrayDocumentState | ValueDocumentState\n\nexport interface ObjectSearchResults extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, SearchResults | undefined>\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport interface ArraySearchResults extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<SearchResults | undefined>\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport interface ValueSearchResults extends ValueRecursiveState {\n  type: 'value'\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport type SearchResults = ObjectSearchResults | ArraySearchResults | ValueSearchResults\n\nexport type WithSearchResults = SearchResults & {\n  searchResults: ExtendedSearchResultItem[]\n}\n\nexport interface ObjectValidationErrors extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, ValidationErrors | undefined>\n  validationError?: NestedValidationError\n}\n\nexport interface ArrayValidationErrors extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<ValidationErrors | undefined>\n  validationError?: NestedValidationError\n}\n\nexport interface ValueValidationErrors extends ValueRecursiveState {\n  type: 'value'\n  validationError?: NestedValidationError\n}\n\nexport type ValidationErrors =\n  | ObjectValidationErrors\n  | ArrayValidationErrors\n  | ValueValidationErrors\n\nexport interface JSONPatchResult {\n  json: unknown\n  previousJson: unknown\n  undo: JSONPatchDocument\n  redo: JSONPatchDocument\n}\n\nexport type AfterPatchCallback = (\n  patchedJson: unknown,\n  patchedState: DocumentState | undefined,\n  patchedSelection: JSONSelection | undefined\n) =>\n  | {\n      json?: unknown\n      state?: DocumentState | undefined\n      selection?: JSONSelection | undefined\n      sortedColumn?: SortedColumn | undefined\n    }\n  | undefined\n\nexport interface MultiSelection {\n  type: SelectionType.multi\n  anchorPath: JSONPath\n  focusPath: JSONPath\n}\n\nexport interface AfterSelection {\n  type: SelectionType.after\n  path: JSONPath\n}\n\nexport interface InsideSelection {\n  type: SelectionType.inside\n  path: JSONPath\n}\n\nexport interface KeySelection {\n  type: SelectionType.key\n  path: JSONPath\n}\n\nexport interface EditKeySelection extends KeySelection {\n  type: SelectionType.key\n  path: JSONPath\n  edit: true\n  initialValue?: string\n}\n\nexport type ValueSelection = {\n  type: SelectionType.value\n  path: JSONPath\n}\n\nexport interface EditValueSelection extends ValueSelection {\n  type: SelectionType.value\n  path: JSONPath\n  edit: true\n  initialValue?: string\n}\n\nexport type JSONSelection =\n  | MultiSelection\n  | AfterSelection\n  | InsideSelection\n  | KeySelection\n  | EditKeySelection\n  | ValueSelection\n  | EditValueSelection\n\n// TextSelection is the result of EditorSelection.toJSON() from CodeMirror,\n// with an additional `type` property\nexport interface TextSelection {\n  type: SelectionType.text\n  ranges: { anchor: number; head: number }[]\n  main: number\n}\n\nexport type JSONEditorSelection = JSONSelection | TextSelection\n\nexport interface ScrollToOptions {\n  scrollToWhenVisible?: boolean\n  element?: Element\n}\n\nexport type ClipboardValues = Array<{ key: string; value: unknown }>\n\nexport interface MenuButton {\n  type: 'button'\n  onClick: (event: MouseEvent) => void\n  icon?: IconDefinition\n  text?: string\n  title?: string\n  className?: string\n  disabled?: boolean\n}\n\nexport interface MenuDropDownButton {\n  type: 'dropdown-button'\n  main: MenuButton\n  width?: string\n  items: MenuButton[]\n}\n\nexport interface MenuLabel {\n  type: 'label'\n  text: string\n}\n\nexport interface MenuSeparator {\n  type: 'separator'\n}\n\nexport interface MenuSpace {\n  type: 'space'\n}\n\nexport type MenuItem = MenuButton | MenuSeparator | MenuSpace\n\nexport interface ContextMenuColumn {\n  type: 'column'\n  items: Array<MenuButton | MenuDropDownButton | MenuLabel | MenuSeparator>\n}\nexport interface ContextMenuRow {\n  type: 'row'\n  items: Array<MenuButton | MenuDropDownButton | ContextMenuColumn>\n}\nexport type ContextMenuItem = MenuButton | MenuDropDownButton | MenuSeparator | ContextMenuRow\n\nexport interface MessageAction {\n  text: string\n  title: string\n  icon?: IconDefinition\n  onClick?: () => void\n  onMouseDown?: () => void\n  disabled?: boolean\n}\n\nexport enum ValidationSeverity {\n  info = 'info',\n  warning = 'warning',\n  error = 'error'\n}\n\nexport interface ValidationError {\n  path: JSONPath\n  message: string\n  severity: ValidationSeverity\n}\n\nexport interface NestedValidationError extends ValidationError {\n  isChildError?: boolean\n}\n\nexport type Validator = (json: unknown) => ValidationError[]\n\nexport interface ParseError {\n  position: number | undefined\n  line: number | undefined\n  column: number | undefined\n  message: string\n}\n\nexport interface ContentParseError {\n  parseError: ParseError\n  isRepairable: boolean\n}\n\nexport interface ContentValidationErrors {\n  validationErrors: ValidationError[]\n}\n\nexport type ContentErrors = ContentParseError | ContentValidationErrors\n\nexport interface RichValidationError extends ValidationError {\n  line: number | undefined\n  column: number | undefined\n  from: number | undefined\n  to: number | undefined\n  actions: Array<{ name: string; apply: () => void }> | undefined\n}\n\nexport interface TextLocation {\n  path: JSONPath\n  line: number\n  column: number\n  from: number\n  to: number\n}\n\nexport interface Section {\n  start: number // start included\n  end: number // end excluded\n}\n\nexport interface QueryLanguage {\n  id: string\n  name: string\n  description: string\n  createQuery: (json: unknown, queryOptions: QueryLanguageOptions) => string\n  executeQuery: (json: unknown, query: string, parser: JSONParser) => unknown\n}\n\nexport interface QueryLanguageOptions {\n  filter?: {\n    path?: JSONPath\n    relation?: '==' | '!=' | '<' | '<=' | '>' | '>='\n    value?: string\n  }\n  sort?: {\n    path?: JSONPath\n    direction?: 'asc' | 'desc'\n  }\n  projection?: {\n    paths?: JSONPath[]\n  }\n}\n\nexport type OnChangeQueryLanguage = (queryLanguageId: string) => void\nexport interface OnChangeStatus {\n  contentErrors: ContentErrors | undefined\n  patchResult: JSONPatchResult | undefined\n}\nexport type OnChange =\n  | ((content: Content, previousContent: Content, status: OnChangeStatus) => void)\n  | undefined\nexport type OnJSONSelect = (selection: JSONSelection) => void\nexport type OnSelect = (selection: JSONEditorSelection | undefined) => void\nexport type OnUndo = (item: HistoryItem | undefined) => void\nexport type OnRedo = (item: HistoryItem | undefined) => void\nexport type OnPatch = (\n  operations: JSONPatchDocument,\n  afterPatch?: AfterPatchCallback\n) => JSONPatchResult\nexport type OnChangeText = (updatedText: string, afterPatch?: AfterPatchCallback) => void\nexport type OnSort = (params: {\n  operations: JSONPatchDocument\n  rootPath: JSONPath\n  itemPath: JSONPath\n  direction: 1 | -1\n}) => void\nexport type OnFind = (findAndReplace: boolean) => void\nexport type OnPaste = (pastedText: string) => void\nexport type OnPasteJson = (pastedJson: PastedJson) => void\nexport type OnExpand = (relativePath: JSONPath) => boolean\nexport type OnRenderValue = (props: RenderValueProps) => RenderValueComponentDescription[]\nexport type OnClassName = (path: JSONPath, value: unknown) => string | undefined\nexport type OnChangeMode = (mode: Mode) => void\nexport type OnContextMenu = (contextMenuProps: AbsolutePopupOptions) => void\nexport type RenderMenuContext = {\n  mode: Mode\n  modal: boolean\n  readOnly: boolean\n}\nexport type OnRenderMenu = (items: MenuItem[], context: RenderMenuContext) => MenuItem[] | undefined\nexport type OnRenderMenuInternal = (items: MenuItem[]) => MenuItem[] | undefined\nexport type RenderContextMenuContext = RenderMenuContext & {\n  selection: JSONEditorSelection | undefined\n}\nexport type OnRenderContextMenu = (\n  items: ContextMenuItem[],\n  context: RenderContextMenuContext\n) => ContextMenuItem[] | false | undefined\nexport type OnRenderContextMenuInternal = (\n  items: ContextMenuItem[]\n) => ContextMenuItem[] | false | undefined\nexport type OnError = (error: Error) => void\nexport type OnFocus = () => void\nexport type OnBlur = () => void\nexport type OnSortModal = (props: SortModalCallback) => void\nexport type OnTransformModal = (props: TransformModalCallback) => void\nexport type OnJSONEditorModal = (props: JSONEditorModalCallback) => void\nexport type FindNextInside = (path: JSONPath) => JSONSelection | undefined\n\nexport interface SearchResultDetails {\n  items: ExtendedSearchResultItem[]\n  activeItem: ExtendedSearchResultItem | undefined\n  activeIndex: number | -1\n}\n\nexport enum SearchField {\n  key = 'key',\n  value = 'value'\n}\n\nexport interface SearchOptions {\n  maxResults?: number\n  columns?: JSONPath[]\n}\n\nexport interface SearchResultItem {\n  path: JSONPath\n  field: SearchField\n  fieldIndex: number\n  start: number\n  end: number\n}\n\nexport interface ExtendedSearchResultItem extends SearchResultItem {\n  resultIndex: number\n  active: boolean\n}\n\nexport type EscapeValue = (value: unknown) => string\n\nexport type UnescapeValue = (escapedValue: string) => string\n\nexport interface ValueNormalization {\n  escapeValue: EscapeValue\n  unescapeValue: UnescapeValue\n}\n\nexport type PastedJson = {\n  path: JSONPath\n  contents: unknown\n  onPasteAsJson: () => void\n}\n\nexport interface DragInsideProps {\n  json: unknown\n  selection: JSONSelection\n  deltaY: number\n  items: Array<{ path: JSONPath; height: number }>\n}\n\nexport type DragInsideAction =\n  | { beforePath: JSONPath; offset: number }\n  | { append: true; offset: number }\n\nexport interface RenderedItem {\n  path: JSONPath\n  height: number\n}\n\nexport interface TreeHistoryItem {\n  type: 'tree'\n  undo: {\n    patch: JSONPatchDocument | undefined\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    sortedColumn: SortedColumn | undefined\n    textIsRepaired: boolean\n  }\n  redo: {\n    patch: JSONPatchDocument | undefined\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    sortedColumn: SortedColumn | undefined\n    textIsRepaired: boolean\n  }\n}\n\nexport type TextChanges = Array<number | [number, ...string[]]>\n\nexport interface TextHistoryItem {\n  type: 'text'\n  undo: {\n    changes: TextChanges\n    selection: TextSelection\n  }\n  redo: {\n    changes: TextChanges\n    selection: TextSelection\n  }\n}\n\nexport interface ModeHistoryItem {\n  type: 'mode'\n  undo: {\n    mode: Mode\n    selection: undefined // selection can be restored used the corresponding sibling HistoryItem\n  }\n  redo: {\n    mode: Mode\n    selection: undefined // selection can be restored used the corresponding sibling HistoryItem\n  }\n}\n\nexport type HistoryItem = TreeHistoryItem | TextHistoryItem | ModeHistoryItem\n\nexport interface HistoryInstance<T> {\n  get: () => History<T>\n}\n\nexport interface History<T> {\n  canUndo: boolean\n  canRedo: boolean\n  items: () => T[]\n  add: (item: T) => void\n  clear: () => void\n  undo: () => T | undefined\n  redo: () => T | undefined\n}\n\nexport type ConvertType = 'value' | 'object' | 'array'\nexport type InsertType = ConvertType | 'structure'\n\nexport interface PopupEntry {\n  id: number\n  component: typeof SvelteComponent<Record<string, unknown>>\n  props: Record<string, unknown>\n  options: AbsolutePopupOptions\n}\n\nexport interface AbsolutePopupOptions {\n  anchor?: Element\n  position?: 'top' | 'left'\n  left?: number\n  top?: number\n  width?: number\n  height?: number\n  offsetTop?: number\n  offsetLeft?: number\n  showTip?: boolean\n  closeOnOuterClick?: boolean\n  onClose?: () => void\n}\n\nexport interface AbsolutePopupContext {\n  openAbsolutePopup: (\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ) => number\n  closeAbsolutePopup: (popupId: number | undefined) => void\n}\n\nexport interface JSONEditorPropsOptional {\n  content?: Content\n  selection?: JSONEditorSelection\n  readOnly?: boolean\n  indentation?: number | string\n  tabSize?: number\n  truncateTextSize?: number\n  mode?: Mode\n  mainMenuBar?: boolean\n  navigationBar?: boolean\n  statusBar?: boolean\n  askToFormat?: boolean\n  escapeControlCharacters?: boolean\n  escapeUnicodeCharacters?: boolean\n  flattenColumns?: boolean\n  parser?: JSONParser\n  validator?: Validator | undefined\n  validationParser?: JSONParser\n  pathParser?: JSONPathParser\n\n  queryLanguages?: QueryLanguage[]\n  queryLanguageId?: string\n\n  onChangeQueryLanguage?: OnChangeQueryLanguage\n  onChange?: OnChange\n  onRenderValue?: OnRenderValue\n  onClassName?: OnClassName\n  onRenderMenu?: OnRenderMenu\n  onRenderContextMenu?: OnRenderContextMenu\n  onChangeMode?: OnChangeMode\n  onSelect?: OnSelect\n  onError?: OnError\n  onFocus?: OnFocus\n  onBlur?: OnBlur\n}\n\nexport interface JSONEditorModalProps {\n  content: Content\n  path: JSONPath\n  onPatch: OnPatch\n\n  readOnly: boolean\n  indentation: number | string\n  tabSize: number\n  truncateTextSize: number\n  mainMenuBar: boolean\n  navigationBar: boolean\n  statusBar: boolean\n  askToFormat: boolean\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n  flattenColumns: boolean\n  parser: JSONParser\n  validator: Validator | undefined\n  validationParser: JSONParser\n  pathParser: JSONPathParser\n\n  onRenderValue: OnRenderValue\n  onClassName: OnClassName\n  onRenderMenu: OnRenderMenu\n  onRenderContextMenu: OnRenderContextMenu\n  onSortModal: (props: SortModalCallback) => void\n  onTransformModal: (props: TransformModalCallback) => void\n  onClose: () => void\n}\n\nexport interface JSONEditorContext {\n  mode: Mode\n  readOnly: boolean\n  truncateTextSize: number\n  parser: JSONParser\n  normalization: ValueNormalization\n  getJson: () => unknown | undefined\n  getDocumentState: () => DocumentState | undefined\n  findElement: (path: JSONPath) => Element | undefined\n  findNextInside: FindNextInside\n  focus: () => void\n  onPatch: OnPatch\n  onSelect: OnJSONSelect\n  onFind: OnFind\n  onPasteJson: (newPastedJson: PastedJson) => void\n  onRenderValue: OnRenderValue\n}\n\nexport interface TreeModeContext extends JSONEditorContext {\n  getJson: () => unknown | undefined\n  getDocumentState: () => DocumentState | undefined\n  getSelection: () => JSONSelection | undefined\n  findElement: (path: JSONPath) => Element | undefined\n  onInsert: (type: InsertType) => void\n  onExpand: (path: JSONPath, expanded: boolean, recursive?: boolean) => void\n  onExpandSection: (path: JSONPath, section: Section) => void\n  onContextMenu: OnContextMenu\n  onClassName: OnClassName\n  onDrag: (event: MouseEvent) => void\n  onDragEnd: () => void\n}\n\nexport interface RenderValueProps extends Record<string, unknown> {\n  path: JSONPath\n  value: unknown\n  mode: Mode\n  truncateTextSize: number\n  readOnly: boolean\n  enforceString: boolean\n  selection: JSONSelection | undefined\n  searchResultItems: ExtendedSearchResultItem[] | undefined\n  isEditing: boolean\n  parser: JSONParser\n  normalization: ValueNormalization\n  onPatch: OnPatch\n  onPasteJson: OnPasteJson\n  onSelect: OnJSONSelect\n  onFind: OnFind\n  findNextInside: FindNextInside\n  focus: () => void\n}\n\nexport type RenderValuePropsOptional = Partial<RenderValueProps>\n\nexport interface DraggingState {\n  initialTarget: Element\n  initialClientY: number\n  initialContentTop: number\n  selectionStartIndex: number\n  selectionItemsCount: number\n  items: RenderedItem[]\n  offset: number\n  didMoveItems: boolean\n}\n\nexport type RenderValueComponentDescription = SvelteComponentRenderer | SvelteActionRenderer\n\nexport interface SvelteComponentRenderer {\n  component:\n    | typeof SvelteComponent<RenderValuePropsOptional> // Classic Svelte component\n    | Component<RenderValueProps> // Runes\n  props: RenderValueProps\n}\n\nexport interface SvelteActionRenderer {\n  action: Action<HTMLElement, Record<string, unknown>>\n  props: Record<string, unknown>\n}\n\nexport interface TransformModalOptions {\n  id?: string\n  rootPath?: JSONPath\n  onTransform?: (state: {\n    operations: JSONPatchDocument\n    json: unknown\n    transformedJson: unknown\n  }) => void\n  onClose?: () => void\n}\n\nexport interface TransformModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  onTransform: (operations: JSONPatchDocument) => void\n  onClose: () => void\n}\n\nexport interface TransformModalProps extends TransformModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  indentation: number | string\n  truncateTextSize: number\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n  parser: JSONParser\n  parseMemoizeOne: JSONParser['parse']\n  validationParser: JSONParser\n  pathParser: JSONPathParser\n\n  queryLanguages: QueryLanguage[]\n  queryLanguageId: string\n  onChangeQueryLanguage: OnChangeQueryLanguage\n\n  onRenderValue: OnRenderValue\n  onRenderMenu: OnRenderMenuInternal\n  onRenderContextMenu: OnRenderContextMenuInternal\n  onClassName: OnClassName\n\n  onTransform: (operations: JSONPatchDocument) => void\n  onClose: () => void\n}\n\nexport interface SortModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  onSort: OnSort\n  onClose: () => void\n}\n\nexport interface JSONRepairModalProps {\n  text: string\n  onParse: (text: string) => void\n  onRepair: (text: string) => string\n  onApply: (repairedText: string) => void\n  onClose: () => void\n}\n\nexport interface JSONEditorModalCallback {\n  content: Content\n  path: JSONPath\n  onPatch: OnPatch\n  onClose: () => void\n}\n\nexport enum SortDirection {\n  asc = 'asc',\n  desc = 'desc'\n}\n\nexport enum UpdateSelectionAfterChange {\n  no = 'no',\n  self = 'self',\n  nextInside = 'nextInside'\n}\n\nexport interface TableCellIndex {\n  rowIndex: number\n  columnIndex: number\n}\n\nexport interface SortedColumn {\n  path: JSONPath\n  sortDirection: SortDirection\n}\n\n// TODO: work out the JSONSchema type in detail.\n//  Ideally, we use use Schema from Ajv, but this interface isn't worked out either\nexport type JSONSchema = Record<string, unknown>\nexport type JSONSchemaDefinitions = Record<string, JSONSchema>\nexport type JSONSchemaEnum = Array<unknown>\n","import type { ValueNormalization } from '$lib/types.js'\nimport { SelectionType } from '$lib/types.js'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, parseJSONPointer } from 'immutable-json-patch'\nimport { map, minBy } from 'lodash-es'\n\n/**\n * Create serialization functions to escape and stringify text,\n * and the other way around: to parse and unescape text.\n */\nexport function createNormalizationFunctions({\n  escapeControlCharacters,\n  escapeUnicodeCharacters\n}: {\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n}): ValueNormalization {\n  if (escapeControlCharacters) {\n    if (escapeUnicodeCharacters) {\n      return normalizeControlAndUnicode\n    } else {\n      return normalizeControl\n    }\n  } else {\n    if (escapeUnicodeCharacters) {\n      return normalizeUnicode\n    } else {\n      return normalizeNothing\n    }\n  }\n}\n\nconst normalizeControlAndUnicode = {\n  escapeValue: (value: unknown) => jsonEscapeUnicode(jsonEscapeControl(String(value))),\n  unescapeValue: (value: string) => jsonUnescapeControl(jsonUnescapeUnicode(value))\n}\n\nconst normalizeControl = {\n  escapeValue: (value: unknown) => jsonEscapeControl(String(value)),\n  unescapeValue: (value: string) => jsonUnescapeControl(value)\n}\n\nconst normalizeUnicode = {\n  escapeValue: (value: unknown) => jsonEscapeUnicode(String(value)),\n  unescapeValue: (value: string) => jsonUnescapeUnicode(value)\n}\n\nconst normalizeNothing = {\n  escapeValue: (value: unknown) => String(value),\n  unescapeValue: (value: string) => value\n}\n\n/**\n * Source:  https://stackoverflow.com/questions/12271547/shouldnt-json-stringify-escape-unicode-characters\n */\nexport function jsonEscapeUnicode(value: string): string {\n  return value.replace(/[^\\x20-\\x7F]/g, (x) => {\n    if (x === '\\b' || x === '\\f' || x === '\\n' || x === '\\r' || x === '\\t') {\n      return x\n    }\n\n    return '\\\\u' + ('000' + x.codePointAt(0)?.toString(16)).slice(-4)\n  })\n}\n\nexport function jsonUnescapeUnicode(value: string): string {\n  return value.replace(/\\\\u[a-fA-F0-9]{4}/g, (x) => {\n    try {\n      const unescaped: string = JSON.parse('\"' + x + '\"')\n      // the resolved character can be a control character like \" or \\n,\n      // that would result in invalid JSON, so we need to keep that escaped\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return controlCharacters[unescaped] || unescaped\n    } catch {\n      return x\n    }\n  })\n}\n\nconst controlCharacters = {\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\',\n  // escaped forward slash '\\/' is the same as '/', we can't escape/unescape it\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n  // unicode is handled separately\n}\n\nconst escapedControlCharacters = {\n  '\\\\\"': '\"',\n  '\\\\\\\\': '\\\\',\n  // escaped forward slash '\\/' is the same as '/', we can't escape/unescape it\n  '\\\\/': '/',\n  '\\\\b': '\\b',\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t'\n  // unicode is handled separately\n}\n\nexport function jsonEscapeControl(value: string): string {\n  return value.replace(/[\"\\b\\f\\n\\r\\t\\\\]/g, (x) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return controlCharacters[x] || x\n  })\n}\n\nexport function jsonUnescapeControl(value: string): string {\n  return value.replace(/\\\\[\"bfnrt\\\\]/g, (x) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return escapedControlCharacters[x] || x\n  })\n}\n\nexport function addNewLineSuffix(value: unknown): string {\n  if (typeof value !== 'string') {\n    return String(value)\n  }\n\n  if (value.endsWith('\\n')) {\n    // DOM innerText strips the last \\n, therefore we add an extra \\n here\n    return value + '\\n'\n  }\n\n  return value\n}\n\n/**\n * Remove a newline suffix from text returned by element.innerText, it adds\n * one return too much.\n */\nexport function removeNewLineSuffix(text: string): string {\n  return text.replace(/\\n$/, '')\n}\n\n// regular expression matching one or multiple return characters with all their\n// enclosing white spaces\nexport function removeReturnsAndSurroundingWhitespace(text: string): string {\n  return text.replace(/(\\b|^)\\s*(\\b|$)/g, (match) => {\n    return /\\n/.exec(match) ? '' : match\n  })\n}\n\nexport function isChildOfNodeName(element: Element, nodeName: string): boolean {\n  return isChildOf(element, (e) => e.nodeName.toUpperCase() === nodeName.toUpperCase())\n}\n\nexport function isChildOfAttribute(element: Element, name: string, value: string): boolean {\n  return isChildOf(element, (e) => hasAttribute(e, name, value))\n}\n\n// test whether a DOM element is a content editable div\nexport function isContentEditableDiv(element: HTMLElement): boolean {\n  return element.nodeName === 'DIV' && element.contentEditable === 'true'\n}\n\n// test whether a DOM element is an \"input\" with type \"text\"\nexport function isTextInput(element: HTMLInputElement): boolean {\n  return (\n    element.nodeName === 'INPUT' &&\n    element.type !== undefined &&\n    element.type.toLowerCase() === 'text'\n  )\n}\n\nfunction hasAttribute(element: Element, name: string, value: string): boolean {\n  return typeof element.getAttribute === 'function' && element.getAttribute(name) === value\n}\n\n/**\n * Test if the element or one of its parents has a certain predicate\n * Can be use for example to check whether the element or it's parent has\n * a specific attribute or nodeName.\n */\nexport function isChildOf(element: Element, predicate: (element: Element) => boolean): boolean {\n  return !!findParent(element, predicate)\n}\n\n/**\n * Test if the element or one of its parents has a certain predicate\n * Can be use for example to check whether the element or it's parent has\n * a specific attribute or nodeName.\n * @param {HTMLElement} element\n * @param {function (element: HTMLElement) : boolean} predicate\n * @returns {HTMLElement | undefined}\n */\nexport function findParent(\n  element: Element,\n  predicate: (element: Element) => boolean\n): Element | undefined {\n  let e: Element | undefined = element\n\n  while (e && !predicate(e)) {\n    e = e.parentNode as Element\n  }\n\n  return e\n}\n\n/**\n * Set the cursor to the end of a content editable div\n * Source: https://stackoverflow.com/questions/13513329/set-cursor-to-the-end-of-contenteditable-div\n * @param {HTMLElement} element\n */\nexport function setCursorToEnd(element: HTMLElement) {\n  if (element.firstChild == null) {\n    element.focus()\n    return\n  }\n\n  const range = document.createRange()\n  const selection = window.getSelection()\n  range.setStart(element, 1)\n  range.collapse(true)\n  selection?.removeAllRanges()\n  selection?.addRange(range)\n}\n\n/**\n * Gets a DOM element's Window.  This is normally just the global `window`\n * variable, but if we opened a child window, it may be different.\n */\nexport function getWindow(element: Element): Window | undefined {\n  return element?.ownerDocument?.defaultView ?? undefined\n}\n\nexport function activeElementIsChildOf(element: Element) {\n  const window = getWindow(element)\n  const activeElement = window?.document.activeElement\n  return activeElement ? isChildOf(activeElement, (e) => e === element) : false\n}\n\n/**\n * Traverse over the parents of the element until a node is found with the\n * searched for node name. If the element itself contains the nodeName, the\n * element itself will be returned\n */\nexport function findParentWithNodeName(element: Element, nodeName: string): Element | undefined {\n  return findParent(element, (e) => e.nodeName === nodeName)\n}\n\nexport function getSelectionTypeFromTarget(target: Element): SelectionType {\n  if (isChildOfAttribute(target, 'data-type', 'selectable-key')) {\n    return SelectionType.key\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'selectable-value')) {\n    return SelectionType.value\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-inside')) {\n    return SelectionType.inside\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-after')) {\n    return SelectionType.after\n  }\n\n  return SelectionType.multi\n}\n\n/**\n * Encode a path into a string that can be used as attribute in HTML\n */\nexport function encodeDataPath(path: JSONPath): string {\n  return encodeURIComponent(compileJSONPointer(path))\n}\n\n/**\n * Decode a path that was stringified for use as an HTML attribute\n */\nexport function decodeDataPath(pathStr: string): JSONPath {\n  return parseJSONPointer(decodeURIComponent(pathStr))\n}\n\n/**\n * Find the data path of the given element. Traverses the parent nodes until find\n */\nexport function getDataPathFromTarget(target: Element): JSONPath | undefined {\n  const parent = findParent(target, (element) => {\n    return element?.hasAttribute ? element.hasAttribute('data-path') : false\n  })\n\n  const dataPath = parent?.getAttribute('data-path') ?? undefined\n  return dataPath ? decodeDataPath(dataPath) : undefined\n}\n\n/**\n * Find the nearest element in a given context menu with buttons or inputs\n */\n// TODO: unit test\nexport function findNearestElement<T extends Element>({\n  allElements,\n  currentElement,\n  direction,\n  hasPrio = () => true,\n  margin = 10\n}: {\n  allElements: T[]\n  currentElement: T\n  direction: 'Up' | 'Down' | 'Left' | 'Right'\n  margin?: number\n  hasPrio?: (element: T) => boolean\n}): T | undefined {\n  const all = map(allElements.filter(isVisible), calculateCenter)\n  const current = calculateCenter(currentElement)\n\n  interface CenterLocation {\n    x: number\n    y: number\n    rect: DOMRect\n    element: T\n  }\n\n  function isVisible(element: T): boolean {\n    const rect = element.getBoundingClientRect()\n    return rect.width > 0 && rect.height > 0\n  }\n\n  function calculateCenter(element: T): CenterLocation {\n    const rect = element.getBoundingClientRect()\n    return {\n      x: rect.left + rect.width / 2,\n      y: rect.top + rect.height / 2,\n      rect,\n      element\n    }\n  }\n\n  const isOnSameRow = (a: CenterLocation, b: CenterLocation) => Math.abs(a.y - b.y) < margin\n  const isLeft = (a: CenterLocation, b: CenterLocation) => a.rect.left + margin < b.rect.left\n  const isRight = (a: CenterLocation, b: CenterLocation) => a.rect.right > b.rect.right + margin\n  const isAbove = (a: CenterLocation, b: CenterLocation) => a.y + margin < b.y\n  const isBelow = (a: CenterLocation, b: CenterLocation) => a.y > b.y + margin\n\n  function distance(a: CenterLocation, b: CenterLocation, weightY = 1): number {\n    const diffX = a.x - b.x\n    const diffY = (a.y - b.y) * weightY\n    return Math.sqrt(diffX * diffX + diffY * diffY)\n  }\n  const distanceToCurrent = (candidate: CenterLocation) => distance(candidate, current)\n  const distanceToCurrentWeighted = (candidate: CenterLocation) => distance(candidate, current, 10)\n\n  if (direction === 'Left' || direction === 'Right') {\n    // First we find the first button left from the current button on the same row\n    // if not found, search the closest button left/right from current button\n    const candidatesLeft =\n      direction === 'Left'\n        ? all.filter((button) => isLeft(button, current))\n        : all.filter((button) => isRight(button, current))\n    const candidatesLeftOnRow = candidatesLeft.filter((button) => isOnSameRow(button, current))\n    const nearest =\n      minBy(candidatesLeftOnRow, distanceToCurrent) ||\n      minBy(candidatesLeft, distanceToCurrentWeighted)\n\n    return nearest?.element\n  }\n\n  if (direction === 'Up' || direction === 'Down') {\n    // first we only search through the prio buttons\n    // if there were no matching prio buttons, search all matching buttons\n    const candidates =\n      direction === 'Up'\n        ? all.filter((button) => isAbove(button, current))\n        : all.filter((button) => isBelow(button, current))\n    const prioCandidates = candidates.filter((button) => hasPrio(button.element))\n    const nearest = minBy(prioCandidates, distanceToCurrent) || minBy(candidates, distanceToCurrent)\n\n    return nearest?.element\n  }\n\n  return undefined\n}\n","declare global {\n  // extend with the userAgentData: NavigatorUAData property (currently experimental)\n  // see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgentData\n  interface Navigator {\n    userAgentData?: {\n      platform: string\n    }\n  }\n}\n\nexport function isMacDevice() {\n  return (\n    typeof navigator !== 'undefined' &&\n    (navigator?.platform?.toUpperCase().includes('MAC') ??\n      navigator?.userAgentData?.platform?.toUpperCase().includes('MAC') ??\n      false)\n  )\n}\n","// inspiration: https://github.com/andrepolischuk/keycomb\n\nimport { isMacDevice } from './navigatorUtils.js'\n\n// KeyComboEvent is a subset of KeyboardEvent\nexport interface KeyComboEvent {\n  ctrlKey: boolean\n  metaKey: boolean\n  altKey: boolean\n  shiftKey: boolean\n  key: string\n}\n\n/**\n * Get the active key combination from a keyboard event.\n * For example returns \"Ctrl+Shift+ArrowUp\" or \"Ctrl+A\"\n *\n * Returns the same output on both Windows and Mac:\n * meta keys \"Ctrl\" (\"Command\" on Mac), and \"Alt\" (\"Alt\" or \"Option\" on Mac)\n * So pressing \"Command\" and \"A\"on Mac will return \"Ctrl+A\"\n */\nexport function keyComboFromEvent(\n  event: KeyComboEvent,\n  separator = '+',\n  isMac = isMacDevice\n): string {\n  const combi = []\n\n  if (isCtrlKeyDown(event, isMac)) {\n    // on Mac this is called Command or Cmd\n    combi.push('Ctrl')\n  }\n  if (event.altKey) {\n    // on Mac this is called Option\n    combi.push('Alt')\n  }\n  if (event.shiftKey) {\n    combi.push('Shift')\n  }\n\n  const keyName = event.key.length === 1 ? event.key.toUpperCase() : event.key\n  if (!(keyName in metaKeys)) {\n    // prevent output like 'Ctrl+Ctrl'\n    combi.push(keyName)\n  }\n\n  return combi.join(separator)\n}\n\n/**\n * Test whether the Ctrl key (windows, linux) or Command key (mac) is down\n */\nexport function isCtrlKeyDown(\n  event: { ctrlKey: boolean; metaKey: boolean },\n  isMac = isMacDevice\n): boolean {\n  // metaKey is the Command key ⌘ on a Mac (but the Windows Key ⊞ on Windows)\n  return event.ctrlKey || (event.metaKey && isMac())\n}\n\nconst metaKeys = {\n  Ctrl: true,\n  Command: true,\n  Control: true,\n  Alt: true,\n  Option: true,\n  Shift: true\n}\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<script lang=\"ts\">\n  import type { AbsolutePopupOptions, PopupEntry } from '$lib/types.js'\n  import { onMount } from 'svelte'\n  import { isChildOf } from '$lib/utils/domUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n\n  export let popup: PopupEntry\n  export let closeAbsolutePopup: (popupId: number) => void\n\n  let refRootPopup: HTMLDivElement\n  let refHiddenInput: HTMLInputElement\n\n  onMount(focus)\n\n  function closeWhenOutside(event: Event) {\n    if (\n      popup.options &&\n      popup.options.closeOnOuterClick &&\n      !isChildOf(event.target as HTMLElement, (e) => e === refRootPopup)\n    ) {\n      closeAbsolutePopup(popup.id)\n    }\n  }\n\n  function handleWindowMouseDown(event: Event) {\n    closeWhenOutside(event)\n  }\n\n  function handleMouseDownInside(event: Event) {\n    event.stopPropagation()\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    if (combo === 'Escape') {\n      event.preventDefault()\n      event.stopPropagation()\n      closeAbsolutePopup(popup.id)\n    }\n  }\n\n  function handleScrollWheel(event: Event) {\n    closeWhenOutside(event)\n  }\n\n  function calculateStyle(refRootPopup: HTMLDivElement, options: AbsolutePopupOptions) {\n    function calculatePosition() {\n      if (options.anchor) {\n        const { anchor, width = 0, height = 0, offsetTop = 0, offsetLeft = 0, position } = options\n        const { left, top, bottom, right } = anchor.getBoundingClientRect()\n\n        const positionAbove =\n          position === 'top' || (top + height > window.innerHeight && top > height)\n        const positionLeft =\n          position === 'left' || (left + width > window.innerWidth && left > width)\n\n        return {\n          left: positionLeft ? right - offsetLeft : left + offsetLeft,\n          top: positionAbove ? top - offsetTop : bottom + offsetTop,\n          positionAbove,\n          positionLeft\n        }\n      } else if (typeof options.left === 'number' && typeof options.top === 'number') {\n        const { left, top, width = 0, height = 0 } = options\n\n        const positionAbove = top + height > window.innerHeight && top > height\n        const positionLeft = left + width > window.innerWidth && left > width\n\n        return {\n          left,\n          top,\n          positionAbove,\n          positionLeft\n        }\n      } else {\n        throw new Error('Invalid config: pass either \"left\" and \"top\", or pass \"anchor\"')\n      }\n    }\n\n    const rootRect = refRootPopup.getBoundingClientRect()\n    const { left, top, positionAbove, positionLeft } = calculatePosition()\n\n    const verticalStyling = positionAbove\n      ? `bottom: ${rootRect.top - top}px;`\n      : `top: ${top - rootRect.top}px;`\n\n    const horizontalStyling = positionLeft\n      ? `right: ${rootRect.left - left}px;`\n      : `left: ${left - rootRect.left}px;`\n\n    return verticalStyling + horizontalStyling\n  }\n\n  function focus() {\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n    }\n  }\n</script>\n\n<svelte:window\n  on:mousedown|capture={handleWindowMouseDown}\n  on:keydown|capture={handleKeyDown}\n  on:wheel|capture={handleScrollWheel}\n/>\n\n<div\n  role=\"none\"\n  bind:this={refRootPopup}\n  class=\"jse-absolute-popup\"\n  on:mousedown={handleMouseDownInside}\n  on:keydown={handleKeyDown}\n>\n  {#if refRootPopup}\n    <div class=\"jse-absolute-popup-content\" style={calculateStyle(refRootPopup, popup.options)}>\n      <input\n        type=\"text\"\n        readonly\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n      />\n      <svelte:component this={popup.component} {...popup.props} />\n    </div>\n  {/if}\n</div>\n\n<style src=\"./AbsolutePopupEntry.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { createDebug } from '$lib/utils/debug.js'\n  import { setContext, type SvelteComponent } from 'svelte'\n  import type { AbsolutePopupOptions, PopupEntry, AbsolutePopupContext } from '$lib/types'\n  import { uniqueId } from '$lib/utils/uniqueId.js'\n  import AbsolutePopupEntry from './AbsolutePopupEntry.svelte'\n\n  const debug = createDebug('jsoneditor:AbsolutePopup')\n\n  let popups: PopupEntry[] = []\n\n  function openAbsolutePopup(\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ): number {\n    debug('open...', props, options)\n\n    const popup: PopupEntry = {\n      id: uniqueId(),\n      component: component,\n      props: props || {},\n      options: options || {}\n    }\n\n    popups = [...popups, popup]\n\n    return popup.id\n  }\n\n  function closeAbsolutePopup(popupId: number | undefined) {\n    const popupIndex = popups.findIndex((popup) => popup.id === popupId)\n\n    if (popupIndex !== -1) {\n      const popup = popups[popupIndex]\n      if (popup.options.onClose) {\n        popup.options.onClose()\n      }\n\n      popups = popups.filter((popup) => popup.id !== popupId)\n    }\n  }\n\n  $: debug('popups', popups)\n\n  setContext<AbsolutePopupContext>('absolute-popup', { openAbsolutePopup, closeAbsolutePopup })\n</script>\n\n{#each popups as popup}\n  <AbsolutePopupEntry {popup} {closeAbsolutePopup} />\n{/each}\n\n<slot />\n","/**\n * Find a unique name. Suffix the name with ' (copy)', '(copy 2)', etc\n * until a unique name is found\n * @param name    Proposed name\n * @param keys    Array with existing keys\n */\nexport function findUniqueName(name: string, keys: string[]): string {\n  const keysSet = new Set(keys)\n\n  // remove any \" (copy)\" or \" (copy 2)\" suffix from the name\n  const nameWithoutCopySuffix = name.replace(/ \\(copy( \\d+)?\\)$/, '')\n\n  let validName = name\n  let i = 1\n\n  while (keysSet.has(validName)) {\n    const copy = 'copy' + (i > 1 ? ' ' + i : '')\n    validName = `${nameWithoutCopySuffix} (${copy})`\n    i++\n  }\n\n  return validName\n}\n\n/**\n * Transform a text into lower case with the first character upper case\n */\nexport function toCapital(text: string): string {\n  return text && text.length > 0 ? text[0].toUpperCase() + text.substring(1).toLowerCase() : text\n}\n\nexport function compareStrings(a: string, b: string): -1 | 0 | 1 {\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\n/**\n * Duplicate a piece of text\n */\nexport function duplicateInText(text: string, anchorOffset: number, focusOffset: number): string {\n  const startOffset = Math.min(anchorOffset, focusOffset)\n  const endOffset = Math.max(anchorOffset, focusOffset)\n\n  return (\n    text.slice(0, endOffset) +\n    text.slice(startOffset, endOffset) + // the duplicated piece of the text\n    text.slice(endOffset)\n  )\n}\n\n/**\n * Truncate a text to a maximum length.\n * When truncated, the text will pe appended with ellipsis '...'\n * @param text Text to be truncated\n * @param maxLength Maximum allowed length for the text including ellipsis\n */\nexport function truncate(text: string, maxLength: number): string {\n  const ellipsis = '...'\n  const maxTextLength = maxLength - ellipsis.length\n\n  return text.length > maxLength ? text.substring(0, maxTextLength) + ellipsis : text\n}\n\n/**\n * Cast contents of a string to the correct type.\n * This can be a string, a number, a boolean, null, undefined, etc\n * @param str\n * @return parsed string\n */\nexport function parseString(str: string): string | number | boolean | null | undefined {\n  if (str === '') {\n    return ''\n  }\n\n  const lower = str.toLowerCase()\n  if (lower === 'null') {\n    return null\n  }\n  if (lower === 'true') {\n    return true\n  }\n  if (lower === 'false') {\n    return false\n  }\n  if (lower === 'undefined') {\n    return undefined\n  }\n\n  const num = Number(str) // will nicely fail with '123ab'\n  const numFloat = parseFloat(str) // will nicely fail with '  '\n  if (!isNaN(num) && !isNaN(numFloat)) {\n    return num\n  }\n\n  return str\n}\n","import { jsonquery, type JSONQuery, parse, stringify } from '@jsonquerylang/jsonquery'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://jsonquerylang.org\" target=\"_blank\" \n  rel=\"noopener noreferrer\">JSON Query</a> function to filter, sort, or transform the data.\n  You can use functions like <code>get</code>, <code>filter</code>,\n  <code>sort</code>, <code>pick</code>, <code>groupBy</code>, <code>uniq</code>, etcetera. \n  Example query: <code>filter(.age >= 18)</code>\n</p>\n`\n\nexport const jsonQueryLanguage: QueryLanguage = {\n  id: 'jsonquery',\n  name: 'JSONQuery',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(_json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryFunctions: JSONQuery[] = []\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    queryFunctions.push([\n      'filter',\n      [\n        getOperatorName(filter.relation),\n        getter(filter.path),\n        parseString(filter.value) as JSONQuery\n      ]\n    ])\n  }\n\n  if (sort && sort.path && sort.direction) {\n    queryFunctions.push(['sort', getter(sort.path), sort.direction === 'desc' ? 'desc' : 'asc'])\n  }\n\n  if (projection && projection.paths) {\n    if (projection.paths.length > 1) {\n      queryFunctions.push(['pick', ...projection.paths.map(getter)])\n    } else {\n      queryFunctions.push(['map', getter(projection.paths[0])])\n    }\n  }\n\n  return stringify(['pipe', ...queryFunctions])\n}\n\nfunction getter(path: JSONPath): ['get', ...path: JSONPath] {\n  return ['get', ...path]\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  return query.trim() !== '' ? jsonquery(json, query) : json\n}\n\nfunction getOperatorName(operator: string): string {\n  // a trick to get the name of the operator by parsing the operator in a temporary query\n  return (parse(`1 ${operator} 1`) as [string, number, number])[0]\n}\n","<g>\n  {@html raw}\n</g>\n\n<script lang=\"ts\">\n  import type { IconData } from '../Icon.svelte';\n\n  let cursor = 0xd4937;\n  function getId() {\n    cursor += 1;\n    return `fa-${cursor.toString(16)}`;\n  }\n\n  let raw = '';\n\n  export let data: IconData;\n\n  function getRaw(data: IconData) {\n    if (!data || !data.raw) {\n      return '';\n    }\n    let rawData = data.raw;\n    const ids: Record<string, string> = {};\n    rawData = rawData.replace(/\\s(?:xml:)?id=[\"']?([^\"')\\s]+)/g, (match, id) => {\n      const uniqueId = getId();\n      ids[id] = uniqueId;\n      return ` id=\"${uniqueId}\"`;\n    });\n\n    rawData = rawData.replace(\n      /#(?:([^'\")\\s]+)|xpointer\\(id\\((['\"]?)([^')]+)\\2\\)\\))/g,\n      (match, rawId, _, pointerId) => {\n        const id = rawId || pointerId;\n        if (!id || !ids[id]) {\n          return match;\n        }\n        return `#${ids[id]}`;\n      }\n    );\n    return rawData;\n  }\n\n  $: raw = getRaw(data);\n</script>\n","<Svg\n  {label}\n  {width}\n  {height}\n  {box}\n  style={combinedStyle}\n  {spin}\n  {flip}\n  {inverse}\n  {pulse}\n  class={className}\n  {...$$restProps}\n>\n  <slot>\n    {#each iconData?.paths || [] as path}\n      <path {...path} />\n    {/each}\n    {#each iconData?.polygons || [] as polygon}\n      <polygon {...polygon} />\n    {/each}\n    {#if iconData?.raw}\n      <Raw bind:data={iconData} />\n    {/if}\n  </slot>\n</Svg>\n\n<script context=\"module\" lang=\"ts\">\n  export interface FaIconDefinition {\n    prefix: string;\n    iconName: string;\n    icon: [\n      number, // width\n      number, // height\n      string[], // ligatures\n      string, // unicode\n      string | string[] // svgPathData\n    ];\n  }\n\n  export interface IconPath {\n    id?: string;\n    d: string;\n    style?: string;\n    stroke?: string;\n  }\n\n  export interface IconPolygon {\n    points: string;\n    style?: string;\n  }\n\n  export interface IconData {\n    width: number;\n    height: number;\n    paths?: IconPath[];\n    polygons?: IconPolygon[];\n    raw?: string;\n  }\n\n  export type IconType = Record<string, IconData> | FaIconDefinition;\n</script>\n\n<script lang=\"ts\">\n  import Raw from './svg/Raw.svelte';\n  import Svg from './svg/Svg.svelte';\n\n  let className = '';\n\n  export let data: IconType;\n  let iconData: IconData | undefined;\n  export let scale = 1;\n  export let spin = false;\n  export let inverse = false;\n  export let pulse = false;\n  export let flip: 'horizontal' | 'vertical' | undefined = undefined;\n  export let label: string = '';\n  export let style: string = '';\n  export { className as class };\n\n  // internal\n  let childrenHeight = 0;\n  let childrenWidth = 0;\n  let outerScale = 1;\n\n  let width: number = 10;\n  let height: number = 10;\n  let combinedStyle: string;\n  let box: string;\n\n  function normaliseData(data: IconType): IconData | undefined {\n    let name: string;\n    let iconData: IconData;\n    if (!data) {\n      return undefined;\n    } else if ('definition' in data) {\n      console.error(\n        \"`import faIconName from '@fortawesome/package-name/faIconName` not supported - Please use `import { faIconName } from '@fortawesome/package-name/faIconName'` instead\"\n      );\n      return undefined;\n    } else if ('iconName' in data && 'icon' in data) {\n      name = data.iconName as string;\n      // fontawesome v5/6 icon imported with:\n      // import { iconName } from '@fortawesome/packagename/iconName';\n      // import { iconName } from '@fortawesome/packagename';\n      const [width, height, , , path] = data.icon as Exclude<IconType['icon'], IconData>;\n      const paths = Array.isArray(path) ? path : [path];\n      iconData = {\n        width,\n        height,\n        paths: paths.map((path) => {\n          return { d: path };\n        })\n      };\n    } else {\n      // inbuilt icons\n      name = Object.keys(data)[0];\n      iconData = data[name];\n    }\n    return iconData;\n  }\n\n  function normalisedScale() {\n    let numScale = 1;\n    if (typeof scale !== 'undefined') {\n      numScale = Number(scale);\n    }\n    if (isNaN(numScale) || numScale <= 0) {\n      console.warn('Invalid prop: prop \"scale\" should be a number over 0.');\n      return outerScale;\n    }\n    return numScale * outerScale;\n  }\n\n  function calculateBox() {\n    if (iconData) {\n      return `0 0 ${iconData.width} ${iconData.height}`;\n    }\n    return `0 0 ${width} ${height}`;\n  }\n\n  function calculateRatio() {\n    if (!iconData) {\n      return 1;\n    }\n    return Math.max(iconData.width, iconData.height) / 16;\n  }\n\n  function calculateWidth() {\n    if (childrenWidth) {\n      return childrenWidth;\n    }\n    if (iconData) {\n      return (iconData.width / calculateRatio()) * normalisedScale();\n    }\n    return 0;\n  }\n\n  function calculateHeight() {\n    if (childrenHeight) {\n      return childrenHeight;\n    }\n    if (iconData) {\n      return (iconData.height / calculateRatio()) * normalisedScale();\n    }\n    return 0;\n  }\n\n  function calculateStyle() {\n    let combined = '';\n    if (style !== null) {\n      combined += style;\n    }\n    let size = normalisedScale();\n    if (size === 1) {\n      if (combined.length === 0) {\n        return '';\n      }\n      return combined;\n    }\n    if (combined !== '' && !combined.endsWith(';')) {\n      combined += '; ';\n    }\n    return `${combined}font-size: ${size}em`;\n  }\n\n  $: {\n    iconData = normaliseData(data);\n    style;\n    scale;\n    width = calculateWidth();\n    height = calculateHeight();\n    combinedStyle = calculateStyle();\n    box = calculateBox();\n  }\n</script>\n\n<svelte:options namespace=\"svg\" />\n","<svg\n  version=\"1.1\"\n  class=\"fa-icon {className}\"\n  class:fa-spin={spin}\n  class:fa-pulse={pulse}\n  class:fa-inverse={inverse}\n  class:fa-flip-horizontal={flip === 'horizontal'}\n  class:fa-flip-vertical={flip === 'vertical'}\n  {width}\n  {height}\n  aria-label={label}\n  role={label ? 'img' : 'presentation'}\n  viewBox={box}\n  {style}\n  {...$$restProps}\n>\n  <slot />\n</svg>\n\n<style>\n  .fa-icon {\n    display: inline-block;\n    fill: currentColor;\n  }\n  .fa-flip-horizontal {\n    transform: scale(-1, 1);\n  }\n  .fa-flip-vertical {\n    transform: scale(1, -1);\n  }\n  .fa-spin {\n    animation: fa-spin 1s 0s infinite linear;\n  }\n  .fa-inverse {\n    color: #fff;\n  }\n  .fa-pulse {\n    animation: fa-spin 1s infinite steps(8);\n  }\n  @keyframes fa-spin {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n</style>\n\n<script lang=\"ts\">\n  let className: string = '';\n\n  export { className as class };\n\n  export let width: number;\n  export let height: number;\n  export let box: string = '0 0 0 0';\n\n  export let spin = false;\n  export let inverse = false;\n  export let pulse = false;\n  export let flip: string = 'none';\n\n  // optionals\n  export let style: string = '';\n  export let label: string = '';\n</script>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCheckSquare, faSquare } from '@fortawesome/free-regular-svg-icons'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import Icon from 'svelte-awesome'\n  import type { OnPatch } from '$lib/types.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let readOnly: boolean\n  export let onPatch: OnPatch\n  export let focus: () => void\n\n  function toggleBooleanValue(event: MouseEvent) {\n    event.stopPropagation()\n\n    if (readOnly) {\n      return\n    }\n\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: !value\n      }\n    ])\n\n    focus()\n  }\n</script>\n\n<div\n  role=\"checkbox\"\n  tabindex=\"-1\"\n  aria-checked={value === true}\n  class=\"jse-boolean-toggle\"\n  class:jse-readonly={readOnly}\n  on:mousedown={toggleBooleanValue}\n  title={!readOnly ? 'Click to toggle this boolean value' : `Boolean value ${value}`}\n>\n  <Icon data={value === true ? faCheckSquare : faSquare} />\n</div>\n\n<style src=\"./BooleanToggle.scss\"></style>\n","<script lang=\"ts\">\n  import { onDestroy, onMount } from 'svelte'\n\n  export let color: string\n  export let onChange: (newColor: string) => void\n  export let showOnTop: boolean\n\n  let ref: HTMLElement | undefined\n  let destroyColorPicker = () => {}\n\n  onMount(async () => {\n    // Dynamically import VanillaPicker, because it requires `document` to be defined,\n    // and that is not supported server side\n    const VanillaPicker = (await import('vanilla-picker'))?.default\n\n    const colorPicker = new VanillaPicker({\n      parent: ref,\n      color,\n      popup: showOnTop ? 'top' : 'bottom',\n      onDone: function (color) {\n        const alpha = color.rgba[3]\n        const hex =\n          alpha === 1\n            ? color.hex.substring(0, 7) // return #RRGGBB\n            : color.hex // return #RRGGBBAA\n        onChange(hex)\n      }\n    })\n\n    colorPicker.show()\n\n    destroyColorPicker = () => {\n      colorPicker.destroy()\n    }\n  })\n\n  onDestroy(() => {\n    destroyColorPicker()\n  })\n</script>\n\n<div class=\"jse-color-picker-popup\" bind:this={ref}></div>\n\n<style src=\"./ColorPickerPopup.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getColorCSS } from '$lib/utils/typeUtils.js'\n  import { getWindow } from '$lib/utils/domUtils.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { getContext } from 'svelte'\n  import ColorPickerPopup from '../../../components/controls/ColorPickerPopup.svelte'\n  import type { AbsolutePopupContext, OnPatch } from '$lib/types.js'\n\n  const { openAbsolutePopup } = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let value: string\n  export let readOnly: boolean\n  export let onPatch: OnPatch\n  export let focus: () => void\n\n  $: color = getColorCSS(value)\n  $: title = !readOnly ? 'Click to open a color picker' : `Color ${value}`\n\n  function onChange(color: string) {\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: color\n      }\n    ])\n\n    onClose()\n  }\n\n  function onClose() {\n    focus()\n  }\n\n  function openColorPicker(event: MouseEvent) {\n    if (readOnly) {\n      return\n    }\n\n    // estimate of the color picker height\n    // we'll render the color picker on top\n    // when there is not enough space below, and there is enough space above\n    const height = 300\n\n    const target = event.target as Element\n    const top = target.getBoundingClientRect().top\n    const windowHeight = getWindow(target)?.innerHeight ?? 0\n    const showOnTop = windowHeight - top < height && top > height\n\n    const props = {\n      color: value,\n      onChange,\n      showOnTop\n    }\n\n    openAbsolutePopup(ColorPickerPopup, props, {\n      anchor: target,\n      closeOnOuterClick: true,\n      onClose,\n      offsetTop: 18,\n      offsetLeft: -8,\n      height\n    })\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-color-picker-button\"\n  class:jse-readonly={readOnly}\n  style=\"background: {color}\"\n  {title}\n  aria-label={title}\n  on:click={openColorPicker}\n></button>\n\n<style src=\"./ColorPicker.scss\"></style>\n","import type { Section } from './types'\nimport { SortDirection } from './types.js'\n\nexport const SCROLL_DURATION = 300 // ms\nexport const DEBOUNCE_DELAY = 300 // ms\nexport const TEXT_MODE_ONCHANGE_DELAY = 300 // ms\nexport const AUTO_SCROLL_INTERVAL = 50 // ms\nexport const AUTO_SCROLL_SPEED_SLOW = 200 // pixels per second\nexport const AUTO_SCROLL_SPEED_NORMAL = 400 // pixels per second\nexport const AUTO_SCROLL_SPEED_FAST = 1200 // pixels per second\nexport const MAX_SEARCH_RESULTS = 1000\nexport const ARRAY_SECTION_SIZE = 100\nexport const MAX_VALIDATION_ERRORS = 100\nexport const MAX_CHARACTERS_TEXT_PREVIEW = 20000\nexport const MAX_INLINE_OBJECT_CHARS = 50\nexport const MAX_HEADER_NAME_CHARACTERS = 50\nexport const DEFAULT_VISIBLE_SECTIONS: Section[] = [{ start: 0, end: ARRAY_SECTION_SIZE }]\nexport const MAX_VALIDATABLE_SIZE = 100 * 1024 * 1024 // 1 MB\nexport const MAX_AUTO_REPAIRABLE_SIZE = 1024 * 1024 // 1 MB\nexport const MAX_DOCUMENT_SIZE_TEXT_MODE = 10 * 1024 * 1024 // 10 MB\nexport const MAX_DOCUMENT_SIZE_EXPAND_ALL = 10 * 1024 // 10 KB\n\nexport const INSERT_EXPLANATION =\n  'Insert or paste contents, ' +\n  'enter [ insert a new array, ' +\n  'enter { to insert a new object, ' +\n  'or start typing to insert a new value'\n\nexport const CONTEXT_MENU_EXPLANATION =\n  'Open context menu ' +\n  '(Click here, ' +\n  'right click on the selection, ' +\n  'or use the context menu button or Ctrl+Q)'\n\nexport const HOVER_INSERT_INSIDE = 'hover-insert-inside'\nexport const HOVER_INSERT_AFTER = 'hover-insert-after'\nexport const HOVER_COLLECTION = 'hover-collection'\n\nexport const JSON_STATUS_VALID = 'valid'\nexport const JSON_STATUS_REPAIRABLE = 'repairable'\nexport const JSON_STATUS_INVALID = 'invalid'\n\n// TODO: can we dynamically calculate the size?\nexport const CONTEXT_MENU_HEIGHT = (40 + 2) * 8 // px\nexport const CONTEXT_MENU_WIDTH = 260 // px\nexport const SEARCH_BOX_HEIGHT = 100 // px for search and replace\n\nexport const SORT_DIRECTION_NAMES = {\n  [SortDirection.asc]: 'ascending',\n  [SortDirection.desc]: 'descending'\n}\n","import { sortBy } from 'lodash-es'\nimport { ARRAY_SECTION_SIZE } from '../constants.js'\nimport type { Section } from '$lib/types.js'\n\n/**\n * Create sections that can be expanded.\n * Used to display a button like \"Show items 100-200\"\n */\nexport function getExpandItemsSections(startIndex: number, endIndex: number): Section[] {\n  // expand the start of the section\n  const section1 = {\n    start: startIndex,\n    end: Math.min(nextRoundNumber(startIndex), endIndex)\n  }\n\n  // expand the middle of the section\n  const start2 = Math.max(currentRoundNumber((startIndex + endIndex) / 2), startIndex)\n  const section2 = {\n    start: start2,\n    end: Math.min(nextRoundNumber(start2), endIndex)\n  }\n\n  // expand the end of the section\n  const currentIndex = currentRoundNumber(endIndex)\n  const previousIndex = currentIndex === endIndex ? currentIndex - ARRAY_SECTION_SIZE : currentIndex\n  const section3 = {\n    start: Math.max(previousIndex, startIndex),\n    end: endIndex\n  }\n\n  const sections = [section1]\n\n  const showSection2 = section2.start >= section1.end && section2.end <= section3.start\n  if (showSection2) {\n    sections.push(section2)\n  }\n\n  const showSection3 = section3.start >= (showSection2 ? section2.end : section1.end)\n  if (showSection3) {\n    sections.push(section3)\n  }\n\n  return sections\n}\n\n/**\n * Sort and merge a list with sections\n */\nexport function mergeSections(sections: Section[]): Section[] {\n  const sortedSections = sortBy(sections, (section) => section.start)\n\n  const mergedSections = [sortedSections[0]]\n\n  for (let sortedIndex = 0; sortedIndex < sortedSections.length; sortedIndex++) {\n    const mergedIndex = mergedSections.length - 1\n    const previous = mergedSections[mergedIndex]\n    const current = sortedSections[sortedIndex]\n\n    if (current.start <= previous.end) {\n      // there is overlap -> replace the previous item\n      mergedSections[mergedIndex] = {\n        start: Math.min(previous.start, current.start),\n        end: Math.max(previous.end, current.end)\n      }\n    } else {\n      // no overlap, just add the item\n      mergedSections.push(current)\n    }\n  }\n\n  return mergedSections\n}\n\n// TODO: write unit test\nexport function inVisibleSection(sections: Section[], index: number): boolean {\n  return sections.some((section) => {\n    return index >= section.start && index < section.end\n  })\n}\n\nexport function nextRoundNumber(index: number): number {\n  return currentRoundNumber(index) + ARRAY_SECTION_SIZE\n}\n\nexport function currentRoundNumber(index: number): number {\n  return Math.floor(index / ARRAY_SECTION_SIZE) * ARRAY_SECTION_SIZE\n}\n","import type {\n  ContentParseError,\n  ContentValidationErrors,\n  ContextMenuColumn,\n  ContextMenuRow,\n  MenuButton,\n  MenuDropDownButton,\n  MenuLabel,\n  MenuSeparator,\n  MenuSpace,\n  ValidationError,\n  NestedValidationError,\n  SvelteActionRenderer,\n  SvelteComponentRenderer,\n  RecursiveState,\n  ArrayRecursiveState,\n  ObjectRecursiveState,\n  ValueRecursiveState,\n  SearchResults,\n  WithSearchResults,\n  TreeHistoryItem,\n  HistoryItem,\n  TextHistoryItem,\n  ModeHistoryItem\n} from './types.js'\nimport { isObject } from '$lib/utils/typeUtils.js'\n\nexport function isMenuSpace(item: unknown): item is MenuSpace {\n  // checking the .space property is for backward compatibility\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'space' || item['space'] === true : false\n}\n\nexport function isMenuSeparator(item: unknown): item is MenuSeparator {\n  // checking the .separator property is for backward compatibility\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'separator' || item['separator'] === true : false\n}\n\nexport function isMenuLabel(item: unknown): item is MenuLabel {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'label' && typeof item['text'] === 'string' : false\n}\n\nexport function isMenuButton(item: unknown): item is MenuButton {\n  // for backward compatibility, we only check .onClick here and not item['type'] === 'button'\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? typeof item['onClick'] === 'function' : false\n}\n\nexport function isMenuDropDownButton(item: unknown): item is MenuDropDownButton {\n  return item\n    ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      item['type'] === 'dropdown-button' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        isMenuButton(item['main']) &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        Array.isArray(item['items'])\n    : false\n}\n\nexport function isContextMenuRow(item: unknown): item is ContextMenuRow {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'row' && Array.isArray(item['items']) : false\n}\n\nexport function isContextMenuColumn(item: unknown): item is ContextMenuColumn {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'column' && Array.isArray(item['items']) : false\n}\n\nexport function isContentParseError(contentErrors: unknown): contentErrors is ContentParseError {\n  return isObject(contentErrors) && isObject(contentErrors['parseError'])\n}\n\nexport function isContentValidationErrors(\n  contentErrors: unknown\n): contentErrors is ContentValidationErrors {\n  return isObject(contentErrors) && Array.isArray(contentErrors['validationErrors'])\n}\n\nexport function isValidationError(value: unknown): value is ValidationError {\n  return (\n    isObject(value) &&\n    Array.isArray(value.path) &&\n    typeof value.message === 'string' &&\n    'severity' in value\n  )\n}\n\nexport function isNestedValidationError(value: unknown): value is NestedValidationError {\n  return isObject(value) && isValidationError(value) && typeof value.isChildError === 'boolean'\n}\n\nexport function isSvelteComponentRenderer(value: unknown): value is SvelteComponentRenderer {\n  return isObject(value) && 'component' in value && isObject(value.props)\n}\n\nexport function isSvelteActionRenderer(value: unknown): value is SvelteActionRenderer {\n  return isObject(value) && typeof value.action === 'function' && isObject(value.props)\n}\n\nexport function isObjectRecursiveState(\n  state: RecursiveState | undefined\n): state is ObjectRecursiveState {\n  return state !== undefined && state.type === 'object'\n}\n\nexport function isArrayRecursiveState(\n  state: RecursiveState | undefined\n): state is ArrayRecursiveState {\n  return state !== undefined && state.type === 'array'\n}\n\nexport function isValueRecursiveState(\n  state: RecursiveState | undefined\n): state is ValueRecursiveState {\n  return state !== undefined && state.type === 'value'\n}\n\nexport function isExpandableState(\n  state: RecursiveState | undefined\n): state is ObjectRecursiveState | ArrayRecursiveState {\n  return isObjectRecursiveState(state) || isArrayRecursiveState(state)\n}\n\nexport function hasSearchResults(state: SearchResults | undefined): state is WithSearchResults {\n  return (\n    state !== undefined &&\n    Array.isArray((state as unknown as Record<string, unknown>).searchResults)\n  )\n}\n\nexport function isTreeHistoryItem(\n  historyItem: HistoryItem | undefined\n): historyItem is TreeHistoryItem {\n  return historyItem ? historyItem.type === 'tree' : false\n}\n\nexport function isTextHistoryItem(\n  historyItem: HistoryItem | undefined\n): historyItem is TextHistoryItem {\n  return historyItem ? historyItem.type === 'text' : false\n}\n\nexport function isModeHistoryItem(\n  historyItem: HistoryItem | undefined\n): historyItem is ModeHistoryItem {\n  return historyItem ? historyItem.type === 'mode' : false\n}\n","import {\n  compileJSONPointer,\n  deleteIn,\n  existsIn,\n  getIn,\n  immutableJSONPatch,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchAdd,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  isJSONPatchRemove,\n  isJSONPatchReplace,\n  type JSONPatchAdd,\n  type JSONPatchCopy,\n  type JSONPatchDocument,\n  type JSONPatchMove,\n  type JSONPatchOperation,\n  type JSONPatchRemove,\n  type JSONPath,\n  parsePath,\n  setIn,\n  updateIn\n} from 'immutable-json-patch'\nimport { initial, last } from 'lodash-es'\nimport { DEFAULT_VISIBLE_SECTIONS, MAX_DOCUMENT_SIZE_EXPAND_ALL } from '../constants.js'\nimport { forEachIndex, insertItemsAt, strictShallowEqual } from '../utils/arrayUtils.js'\nimport { isObject, isStringContainingPrimitiveValue } from '../utils/typeUtils.js'\nimport {\n  currentRoundNumber,\n  inVisibleSection,\n  mergeSections,\n  nextRoundNumber\n} from './expandItemsSections.js'\nimport type {\n  ArrayDocumentState,\n  CaretPosition,\n  DocumentState,\n  ObjectDocumentState,\n  OnExpand,\n  ArrayRecursiveState,\n  RecursiveState,\n  RecursiveStateFactory,\n  Section,\n  ValueDocumentState,\n  VisibleSection\n} from '$lib/types'\nimport { CaretType } from '$lib/types.js'\nimport { int } from '../utils/numberUtils.js'\nimport { isLargeContent } from '$lib/utils/jsonUtils.js'\nimport {\n  isArrayRecursiveState,\n  isExpandableState,\n  isObjectRecursiveState,\n  isValueRecursiveState\n} from '$lib/typeguards.js'\n\nexport type CreateRecursiveStateProps = {\n  json: unknown | undefined\n  factory: RecursiveStateFactory\n}\n\nexport function createRecursiveState({\n  json,\n  factory\n}: CreateRecursiveStateProps): RecursiveState | undefined {\n  return Array.isArray(json)\n    ? factory.createArrayDocumentState()\n    : isObject(json)\n      ? factory.createObjectDocumentState()\n      : json !== undefined\n        ? factory.createValueDocumentState()\n        : undefined\n}\n\nexport type CreateDocumentStateProps = {\n  json: unknown | undefined\n  expand?: OnExpand\n}\n\nexport function createDocumentState({\n  json,\n  expand\n}: CreateDocumentStateProps): DocumentState | undefined {\n  const documentState: DocumentState | undefined = createRecursiveState({\n    json,\n    factory: documentStateFactory\n  }) as DocumentState\n\n  return expand && documentState ? expandPath(json, documentState, [], expand) : documentState\n}\n\nexport function createArrayDocumentState({ expanded } = { expanded: false }): ArrayDocumentState {\n  return { type: 'array', expanded, visibleSections: DEFAULT_VISIBLE_SECTIONS, items: [] }\n}\n\nexport function createObjectDocumentState({ expanded } = { expanded: false }): ObjectDocumentState {\n  return { type: 'object', expanded, properties: {} }\n}\n\nexport function createValueDocumentState(): ValueDocumentState {\n  return { type: 'value' }\n}\n\nexport const documentStateFactory: RecursiveStateFactory = {\n  createObjectDocumentState,\n  createArrayDocumentState,\n  createValueDocumentState\n}\n\nexport function ensureRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath,\n  {\n    createObjectDocumentState,\n    createArrayDocumentState,\n    createValueDocumentState\n  }: RecursiveStateFactory\n): T {\n  function recurse(value: unknown, state: T | undefined, path: JSONPath): T {\n    if (Array.isArray(value)) {\n      const arrayState: ArrayRecursiveState = isArrayRecursiveState(state)\n        ? state\n        : createArrayDocumentState()\n      if (path.length === 0) {\n        return arrayState as T\n      }\n\n      const index = int(path[0])\n      const itemState = recurse(value[index], arrayState.items[index] as T, path.slice(1))\n      return setIn(arrayState, ['items', path[0]], itemState)\n    }\n\n    if (isObject(value)) {\n      const objectState = isObjectRecursiveState(state) ? state : createObjectDocumentState()\n      if (path.length === 0) {\n        return objectState as T\n      }\n\n      const key = path[0]\n      const itemState = recurse(value[key], objectState.properties[key] as T, path.slice(1))\n      return setIn(objectState, ['properties', key], itemState)\n    }\n\n    return isValueRecursiveState(state) ? state : (createValueDocumentState() as T)\n  }\n\n  return recurse(json, documentState, path)\n}\n\nexport function syncDocumentState(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath = []\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (nestedJson, nestedState) => {\n      if (nestedJson === undefined || nestedState === undefined) {\n        return undefined\n      }\n\n      if (Array.isArray(nestedJson)) {\n        if (isArrayRecursiveState(nestedState)) {\n          return nestedState\n        }\n\n        const expanded = isExpandableState(nestedState) ? nestedState.expanded : false\n        return createArrayDocumentState({ expanded })\n      }\n\n      if (isObject(nestedJson)) {\n        if (isObjectRecursiveState(nestedState)) {\n          return nestedState\n        }\n\n        const expanded = isExpandableState(nestedState) ? nestedState.expanded : false\n        return createObjectDocumentState({ expanded })\n      }\n\n      // json is of type value\n      if (isValueRecursiveState(nestedState)) {\n        return nestedState\n      }\n\n      // type of state does not match the actual type of the json\n      return undefined\n    },\n    () => true\n  )\n}\n\nfunction _transformDocumentState(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: (\n    nestedJson: unknown,\n    nestedState: DocumentState | undefined,\n    path: JSONPath\n  ) => DocumentState | undefined,\n  recurse: (nestedState: DocumentState | undefined) => boolean\n): DocumentState | undefined {\n  const updatedState = callback(json, documentState, path)\n\n  if (Array.isArray(json) && isArrayRecursiveState(updatedState) && recurse(updatedState)) {\n    const items: (DocumentState | undefined)[] = []\n\n    forEachVisibleIndex(json, updatedState.visibleSections, (index) => {\n      const itemPath = path.concat(String(index))\n      const value = json[index]\n      const item = updatedState.items[index]\n      const updatedItem = _transformDocumentState(value, item, itemPath, callback, recurse)\n      if (updatedItem !== undefined) {\n        items[index] = updatedItem\n      }\n    })\n\n    const changed = !strictShallowEqual(items, updatedState.items)\n\n    return changed ? { ...updatedState, items } : updatedState\n  }\n\n  if (isObject(json) && isObjectRecursiveState(updatedState) && recurse(updatedState)) {\n    const properties: ObjectDocumentState['properties'] = {}\n    Object.keys(json).forEach((key) => {\n      const propPath = path.concat(key)\n      const value = json[key]\n      const prop = updatedState.properties[key]\n      const updatedProp = _transformDocumentState(value, prop, propPath, callback, recurse)\n      if (updatedProp !== undefined) {\n        properties[key] = updatedProp\n      }\n    })\n\n    const changed = !strictShallowEqual(\n      Object.values(properties),\n      Object.values(updatedState.properties)\n    )\n\n    return changed ? { ...updatedState, properties } : updatedState\n  }\n\n  return updatedState\n}\n\n/**\n * Invoke a callback function for every visible item in the array\n */\nexport function forEachVisibleIndex(\n  jsonArray: Array<unknown>,\n  visibleSections: VisibleSection[],\n  callback: (index: number) => void\n) {\n  visibleSections.forEach(({ start, end }) => {\n    forEachIndex(start, Math.min(jsonArray.length, end), callback)\n  })\n}\n\nexport function expandVisibleSection(state: ArrayDocumentState, index: number): ArrayDocumentState {\n  if (inVisibleSection(state.visibleSections, index)) {\n    return state\n  }\n\n  const start = currentRoundNumber(index)\n  const end = nextRoundNumber(start)\n  const newVisibleSection = { start, end }\n\n  return {\n    ...state,\n    visibleSections: mergeSections(state.visibleSections.concat(newVisibleSection))\n  }\n}\n\nexport function toRecursiveStatePath(json: unknown, path: JSONPath): JSONPath {\n  let value = json\n  const recursiveStatePath: JSONPath = []\n\n  let i = 0\n  while (i < path.length) {\n    if (Array.isArray(value)) {\n      const index = path[i]\n      recursiveStatePath.push('items', index)\n      value = value[int(index)]\n    } else if (isObject(value)) {\n      const key = path[i]\n      recursiveStatePath.push('properties', key)\n      value = (value as Record<string, unknown>)[key]\n    } else {\n      throw new Error(`Cannot convert path: Object or Array expected at index ${i}`)\n    }\n\n    i++\n  }\n\n  return recursiveStatePath\n}\n\n/**\n * Expand all nodes along the given path, and expand invisible array sections if needed.\n * Then, optionally expand child nodes according to the provided callback.\n */\nexport function expandPath(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: OnExpand\n): DocumentState | undefined {\n  let updatedState = documentState\n\n  // Step 1: expand all nodes along the path, and update visibleSections if needed\n  for (let i = 0; i < path.length; i++) {\n    const partialPath = path.slice(0, i)\n\n    updatedState = updateInDocumentState(json, updatedState, partialPath, (_, nestedState) => {\n      const updatedState =\n        isExpandableState(nestedState) && !nestedState.expanded\n          ? { ...nestedState, expanded: true }\n          : nestedState\n\n      if (isArrayRecursiveState(updatedState)) {\n        const index = int(path[i])\n        return expandVisibleSection(updatedState, index)\n      }\n\n      return updatedState\n    })\n  }\n\n  // Step 2: recursively expand child nodes tested with the callback\n  return updateInDocumentState(json, updatedState, path, (nestedValue, nestedState) => {\n    const relativePath: JSONPath = []\n    return _expandRecursively(nestedValue, nestedState, relativePath, callback)\n  })\n}\n\nfunction _expandRecursively(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: OnExpand\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (nestedJson, nestedState, nestedPath) => {\n      if (Array.isArray(nestedJson) && callback(nestedPath)) {\n        return isArrayRecursiveState(nestedState)\n          ? nestedState.expanded\n            ? nestedState\n            : { ...nestedState, expanded: true }\n          : createArrayDocumentState({ expanded: true })\n      }\n\n      if (isObject(nestedJson) && callback(nestedPath)) {\n        return isObjectRecursiveState(nestedState)\n          ? nestedState.expanded\n            ? nestedState\n            : { ...nestedState, expanded: true }\n          : createObjectDocumentState({ expanded: true })\n      }\n\n      return nestedState\n    },\n    (nestedState) => isExpandableState(nestedState) && nestedState.expanded\n  )\n}\n\nexport function collapsePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  recursive: boolean\n): DocumentState | undefined {\n  return updateInDocumentState(json, documentState, path, (nestedJson, nestedState) => {\n    return recursive ? _collapseRecursively(nestedJson, nestedState, path) : _collapse(nestedState)\n  })\n}\n\nfunction _collapse<T extends DocumentState | undefined>(documentState: T): T {\n  if (isArrayRecursiveState(documentState) && documentState.expanded) {\n    return { ...documentState, expanded: false, visibleSections: DEFAULT_VISIBLE_SECTIONS }\n  }\n\n  if (isObjectRecursiveState(documentState) && documentState.expanded) {\n    return { ...documentState, expanded: false }\n  }\n\n  return documentState\n}\n\nfunction _collapseRecursively(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (_, nestedState) => _collapse(nestedState),\n    () => true\n  )\n}\n\n/**\n * Expand a section of items in an array\n */\nexport function expandSection(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  section: Section\n): DocumentState | undefined {\n  return updateInDocumentState(json, documentState, path, (_value, state) => {\n    if (!isArrayRecursiveState(state)) {\n      return state\n    }\n\n    const visibleSections = mergeSections(state.visibleSections.concat(section))\n\n    return { ...state, visibleSections }\n  })\n}\n\nexport function syncKeys(actualKeys: string[], prevKeys?: string[]): string[] {\n  if (!prevKeys) {\n    return actualKeys\n  }\n\n  // copy the keys that still exist\n  const actualKeysSet = new Set(actualKeys)\n  const keys = prevKeys.filter((key) => actualKeysSet.has(key))\n\n  // add new keys\n  const keysSet = new Set(keys)\n  actualKeys.filter((key) => !keysSet.has(key)).forEach((key) => keys.push(key))\n\n  return keys\n}\n\n/**\n * Apply patch operations to both json and state\n */\nexport function documentStatePatch(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operations: JSONPatchDocument\n): { json: unknown; documentState: DocumentState | undefined } {\n  const initial = { json, documentState }\n\n  const result = operations.reduce((current, operation) => {\n    return {\n      json: immutableJSONPatch(current.json, [operation]),\n      documentState: _documentStatePatch(current.json, current.documentState, operation)\n    }\n  }, initial)\n\n  return {\n    json: result.json,\n    documentState: syncDocumentState(result.json, result.documentState) // sync to clean up leftover state\n  }\n}\n\nfunction _documentStatePatch(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchOperation\n): DocumentState | undefined {\n  if (isJSONPatchAdd(operation)) {\n    return documentStateAdd(json, documentState, operation, undefined)\n  }\n\n  if (isJSONPatchRemove(operation)) {\n    return documentStateRemove(json, documentState, operation)\n  }\n\n  if (isJSONPatchReplace(operation)) {\n    const path = parsePath(json, operation.path)\n    const enforceString = getEnforceString(json, documentState, path)\n    if (enforceString) {\n      // ensure the enforceString setting is not lost when for example changing \"123\"\n      // into \"abc\" and later back to \"123\", so we now make it explicit.\n      return setInDocumentState(json, documentState, path, { type: 'value', enforceString })\n    }\n\n    // nothing special to do (all is handled by syncDocumentState)\n    return documentState\n  }\n\n  if (isJSONPatchCopy(operation) || isJSONPatchMove(operation)) {\n    return documentStateMoveOrCopy(json, documentState, operation)\n  }\n\n  return documentState\n}\n\nexport function getInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath\n): T | undefined {\n  try {\n    return getIn(documentState, toRecursiveStatePath(json, path))\n  } catch {\n    return undefined\n  }\n}\n\nexport function setInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  recursiveState: T | undefined,\n  path: JSONPath,\n  value: unknown,\n  factory: RecursiveStateFactory\n): T | undefined {\n  const ensuredState = ensureRecursiveState(json, recursiveState, path, factory)\n  return setIn(ensuredState, toRecursiveStatePath(json, path), value)\n}\n\nexport function updateInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: T) => T | undefined,\n  factory: RecursiveStateFactory\n): T {\n  const ensuredState: T = ensureRecursiveState(json, documentState, path, factory)\n  return updateIn(ensuredState, toRecursiveStatePath(json, path), (nestedState: T) => {\n    const value = getIn(json, path)\n    return transform(value, nestedState)\n  })\n}\n\nexport function setInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath,\n  value: unknown\n): T | undefined {\n  return setInRecursiveState(json, documentState, path, value, documentStateFactory)\n}\n\nexport function updateInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: T) => T | undefined\n): T {\n  return updateInRecursiveState(json, documentState, path, transform, documentStateFactory)\n}\n\nexport function deleteInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath\n): T | undefined {\n  const recursivePath = toRecursiveStatePath(json, path)\n\n  return existsIn(documentState, recursivePath)\n    ? deleteIn(documentState, toRecursiveStatePath(json, path))\n    : documentState\n}\n\nexport function documentStateAdd(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchAdd,\n  stateValue: DocumentState | undefined\n): DocumentState | undefined {\n  const path = parsePath(json, operation.path)\n  const parentPath = initial(path)\n\n  let updatedState = documentState\n\n  updatedState = updateInDocumentState(json, updatedState, parentPath, (_parent, arrayState) => {\n    if (!isArrayRecursiveState(arrayState)) {\n      return arrayState\n    }\n\n    const index = int(last(path) as string)\n    const { items, visibleSections } = arrayState\n    return {\n      ...arrayState,\n      items:\n        index < items.length\n          ? insertItemsAt(items, index, stateValue !== undefined ? [stateValue] : Array(1))\n          : items,\n      visibleSections: shiftVisibleSections(visibleSections, index, 1)\n    }\n  })\n\n  // object property added, nothing to do\n  return setInDocumentState(json, updatedState, path, stateValue)\n}\n\nexport function documentStateRemove(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchRemove\n): DocumentState | undefined {\n  const path = parsePath(json, operation.path)\n  const parentPath = initial(path)\n  const parent = getIn(json, parentPath)\n\n  if (Array.isArray(parent)) {\n    return updateInDocumentState(json, documentState, parentPath, (_parent, arrayState) => {\n      if (!isArrayRecursiveState(arrayState)) {\n        return arrayState\n      }\n\n      const index = int(last(path) as string)\n      const { items, visibleSections } = arrayState\n\n      return {\n        ...arrayState,\n        items: items.slice(0, index).concat(items.slice(index + 1)),\n        visibleSections: shiftVisibleSections(visibleSections, index, -1)\n      }\n    })\n  }\n\n  return deleteInDocumentState(json, documentState, path)\n}\n\nexport function documentStateMoveOrCopy(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchCopy | JSONPatchMove\n): DocumentState | undefined {\n  if (isJSONPatchMove(operation) && operation.from === operation.path) {\n    // nothing to do\n    return documentState\n  }\n\n  let updatedState = documentState\n\n  // get the state that we will move or copy\n  const from = parsePath(json, operation.from)\n  const stateValue = getInRecursiveState(json, updatedState, from)\n\n  if (isJSONPatchMove(operation)) {\n    updatedState = documentStateRemove(json, updatedState, {\n      op: 'remove',\n      path: operation.from\n    })\n  }\n\n  updatedState = documentStateAdd(\n    json,\n    updatedState,\n    {\n      op: 'add',\n      path: operation.path,\n      value: null // note that the value is not actually used, so we just use null instead of getting the actual value from the json\n    },\n    stateValue\n  )\n\n  return updatedState\n}\n\n/**\n * Shift visible sections in an Array with a specified offset\n */\nexport function shiftVisibleSections(\n  visibleSections: VisibleSection[],\n  index: number,\n  offset: number\n): VisibleSection[] {\n  const shiftedSections = visibleSections.map((section) => {\n    return {\n      start: section.start > index ? section.start + offset : section.start,\n      end: section.end > index ? section.end + offset : section.end\n    }\n  })\n\n  return mergeAdjacentSections(shiftedSections)\n}\n\n// merge adjacent sections like [{start:0, end:100}, {start:100, end:200}] into [{start:0, end:200}]\nfunction mergeAdjacentSections(visibleSections: VisibleSection[]): VisibleSection[] {\n  const merged = visibleSections.slice(0)\n\n  let i = 1\n  while (i < merged.length) {\n    if (merged[i - 1].end === merged[i].start) {\n      merged[i - 1] = {\n        start: merged[i - 1].start,\n        end: merged[i].end\n      }\n      merged.splice(i)\n    }\n    i++\n  }\n\n  return merged\n}\n\nexport function getEnforceString(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): boolean {\n  const value = getIn(json, path)\n  const nestedState = getInRecursiveState(json, documentState, path)\n  const enforceString = isValueRecursiveState(nestedState) ? nestedState.enforceString : undefined\n\n  if (typeof enforceString === 'boolean') {\n    return enforceString\n  }\n\n  return isStringContainingPrimitiveValue(value)\n}\n\nexport function getNextKeys(keys: string[], key: string, includeKey = false): string[] {\n  const index = keys.indexOf(key)\n  if (index !== -1) {\n    return includeKey ? keys.slice(index) : keys.slice(index + 1)\n  } else {\n    // a new key, that doesn't have next keys\n    return []\n  }\n}\n\n/**\n * Get all paths which are visible and rendered\n */\n// TODO: create memoized version of getVisiblePaths which remembers just the previous result if json and state are the same\nexport function getVisiblePaths(\n  json: unknown,\n  documentState: DocumentState | undefined\n): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  function _recurse(value: unknown, state: DocumentState | undefined, path: JSONPath) {\n    paths.push(path)\n\n    if (isJSONArray(value) && isArrayRecursiveState(state) && state.expanded) {\n      forEachVisibleIndex(value, state.visibleSections, (index) => {\n        _recurse(value[index], state.items[index], path.concat(String(index)))\n      })\n    }\n\n    if (isJSONObject(value) && isObjectRecursiveState(state) && state.expanded) {\n      Object.keys(value).forEach((key) => {\n        _recurse(value[key], state.properties[key], path.concat(key))\n      })\n    }\n  }\n\n  _recurse(json, documentState, [])\n\n  return paths\n}\n\n/**\n * Get all caret position which are visible and rendered:\n * before a node, at a key, at a value, appending an object/array\n */\n// TODO: create memoized version of getVisibleCaretPositions which remembers just the previous result if json and state are the same\nexport function getVisibleCaretPositions(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  includeInside = true\n): CaretPosition[] {\n  const paths: CaretPosition[] = []\n\n  function _recurse(value: unknown, path: JSONPath) {\n    paths.push({ path, type: CaretType.value })\n\n    const valueState = getInRecursiveState(json, documentState, path)\n    if (value && isExpandableState(valueState) && valueState.expanded) {\n      if (includeInside) {\n        paths.push({ path, type: CaretType.inside })\n      }\n\n      if (isJSONArray(value)) {\n        const visibleSections = isArrayRecursiveState(valueState)\n          ? valueState.visibleSections\n          : DEFAULT_VISIBLE_SECTIONS\n        forEachVisibleIndex(value, visibleSections, (index) => {\n          const itemPath = path.concat(String(index))\n\n          _recurse(value[index], itemPath)\n\n          if (includeInside) {\n            paths.push({ path: itemPath, type: CaretType.after })\n          }\n        })\n      }\n\n      if (isJSONObject(value)) {\n        const keys = Object.keys(value)\n        keys.forEach((key) => {\n          const propertyPath = path.concat(key)\n\n          paths.push({ path: propertyPath, type: CaretType.key })\n\n          _recurse(value[key], propertyPath)\n\n          if (includeInside) {\n            paths.push({ path: propertyPath, type: CaretType.after })\n          }\n        })\n      }\n    }\n  }\n\n  _recurse(json, [])\n\n  return paths\n}\n\n/**\n * Find the previous visible path.\n * This can be the last child of the previous object or array, or the parent of a first entry.\n */\n// TODO: write tests for getPreviousVisiblePath\nexport function getPreviousVisiblePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONPath | undefined {\n  const visiblePaths = getVisiblePaths(json, documentState)\n  const visiblePathPointers = visiblePaths.map(compileJSONPointer)\n  const pathPointer = compileJSONPointer(path)\n  const index = visiblePathPointers.indexOf(pathPointer)\n\n  if (index !== -1 && index > 0) {\n    return visiblePaths[index - 1]\n  }\n\n  return undefined\n}\n\n/**\n * Find the next visible path.\n * This can be the next parent entry.\n */\n// TODO: write tests for getNextVisiblePath\nexport function getNextVisiblePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONPath | undefined {\n  const visiblePaths = getVisiblePaths(json, documentState)\n  const visiblePathPointers = visiblePaths.map(compileJSONPointer)\n  const index = visiblePathPointers.indexOf(compileJSONPointer(path))\n\n  if (index !== -1 && index < visiblePaths.length - 1) {\n    return visiblePaths[index + 1]\n  }\n\n  return undefined\n}\n\n/**\n * Expand recursively when the expanded contents is small enough,\n * else expand in a minimalistic way\n */\nexport function expandSmart(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  maxSize: number = MAX_DOCUMENT_SIZE_EXPAND_ALL\n): DocumentState | undefined {\n  const nestedJson = getIn(json, path)\n  const callback = isLargeContent({ json: nestedJson }, maxSize) ? expandMinimal : expandAll\n\n  return expandPath(json, documentState, path, callback)\n}\n\nexport function expandSmartIfCollapsed(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n) {\n  const nestedState = getInRecursiveState(json, documentState, path)\n  const isExpanded = isExpandableState(nestedState) ? nestedState.expanded : false\n\n  return isExpanded ? documentState : expandSmart(json, documentState, path)\n}\n\n/**\n * Expand the root array or object, and in case of an array, expand the first array item\n */\nexport function expandMinimal(relativePath: JSONPath): boolean {\n  // first item of an array\n  return relativePath.length === 0 ? true : relativePath.length === 1 && relativePath[0] === '0'\n}\n\n/**\n * Expand the root array or object\n */\nexport function expandSelf(relativePath: JSONPath): boolean {\n  return relativePath.length === 0\n}\n\nexport function expandAll(): boolean {\n  return true\n}\n\nexport function expandNone(): boolean {\n  return false\n}\n","import {\n  getIn,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  type JSONPatchDocument,\n  type JSONPatchOperation,\n  type JSONPath,\n  parsePath\n} from 'immutable-json-patch'\nimport { first, initial, isEmpty, isEqual, last } from 'lodash-es'\nimport { isObjectOrArray } from '$lib/utils/typeUtils.js'\nimport {\n  collapsePath,\n  getNextVisiblePath,\n  getPreviousVisiblePath,\n  getVisibleCaretPositions,\n  getVisiblePaths\n} from './documentState.js'\nimport type {\n  AfterSelection,\n  CaretPosition,\n  DocumentState,\n  EditKeySelection,\n  EditValueSelection,\n  InsideSelection,\n  JSONEditorSelection,\n  JSONParser,\n  JSONSelection,\n  KeySelection,\n  MultiSelection,\n  TextSelection,\n  ValueSelection\n} from '../types.js'\nimport { CaretType, SelectionType } from '$lib/types.js'\nimport { int } from '$lib/utils/numberUtils.js'\n\nexport function isAfterSelection(\n  selection: JSONEditorSelection | undefined\n): selection is AfterSelection {\n  return (selection && selection.type === SelectionType.after) || false\n}\n\nexport function isInsideSelection(\n  selection: JSONEditorSelection | undefined\n): selection is InsideSelection {\n  return (selection && selection.type === SelectionType.inside) || false\n}\n\nexport function isKeySelection(\n  selection: JSONEditorSelection | undefined\n): selection is KeySelection {\n  return (selection && selection.type === SelectionType.key) || false\n}\n\nexport function isValueSelection(\n  selection: JSONEditorSelection | undefined\n): selection is ValueSelection {\n  return (selection && selection.type === SelectionType.value) || false\n}\n\nexport function isMultiSelection(\n  selection: JSONEditorSelection | undefined\n): selection is MultiSelection {\n  return (selection && selection.type === SelectionType.multi) || false\n}\n\nexport function isMultiSelectionWithOneItem(\n  selection: JSONEditorSelection | undefined\n): selection is MultiSelection {\n  return isMultiSelection(selection) && isEqual(selection.focusPath, selection.anchorPath)\n}\n\nexport function isJSONSelection(\n  selection: JSONEditorSelection | undefined\n): selection is JSONSelection {\n  return (\n    isMultiSelection(selection) ||\n    isAfterSelection(selection) ||\n    isInsideSelection(selection) ||\n    isKeySelection(selection) ||\n    isValueSelection(selection)\n  )\n}\n\nexport function isTextSelection(\n  selection: JSONEditorSelection | undefined\n): selection is TextSelection {\n  return (selection && selection.type === SelectionType.text) || false\n}\n\n/**\n * Expand a selection start and end into an array containing all paths\n * between (and including) start and end\n */\nexport function getSelectionPaths(json: unknown, selection: JSONSelection): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  iterateOverSelection(json, selection, (path) => {\n    paths.push(path)\n  })\n\n  return paths\n}\n\n/**\n * Expand a selection start and end into an array containing all paths\n * between (and including) start and end.\n *\n * The function iterates always from start to end, independent of the order\n * of focusPath and anchorPath.\n *\n * When the callback returns something other than undefined, the iteration is\n * canceled and the value returned by the callback is returned by iterateOverSelection.\n */\nexport function iterateOverSelection<T>(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  callback: (path: JSONPath) => void | undefined | T\n): void | undefined | T {\n  if (!selection) {\n    return undefined\n  }\n\n  const anchorPath = getAnchorPath(selection)\n  const focusPath = getFocusPath(selection)\n\n  if (isEqual(anchorPath, focusPath)) {\n    // just a single node\n    return callback(anchorPath)\n  } else {\n    // multiple nodes\n    if (json === undefined) {\n      return undefined\n    }\n\n    const sharedPath = findSharedPath(anchorPath, focusPath)\n\n    if (anchorPath.length === sharedPath.length || focusPath.length === sharedPath.length) {\n      // a parent and a child, like ['arr', 1] and ['arr']\n      return callback(sharedPath)\n    }\n\n    const selection = createMultiSelection(anchorPath, focusPath)\n    const startPath = getStartPath(json, selection)\n    const endPath = getEndPath(json, selection)\n\n    const startIndex = getChildIndex(json, selection, startPath)\n    const endIndex = getChildIndex(json, selection, endPath)\n\n    if (startIndex === -1 || endIndex === -1) {\n      return undefined\n    }\n\n    const value = getIn(json, sharedPath)\n\n    if (isJSONObject(value)) {\n      const keys = Object.keys(value)\n\n      for (let i = startIndex; i <= endIndex; i++) {\n        const value = callback(sharedPath.concat(keys[i]))\n        if (value !== undefined) {\n          return value\n        }\n      }\n\n      return undefined\n    }\n\n    if (isJSONArray(value)) {\n      for (let i = startIndex; i <= endIndex; i++) {\n        const value = callback(sharedPath.concat(String(i)))\n        if (value !== undefined) {\n          return value\n        }\n      }\n\n      return undefined\n    }\n  }\n\n  throw new Error('Failed to create selection')\n}\n\nexport function getParentPath(selection: JSONSelection): JSONPath {\n  if (isInsideSelection(selection)) {\n    return selection.path\n  } else {\n    return initial(getFocusPath(selection))\n  }\n}\n\nexport function getStartPath(json: unknown, selection: JSONSelection): JSONPath {\n  if (!isMultiSelection(selection)) {\n    return selection.path\n  }\n\n  const anchorIndex = getChildIndex(json, selection, selection.anchorPath)\n  const focusIndex = getChildIndex(json, selection, selection.focusPath)\n\n  return focusIndex < anchorIndex ? selection.focusPath : selection.anchorPath\n}\n\nexport function getEndPath(json: unknown, selection: JSONSelection): JSONPath {\n  if (!isMultiSelection(selection)) {\n    return selection.path\n  }\n\n  const anchorIndex = getChildIndex(json, selection, selection.anchorPath)\n  const focusIndex = getChildIndex(json, selection, selection.focusPath)\n\n  return focusIndex > anchorIndex ? selection.focusPath : selection.anchorPath\n}\n\n// TODO: write unit test\nexport function isSelectionInsidePath(selection: JSONSelection, path: JSONPath): boolean {\n  return (\n    pathStartsWith(getFocusPath(selection), path) &&\n    (getFocusPath(selection).length > path.length || isInsideSelection(selection))\n  )\n}\n\nexport function getSelectionUp(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const focusPath = keepAnchorPath ? getFocusPath(selection) : getStartPath(json, selection)\n  const previousPath = getPreviousVisiblePath(json, documentState, focusPath)\n\n  if (keepAnchorPath) {\n    // create a multi-selection with multiple nodes\n    if (isInsideSelection(selection) || isAfterSelection(selection)) {\n      return previousPath !== undefined ? createMultiSelection(focusPath, focusPath) : undefined\n    }\n\n    return previousPath !== undefined\n      ? createMultiSelection(getAnchorPath(selection), previousPath)\n      : undefined\n  }\n\n  if (isAfterSelection(selection)) {\n    // select the node itself, not the previous node,\n    // FIXME: when after an expanded object/array, should go to the last item inside the object/array\n    return createValueSelection(focusPath)\n  }\n\n  if (isInsideSelection(selection)) {\n    // select the node itself, not the previous node,\n    return createValueSelection(focusPath)\n  }\n\n  if (isKeySelection(selection)) {\n    if (previousPath === undefined || previousPath.length === 0) {\n      return undefined\n    }\n\n    const parentPath = initial(previousPath)\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent) || isEmpty(previousPath)) {\n      // switch to value selection: array has no keys, and root object also not\n      return createValueSelection(previousPath)\n    } else {\n      return createKeySelection(previousPath)\n    }\n  }\n\n  if (isValueSelection(selection)) {\n    return previousPath !== undefined ? createValueSelection(previousPath) : undefined\n  }\n\n  if (previousPath !== undefined) {\n    return createValueSelection(previousPath)\n  }\n\n  return undefined\n}\n\nexport function getSelectionDown(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n  const focusPath = keepAnchorPath ? getFocusPath(selection) : getEndPath(json, selection)\n\n  // if the focusPath is an Array or object, we must not step into it but\n  // over it, we pass state with this array/object collapsed\n  const collapsedState = isObjectOrArray(getIn(json, focusPath))\n    ? collapsePath(json, documentState, focusPath, true)\n    : documentState\n\n  const nextPath = getNextVisiblePath(json, documentState, focusPath)\n  const nextPathAfter = getNextVisiblePath(json, collapsedState, focusPath)\n\n  if (keepAnchorPath) {\n    // create a multi-selection with multiple nodes\n    if (isInsideSelection(selection)) {\n      return nextPath !== undefined ? createMultiSelection(nextPath, nextPath) : undefined\n    }\n\n    if (isAfterSelection(selection)) {\n      return nextPathAfter !== undefined\n        ? createMultiSelection(nextPathAfter, nextPathAfter)\n        : undefined\n    }\n\n    return nextPathAfter !== undefined\n      ? createMultiSelection(getAnchorPath(selection), nextPathAfter)\n      : undefined\n  }\n\n  if (isAfterSelection(selection)) {\n    return nextPathAfter !== undefined ? createValueSelection(nextPathAfter) : undefined\n  }\n\n  if (isInsideSelection(selection)) {\n    return nextPath !== undefined ? createValueSelection(nextPath) : undefined\n  }\n\n  if (isValueSelection(selection)) {\n    return nextPath !== undefined ? createValueSelection(nextPath) : undefined\n  }\n\n  if (isKeySelection(selection)) {\n    if (nextPath === undefined || nextPath.length === 0) {\n      return undefined\n    }\n\n    const parentPath = initial(nextPath) // not nextPathAfter!\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent)) {\n      // switch to value selection: array has no keys\n      return createValueSelection(nextPath)\n    } else {\n      return createKeySelection(nextPath)\n    }\n  }\n\n  if (isMultiSelection(selection)) {\n    return nextPathAfter !== undefined\n      ? createValueSelection(nextPathAfter)\n      : nextPath !== undefined\n        ? createValueSelection(nextPath)\n        : undefined\n  }\n\n  return undefined\n}\n\n/**\n * Get the next selection for a value inside the current object/array\n * If there is no next value, select AFTER.\n * Only applicable for ValueSelection\n */\nexport function getSelectionNextInside(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONSelection | undefined {\n  // TODO: write unit tests for getSelectionNextInside\n  const parentPath = initial(path)\n  const childPath = [last(path) as string]\n\n  const parent: unknown | undefined = getIn(json, parentPath)\n  const nextPathInside = parent ? getNextVisiblePath(parent, documentState, childPath) : undefined\n\n  if (nextPathInside) {\n    return createValueSelection(parentPath.concat(nextPathInside))\n  } else {\n    return createAfterSelection(path)\n  }\n}\n\n/**\n * Find the caret position and its siblings for a given selection\n */\n// TODO: unit test\nexport function findCaretAndSiblings(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  includeInside: boolean\n): {\n  next: CaretPosition | undefined\n  caret: CaretPosition | undefined\n  previous: CaretPosition | undefined\n} {\n  if (!selection) {\n    return { caret: undefined, previous: undefined, next: undefined }\n  }\n  const visibleCaretPositions = getVisibleCaretPositions(json, documentState, includeInside)\n\n  const index = visibleCaretPositions.findIndex((caret) => {\n    return (\n      isEqual(caret.path, getFocusPath(selection)) && String(caret.type) === String(selection.type)\n    )\n  })\n\n  return {\n    caret: index !== -1 ? visibleCaretPositions[index] : undefined,\n\n    previous: index !== -1 && index > 0 ? visibleCaretPositions[index - 1] : undefined,\n\n    next:\n      index !== -1 && index < visibleCaretPositions.length - 1\n        ? visibleCaretPositions[index + 1]\n        : undefined\n  }\n}\n\nexport function getSelectionLeft(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false,\n  includeInside = true\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const { caret, previous } = findCaretAndSiblings(json, documentState, selection, includeInside)\n\n  if (keepAnchorPath) {\n    if (!isMultiSelection(selection)) {\n      return createMultiSelection(selection.path, selection.path)\n    }\n\n    return undefined\n  }\n\n  if (caret && previous) {\n    return fromCaretPosition(previous)\n  }\n\n  const parentPath = initial(getFocusPath(selection))\n  const parent = getIn(json, parentPath)\n\n  if (isValueSelection(selection) && Array.isArray(parent)) {\n    return createMultiSelection(selection.path, selection.path)\n  }\n\n  if (isMultiSelection(selection) && !Array.isArray(parent)) {\n    return createKeySelection(selection.focusPath)\n  }\n\n  return undefined\n}\n\nexport function getSelectionRight(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false,\n  includeInside = true\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const { caret, next } = findCaretAndSiblings(json, documentState, selection, includeInside)\n\n  if (keepAnchorPath) {\n    if (!isMultiSelection(selection)) {\n      return createMultiSelection(selection.path, selection.path)\n    }\n\n    return undefined\n  }\n\n  if (caret && next) {\n    return fromCaretPosition(next)\n  }\n\n  if (isMultiSelection(selection)) {\n    return createValueSelection(selection.focusPath)\n  }\n\n  return undefined\n}\n\n/**\n * Get a proper initial selection based on what is visible\n */\nexport function getInitialSelection(\n  json: unknown,\n  documentState: DocumentState | undefined\n): JSONSelection {\n  const visiblePaths = getVisiblePaths(json, documentState)\n\n  // find the first, deepest nested entry (normally a value, not an Object/Array)\n  let index = 0\n  while (\n    index < visiblePaths.length - 1 &&\n    visiblePaths[index + 1].length > visiblePaths[index].length\n  ) {\n    index++\n  }\n\n  const path = visiblePaths[index]\n  return path === undefined || path.length === 0 || Array.isArray(getIn(json, initial(path)))\n    ? createValueSelection(path) // Array items and root object/array do not have a key, so select value in that case\n    : createKeySelection(path)\n}\n\nexport function createSelectionFromOperations(\n  json: unknown,\n  operations: JSONPatchDocument\n): JSONSelection | undefined {\n  if (operations.length === 1) {\n    const operation = first(operations) as JSONPatchOperation\n    if (operation.op === 'replace') {\n      // a replaced value\n      const path = parsePath(json, operation.path)\n\n      return createValueSelection(path)\n    }\n  }\n\n  if (!isEmpty(operations) && operations.every((operation) => operation.op === 'move')) {\n    const firstOp = first(operations)\n    const otherOps = operations.slice(1)\n\n    if (\n      (isJSONPatchCopy(firstOp) || isJSONPatchMove(firstOp)) &&\n      firstOp.from !== firstOp.path &&\n      otherOps.every((op) => (isJSONPatchCopy(op) || isJSONPatchMove(op)) && op.from === op.path)\n    ) {\n      // a renamed key\n      const path = parsePath(json, firstOp.path)\n\n      return createKeySelection(path)\n    }\n  }\n\n  const paths = operations\n    .filter((operation) => {\n      return (\n        operation.op !== 'test' &&\n        operation.op !== 'remove' &&\n        (operation.op !== 'move' || operation.from !== operation.path) &&\n        typeof operation.path === 'string'\n      )\n    })\n    .map((operation) => parsePath(json, operation.path))\n\n  if (isEmpty(paths)) {\n    return undefined\n  }\n\n  // TODO: make this function robust against operations which do not have consecutive paths or have wrongly ordered paths\n\n  return {\n    type: SelectionType.multi,\n    anchorPath: first(paths) as JSONPath,\n    focusPath: last(paths) as JSONPath\n  }\n}\n\n/**\n * Find the common path of two paths.\n * For example findCommonRoot(['arr', '1', 'name'], ['arr', '1', 'address', 'contact']) returns ['arr', '1']\n */\n// TODO: write unit tests for findSharedPath\nexport function findSharedPath(path1: JSONPath, path2: JSONPath): JSONPath {\n  let i = 0\n  while (i < path1.length && i < path2.length && path1[i] === path2[i]) {\n    i++\n  }\n\n  return path1.slice(0, i)\n}\n\nexport function singleItemSelected(selection: JSONSelection | undefined): boolean {\n  return (\n    isKeySelection(selection) ||\n    isValueSelection(selection) ||\n    isMultiSelectionWithOneItem(selection)\n  )\n}\n\nexport function findRootPath(json: unknown, selection: JSONSelection): JSONPath {\n  return singleItemSelected(selection) && isObjectOrArray(getIn(json, getFocusPath(selection)))\n    ? getFocusPath(selection)\n    : initial(getFocusPath(selection)) // the parent path of the paths\n}\n\nexport function pathStartsWith(path: JSONPath, parentPath: JSONPath): boolean {\n  if (path.length < parentPath.length) {\n    return false\n  }\n\n  for (let i = 0; i < parentPath.length; i++) {\n    if (path[i] !== parentPath[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// TODO: write unit tests\nexport function removeEditModeFromSelection(\n  selection: JSONSelection | undefined\n): JSONSelection | undefined {\n  if (isEditingSelection(selection)) {\n    const { type, path } = selection\n    return { type, path } as KeySelection | ValueSelection\n  }\n\n  return selection\n}\n\nexport function createKeySelection(path: JSONPath): KeySelection {\n  return { type: SelectionType.key, path }\n}\n\nexport function createEditKeySelection(path: JSONPath, initialValue?: string): EditKeySelection {\n  return { type: SelectionType.key, path, edit: true, initialValue }\n}\n\nexport function createValueSelection(path: JSONPath): ValueSelection {\n  return { type: SelectionType.value, path }\n}\n\nexport function createEditValueSelection(\n  path: JSONPath,\n  initialValue?: string\n): EditValueSelection {\n  return { type: SelectionType.value, path, edit: true, initialValue }\n}\n\nexport function createInsideSelection(path: JSONPath): InsideSelection {\n  return {\n    type: SelectionType.inside,\n    path\n  }\n}\n\nexport function createAfterSelection(path: JSONPath): AfterSelection {\n  return {\n    type: SelectionType.after,\n    path\n  }\n}\n\nexport function createMultiSelection(anchorPath: JSONPath, focusPath: JSONPath): MultiSelection {\n  // normalize the paths to both be a child of a shared parent\n  const sharedPath = findSharedPath(anchorPath, focusPath)\n  const isParent = anchorPath.length > sharedPath.length && focusPath.length > sharedPath.length\n\n  return {\n    type: SelectionType.multi,\n    anchorPath: isParent ? sharedPath.concat(anchorPath[sharedPath.length]) : sharedPath,\n    focusPath: isParent ? sharedPath.concat(focusPath[sharedPath.length]) : sharedPath\n  }\n}\n\n/**\n * Turn selected contents into plain text partial JSON, usable for copying to\n * clipboard for example.\n */\nexport function selectionToPartialJson(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  indentation: number | string | undefined,\n  parser: JSONParser\n): string | undefined {\n  if (isKeySelection(selection)) {\n    return String(last(selection.path))\n  }\n\n  if (isValueSelection(selection)) {\n    const value = getIn(json, selection.path)\n    return typeof value === 'string' ? value : parser.stringify(value, null, indentation) // TODO: customizable indentation?\n  }\n\n  if (isMultiSelection(selection)) {\n    if (isEmpty(selection.focusPath)) {\n      // root object -> does not have a parent key/index\n      return parser.stringify(json, null, indentation)\n    }\n\n    const parentPath = getParentPath(selection)\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent)) {\n      if (isMultiSelectionWithOneItem(selection)) {\n        // do not suffix a single selected array item with a comma\n        const item = getIn(json, selection.focusPath)\n        return parser.stringify(item, null, indentation)\n      } else {\n        return getSelectionPaths(json, selection)\n          .map((path) => {\n            const item = getIn(json, path)\n            return `${parser.stringify(item, null, indentation)},`\n          })\n          .join('\\n')\n      }\n    } else {\n      // parent is Object\n      return getSelectionPaths(json, selection)\n        .map((path) => {\n          const key = last(path)\n          const value = getIn(json, path)\n          return `${parser.stringify(key)}: ${parser.stringify(value, null, indentation)},`\n        })\n        .join('\\n')\n    }\n  }\n\n  return undefined\n}\n\nexport function isEditingSelection(\n  selection: JSONSelection | undefined\n): selection is EditKeySelection | EditValueSelection {\n  return (\n    (isKeySelection(selection) || isValueSelection(selection)) &&\n    (selection as Record<string, unknown>).edit === true\n  )\n}\n\n/**\n * Create a selection which selects the root of the document\n */\n// TODO: write unit tests\nexport function selectAll(): JSONSelection {\n  return createValueSelection([])\n}\n\n// TODO: write unit tests\nexport function hasSelectionContents(selection: JSONSelection | undefined): boolean {\n  return isKeySelection(selection) || isValueSelection(selection) || isMultiSelection(selection)\n}\n\n/**\n * Test whether the current selection can be converted.\n * That is the case when the selection is a key/value, or a multi selection with only one path\n */\nexport function canConvert(selection: JSONSelection | undefined): boolean {\n  return (\n    isKeySelection(selection) ||\n    isValueSelection(selection) ||\n    isMultiSelectionWithOneItem(selection)\n  )\n}\n\n// TODO: unit test\n// eslint-disable-next-line consistent-return\nexport function fromCaretPosition(caretPosition: CaretPosition): JSONSelection {\n  switch (caretPosition.type) {\n    case CaretType.key:\n      return createKeySelection(caretPosition.path)\n    case CaretType.value:\n      return createValueSelection(caretPosition.path)\n    case CaretType.after:\n      return createAfterSelection(caretPosition.path)\n    case CaretType.inside:\n      return createInsideSelection(caretPosition.path)\n  }\n}\n\n// TODO: unit test\n// eslint-disable-next-line consistent-return\nexport function fromSelectionType(selectionType: SelectionType, path: JSONPath): JSONSelection {\n  switch (selectionType) {\n    case SelectionType.key:\n      return createKeySelection(path)\n    case SelectionType.value:\n      return createValueSelection(path)\n    case SelectionType.after:\n      return createAfterSelection(path)\n    case SelectionType.inside:\n      return createInsideSelection(path)\n    case SelectionType.multi:\n    case SelectionType.text: // type `text` is not applicable, but we need to handle all types\n      return createMultiSelection(path, path)\n  }\n}\n\nexport function selectionIfOverlapping(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  path: JSONPath\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  if (pathInSelection(json, selection, path)) {\n    return selection\n  }\n\n  const sharedPath = isMultiSelection(selection) ? initial(selection.focusPath) : selection.path\n  if (pathStartsWith(sharedPath, path)) {\n    return selection\n  }\n\n  return undefined\n}\n\nexport function pathInSelection(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  path: JSONPath\n): boolean {\n  if (json === undefined || !selection) {\n    return false\n  }\n\n  if (isKeySelection(selection) || isInsideSelection(selection) || isAfterSelection(selection)) {\n    return isEqual(selection.path, path)\n  }\n\n  if (isValueSelection(selection)) {\n    return pathStartsWith(path, selection.path)\n  }\n\n  if (isMultiSelection(selection)) {\n    const startPath = getStartPath(json, selection)\n    const endPath = getEndPath(json, selection)\n    const parentPath = initial(selection.focusPath)\n\n    if (!pathStartsWith(path, parentPath) || path.length <= parentPath.length) {\n      return false\n    }\n\n    const startIndex = getChildIndex(json, selection, startPath)\n    const endIndex = getChildIndex(json, selection, endPath)\n    const pathIndex = getChildIndex(json, selection, path)\n    return pathIndex !== -1 && pathIndex >= startIndex && pathIndex <= endIndex\n  }\n\n  return false\n}\n\nfunction getChildIndex(json: unknown, selection: MultiSelection, path: JSONPath): number {\n  const parentPath = initial(selection.focusPath)\n  if (!pathStartsWith(path, parentPath) || path.length <= parentPath.length) {\n    return -1\n  }\n\n  const key = path[parentPath.length]\n  const parent = getIn(json, parentPath)\n\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    return keys.indexOf(key)\n  }\n\n  if (isJSONArray(parent)) {\n    const index = int(key)\n    if (index < parent.length) {\n      return index\n    }\n  }\n\n  return -1\n}\n\n// TODO: write some unit tests\nexport function getFocusPath(selection: JSONSelection): JSONPath {\n  return isMultiSelection(selection) ? selection.focusPath : selection.path\n}\n\n// TODO: write some unit tests\nexport function getAnchorPath(selection: JSONSelection): JSONPath {\n  return isMultiSelection(selection) ? selection.anchorPath : selection.path\n}\n","/**\n * A simplified version of https://github.com/JedWatson/classnames\n *\n * Example usage:\n *\n *     classnames('primary-button', { selected: true }, 'left')\n *\n */\nexport function classnames(...args: Array<string | Record<string, boolean> | undefined>): string {\n  const classes = []\n\n  for (const arg of args) {\n    if (typeof arg === 'string') {\n      classes.push(arg)\n    }\n\n    if (arg && typeof arg === 'object') {\n      for (const key in arg) {\n        if (Object.hasOwnProperty.call(arg, key) && arg[key]) {\n          classes.push(key)\n        }\n      }\n    }\n  }\n\n  return classes.join(' ')\n}\n","import { isUrl, valueType } from '$lib/utils/typeUtils.js'\nimport { type JSONParser, Mode } from '$lib/types.js'\nimport { classnames } from '$lib/utils/cssUtils.js'\n\nexport function getValueClass(value: unknown, mode: Mode, parser: JSONParser): string {\n  const type = valueType(value, parser)\n\n  return classnames('jse-value', 'jse-' + type, {\n    'jse-url': isUrl(value),\n    'jse-empty': typeof value === 'string' && value.length === 0,\n    'jse-table-cell': mode === Mode.table\n  })\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onDestroy, onMount } from 'svelte'\n  import { addNewLineSuffix, removeNewLineSuffix, setCursorToEnd } from '$lib/utils/domUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { noop } from 'lodash-es'\n  import type { OnFind, OnPaste } from '$lib/types'\n  import { UpdateSelectionAfterChange } from '$lib/types'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  const debug = createDebug('jsoneditor:EditableDiv')\n\n  export let value: string\n  export let initialValue: string | undefined\n  export let shortText = false\n  export let label: string\n  export let onChange: (newValue: string, updateSelection: UpdateSelectionAfterChange) => void\n  export let onCancel: () => void\n  export let onFind: OnFind\n  export let onPaste: OnPaste = noop\n  export let onValueClass: (value: string) => string = () => ''\n\n  let domValue: HTMLDivElement | undefined\n  let valueClass: string\n  $: valueClass = onValueClass(value)\n  let closed = false\n\n  onMount(() => {\n    debug('onMount', { value, initialValue })\n    setDomValue(initialValue !== undefined ? initialValue : value)\n\n    // focus\n    if (domValue) {\n      setCursorToEnd(domValue)\n    }\n  })\n\n  onDestroy(() => {\n    const newValue = getDomValue()\n\n    debug('onDestroy', { closed, value, newValue })\n\n    if (!closed && newValue !== value) {\n      onChange(newValue, UpdateSelectionAfterChange.no)\n    }\n  })\n\n  function getDomValue(): string {\n    if (!domValue) {\n      return ''\n    }\n    return removeNewLineSuffix(domValue.innerText)\n  }\n\n  function setDomValue(updatedValue: string) {\n    if (!domValue) {\n      return\n    }\n    domValue.innerText = addNewLineSuffix(updatedValue)\n  }\n\n  function handleValueInput() {\n    const newValue = getDomValue()\n\n    if (newValue === '') {\n      // immediately update to clean up any left over <br/>\n      setDomValue('')\n    }\n\n    // update class\n    valueClass = onValueClass(newValue)\n  }\n\n  function handleCancel() {\n    // cancel changes (needed to prevent triggering a change onDestroy)\n    closed = true\n\n    onCancel()\n  }\n\n  function handleValueKeyDown(event: KeyboardEvent) {\n    event.stopPropagation()\n\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Escape') {\n      event.preventDefault()\n\n      handleCancel()\n    }\n\n    if (combo === 'Enter' || combo === 'Tab') {\n      // apply changes\n      event.preventDefault()\n\n      closed = true\n\n      const newValue = getDomValue()\n      onChange(newValue, UpdateSelectionAfterChange.nextInside)\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      onFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      onFind(true)\n    }\n  }\n\n  function handleValuePaste(event: ClipboardEvent) {\n    event.stopPropagation()\n\n    if (!onPaste || !event.clipboardData) {\n      return\n    }\n\n    const clipboardText = event.clipboardData.getData('text/plain')\n    onPaste(clipboardText)\n  }\n\n  function handleBlur() {\n    const hasFocus = document.hasFocus()\n    const newValue = getDomValue()\n\n    debug('handleBlur', { hasFocus, closed, value, newValue })\n\n    // we only want to close the editable div when the focus did go to another\n    // element on the same page, but not when the user switches to another\n    // application or browser tab to copy/paste something whilst still editing\n    // the value, hence the check for document.hasFocus()\n    if (document.hasFocus() && !closed) {\n      closed = true\n      if (newValue !== value) {\n        onChange(newValue, UpdateSelectionAfterChange.self)\n      } else {\n        // Note that we do not fire an onCancel here: a blur action\n        // is caused by the user clicking somewhere else. If we apply\n        // onCancel now, we would override the selection that the user\n        // wants by clicking somewhere else in the editor (since `blur`\n        // is occurring *after* `mousedown`).\n      }\n    }\n  }\n</script>\n\n<div\n  role=\"textbox\"\n  aria-label={label}\n  tabindex=\"0\"\n  class={classnames('jse-editable-div', valueClass, { 'jse-short-text': shortText })}\n  contenteditable=\"true\"\n  spellcheck=\"false\"\n  on:input={handleValueInput}\n  on:keydown={handleValueKeyDown}\n  on:paste={handleValuePaste}\n  on:blur={handleBlur}\n  bind:this={domValue}\n></div>\n\n<style src=\"./EditableDiv.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { isObjectOrArray, stringConvert } from '$lib/utils/typeUtils.js'\n  import { createValueSelection, getFocusPath, isEditingSelection } from '$lib/logic/selection.js'\n  import { getValueClass } from '$lib/plugins/value/components/utils/getValueClass.js'\n  import EditableDiv from '../../../components/controls/EditableDiv.svelte'\n  import {\n    type FindNextInside,\n    type JSONParser,\n    type JSONSelection,\n    Mode,\n    type OnFind,\n    type OnJSONSelect,\n    type OnPasteJson,\n    type OnPatch,\n    UpdateSelectionAfterChange,\n    type ValueNormalization\n  } from '$lib/types.js'\n  import { isEqual } from 'lodash-es'\n  import { expandSmart } from '$lib/logic/documentState'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let selection: JSONSelection | undefined\n  export let mode: Mode\n  export let parser: JSONParser\n  export let normalization: ValueNormalization\n  export let enforceString: boolean\n  export let onPatch: OnPatch\n  export let onPasteJson: OnPasteJson\n  export let onSelect: OnJSONSelect\n  export let onFind: OnFind\n  export let focus: () => void\n  export let findNextInside: FindNextInside\n\n  function convert(value: string): unknown {\n    return enforceString ? value : stringConvert(value, parser)\n  }\n\n  function handleChangeValue(newValue: string, updateSelection: UpdateSelectionAfterChange) {\n    onPatch(\n      [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: convert(normalization.unescapeValue(newValue))\n        }\n      ],\n      (_, patchedState, patchedSelection) => {\n        // Leave the selection as is when it is no longer the path that we were editing here\n        // This happens for example when the user clicks or double-clicks on another value\n        // whilst editing a value\n        if (patchedSelection && !isEqual(path, getFocusPath(patchedSelection))) {\n          return undefined\n        }\n\n        const selection =\n          updateSelection === UpdateSelectionAfterChange.nextInside\n            ? findNextInside(path)\n            : createValueSelection(path)\n\n        return {\n          state: patchedState,\n          selection\n        }\n      }\n    )\n\n    focus()\n  }\n\n  function handleCancelChange() {\n    onSelect(createValueSelection(path))\n    focus()\n  }\n\n  function handlePaste(pastedText: string): void {\n    try {\n      const pastedJson = parser.parse(pastedText)\n      if (isObjectOrArray(pastedJson)) {\n        onPasteJson({\n          path,\n          contents: pastedJson,\n          onPasteAsJson: () => {\n            // exit edit mode\n            handleCancelChange()\n\n            // replace the value with the JSON object/array\n            const operations: JSONPatchDocument = [\n              {\n                op: 'replace',\n                path: compileJSONPointer(path),\n                value: pastedJson\n              }\n            ]\n\n            onPatch(operations, (patchedJson, patchedState) => ({\n              state: expandSmart(patchedJson, patchedState, path)\n            }))\n          }\n        })\n      }\n    } catch {\n      // silently ignore: thee pasted text is no valid JSON object or array,\n      // no need to do anything\n    }\n  }\n\n  function handleOnValueClass(value: string): string {\n    return getValueClass(convert(normalization.unescapeValue(value)), mode, parser)\n  }\n</script>\n\n<EditableDiv\n  value={normalization.escapeValue(value)}\n  initialValue={isEditingSelection(selection) ? selection.initialValue : undefined}\n  label=\"Edit value\"\n  onChange={handleChangeValue}\n  onCancel={handleCancelChange}\n  onPaste={handlePaste}\n  {onFind}\n  onValueClass={handleOnValueClass}\n/>\n","import { cloneDeepWith, first, initial, isEmpty, last, times } from 'lodash-es'\nimport {\n  compileJSONPointer,\n  existsIn,\n  getIn,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchMove,\n  isJSONPatchRemove,\n  isJSONPatchReplace,\n  type JSONPatchAdd,\n  type JSONPatchCopy,\n  type JSONPatchDocument,\n  type JSONPatchOperation,\n  type JSONPath,\n  parseJSONPointer,\n  revertJSONPatch\n} from 'immutable-json-patch'\nimport { parseAndRepair, parseAndRepairOrUndefined, parsePartialJson } from '../utils/jsonUtils.js'\nimport { findUniqueName } from '../utils/stringUtils.js'\nimport { isObject, isObjectOrArray } from '../utils/typeUtils.js'\nimport { getNextKeys } from './documentState.js'\nimport {\n  createAfterSelection,\n  createInsideSelection,\n  createSelectionFromOperations,\n  createValueSelection,\n  getEndPath,\n  getFocusPath,\n  getParentPath,\n  getSelectionPaths,\n  getStartPath,\n  isAfterSelection,\n  isInsideSelection,\n  isKeySelection,\n  isMultiSelection,\n  isValueSelection,\n  pathStartsWith\n} from './selection.js'\nimport type { ClipboardValues, DragInsideAction, JSONParser, JSONSelection } from '$lib/types'\nimport { int } from '../utils/numberUtils.js'\nimport { dedupeKeepLast } from '$lib/utils/arrayUtils'\n\n/**\n * Create a JSONPatch for an insert operation.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\n// TODO: write tests\nexport function insertBefore(\n  json: unknown,\n  path: JSONPath,\n  values: ClipboardValues\n): JSONPatchDocument {\n  const parentPath = initial(path)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    // the path is parsed from a JSONPatch operation,\n    // so array indices are a string which we have to parse into a number\n    const offset = int(last(path) as string)\n    return values.map((entry, index) => ({\n      op: 'add',\n      path: compileJSONPointer(parentPath.concat(String(offset + index))),\n      value: entry.value\n    }))\n  } else if (isJSONObject(parent)) {\n    // 'object'\n    const afterKey = last(path)\n    const keys = Object.keys(parent)\n    const nextKeys = afterKey !== undefined ? getNextKeys(keys, afterKey, true) : []\n\n    return [\n      // insert new values\n      ...values.map((entry) => {\n        const newProp = findUniqueName(entry.key, keys)\n        return {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(newProp)),\n          value: entry.value\n        } as JSONPatchAdd\n      }),\n\n      // move all lower down keys so the inserted key will maintain its position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create insert operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for an append operation. The values will be appended\n * to the end of the array or object.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\nexport function append(json: unknown, path: JSONPath, values: ClipboardValues): JSONPatchDocument {\n  const parent = getIn(json, path)\n\n  if (Array.isArray(parent)) {\n    const offset = parent.length\n    return values.map((entry, index) => ({\n      op: 'add',\n      path: compileJSONPointer(path.concat(String(offset + index))),\n      value: entry.value\n    }))\n  } else {\n    // 'object'\n    return values.map((entry) => {\n      const newProp = findUniqueName(entry.key, Object.keys(parent as Record<string, unknown>))\n      return {\n        op: 'add',\n        path: compileJSONPointer(path.concat(newProp)),\n        value: entry.value\n      }\n    })\n  }\n}\n\n/**\n * Rename an object key\n * Not applicable to arrays\n */\nexport function rename(\n  parentPath: JSONPath,\n  keys: string[],\n  oldKey: string,\n  newKey: string\n): JSONPatchDocument {\n  const filteredKeys = keys.filter((key) => key !== oldKey)\n  const newKeyUnique = findUniqueName(newKey, filteredKeys)\n  const nextKeys = getNextKeys(keys, oldKey, false)\n\n  return [\n    // rename a key\n    {\n      op: 'move',\n      from: compileJSONPointer(parentPath.concat(oldKey)),\n      path: compileJSONPointer(parentPath.concat(newKeyUnique))\n    },\n\n    // move all lower down keys so the renamed key will maintain it's position\n    ...nextKeys.map((key) => moveDown(parentPath, key))\n  ]\n}\n\n/**\n * Create a JSONPatch for an insert operation.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\nexport function replace(\n  json: unknown,\n  paths: JSONPath[],\n  values: ClipboardValues\n): JSONPatchDocument {\n  const firstPath = first(paths)\n  const parentPath = initial(firstPath)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    const firstPath = first(paths)\n    const offset = firstPath ? int(last(firstPath) as string) : 0\n\n    return [\n      // remove operations\n      ...removeAll(paths),\n\n      // insert operations\n      ...values.map((entry, index) => {\n        const operation: JSONPatchOperation = {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(String(index + offset))),\n          value: entry.value\n        }\n\n        return operation\n      })\n    ]\n  } else if (isJSONObject(parent)) {\n    // parent is Object\n    // if we're going to replace an existing object with key \"a\" with a new\n    // key \"a\", we must not create a new unique name \"a (copy)\".\n    const lastPath = last(paths)\n    const parentPath = initial(lastPath)\n    const beforeKey = last(lastPath)\n    const keys: string[] = Object.keys(parent)\n    const nextKeys = beforeKey !== undefined ? getNextKeys(keys, beforeKey, false) : []\n    const removeKeys = new Set(paths.map((path) => last(path)))\n    const filteredKeys = keys.filter((key) => !removeKeys.has(key))\n\n    return [\n      // remove operations\n      ...removeAll(paths),\n\n      // insert operations\n      ...values.map((entry) => {\n        const newProp = findUniqueName(entry.key, filteredKeys)\n        return {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(newProp)),\n          value: entry.value\n        } as JSONPatchAdd\n      }),\n\n      // move down operations\n      // move all lower down keys so the renamed key will maintain its position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create replace operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for a duplicate action.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the duplicated node in case of duplicating\n * and object property\n */\nexport function duplicate(json: unknown, paths: JSONPath[]): JSONPatchDocument {\n  // FIXME: here we assume paths is sorted correctly, that's a dangerous assumption\n  const lastPath = last(paths)\n\n  if (isEmpty(lastPath)) {\n    throw new Error('Cannot duplicate root object')\n  }\n\n  const parentPath = initial(lastPath)\n  const beforeKey = last(lastPath)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    const lastPath = last(paths)\n    const offset = lastPath ? int(last(lastPath) as string) + 1 : 0\n\n    return [\n      // copy operations\n      ...paths.map((path, index) => {\n        const operation: JSONPatchOperation = {\n          op: 'copy',\n          from: compileJSONPointer(path),\n          path: compileJSONPointer(parentPath.concat(String(index + offset)))\n        }\n\n        return operation\n      })\n    ]\n  } else if (isJSONObject(parent)) {\n    // 'object'\n    const keys = Object.keys(parent)\n    const nextKeys = beforeKey !== undefined ? getNextKeys(keys, beforeKey, false) : []\n\n    return [\n      // copy operations\n      ...paths.map((path) => {\n        const prop = last(path) as string\n        const newProp = findUniqueName(prop, keys)\n\n        return {\n          op: 'copy',\n          from: compileJSONPointer(path),\n          path: compileJSONPointer(parentPath.concat(newProp))\n        } as JSONPatchCopy\n      }),\n\n      // move down operations\n      // move all lower down keys so the renamed key will maintain it's position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create duplicate operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for an extract action.\n */\n// TODO: write unit tests\nexport function extract(json: unknown, selection: JSONSelection): JSONPatchDocument {\n  if (isValueSelection(selection)) {\n    return [\n      {\n        op: 'move',\n        from: compileJSONPointer(selection.path),\n        path: ''\n      }\n    ]\n  }\n\n  if (isMultiSelection(selection)) {\n    const parentPath = initial(selection.focusPath)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const value = getSelectionPaths(json, selection).map((path) => {\n        const index = int(last(path) as string)\n        return parent[index]\n      })\n\n      return [\n        {\n          op: 'replace',\n          path: '',\n          value\n        }\n      ]\n    } else if (isJSONObject(parent)) {\n      // object\n      const value: Record<string, unknown> = {}\n      getSelectionPaths(json, selection).forEach((path) => {\n        const key = String(last(path))\n        value[key] = parent[key]\n      })\n\n      return [\n        {\n          op: 'replace',\n          path: '',\n          value\n        }\n      ]\n    }\n  } else {\n    throw new Error('Cannot create extract operations: parent must be an Object or Array')\n  }\n\n  // this should never happen\n  throw new Error('Cannot extract: unsupported type of selection ' + JSON.stringify(selection))\n}\n\n// TODO: write unit tests\nexport function insert(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  clipboardText: string,\n  parser: JSONParser\n): JSONPatchDocument {\n  if (isKeySelection(selection)) {\n    // rename key\n    const clipboard = parseAndRepairOrUndefined(clipboardText, parser)\n    const parentPath = initial(selection.path)\n    const parent = getIn(json, parentPath)\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const oldKey = last(selection.path) as string\n    const newKey = typeof clipboard === 'string' ? clipboard : clipboardText\n\n    return rename(parentPath, keys, oldKey, newKey)\n  }\n\n  if (\n    isValueSelection(selection) ||\n    (isMultiSelection(selection) && isEmpty(selection.focusPath)) // root selected\n  ) {\n    // replace selected value (new value can be primitive or an array/object with contents)\n    try {\n      return [\n        {\n          op: 'replace',\n          path: compileJSONPointer(getFocusPath(selection)),\n          value: parsePartialJson(clipboardText, (text) => parseAndRepair(text, parser))\n        }\n      ]\n    } catch {\n      // parsing failed -> just paste the raw text as value\n      return [\n        {\n          op: 'replace',\n          path: compileJSONPointer(getFocusPath(selection)),\n          value: clipboardText\n        }\n      ]\n    }\n  }\n\n  if (isMultiSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n\n    return replace(json, getSelectionPaths(json, selection), newValues)\n  }\n\n  if (isAfterSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n    const path = selection.path\n    const parentPath = initial(path)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const index = int(last(path) as string)\n      const nextItemPath = parentPath.concat(String(index + 1))\n\n      return insertBefore(json, nextItemPath, newValues)\n    } else if (isJSONObject(parent)) {\n      // value is an Object\n      const key = String(last(path))\n      const keys: string[] = Object.keys(parent)\n      if (isEmpty(keys) || last(keys) === key) {\n        return append(json, parentPath, newValues)\n      } else {\n        const index = keys.indexOf(key)\n        const nextKey = keys[index + 1]\n        const nextKeyPath = parentPath.concat(nextKey)\n\n        return insertBefore(json, nextKeyPath, newValues)\n      }\n    } else {\n      throw new Error('Cannot create insert operations: parent must be an Object or Array')\n    }\n  }\n\n  if (isInsideSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n    const path = selection.path\n    const value = getIn(json, path)\n\n    if (isJSONArray(value)) {\n      const firstItemPath = path.concat('0')\n      return insertBefore(json, firstItemPath, newValues)\n    } else if (isJSONObject(value)) {\n      // value is an Object\n      const keys = Object.keys(value)\n      if (isEmpty(keys)) {\n        return append(json, path, newValues)\n      } else {\n        const firstKey = first(keys) as string\n        const firstKeyPath = path.concat(firstKey)\n\n        return insertBefore(json, firstKeyPath, newValues)\n      }\n    } else {\n      throw new Error('Cannot create insert operations: parent must be an Object or Array')\n    }\n  }\n\n  // this should never happen\n  throw new Error('Cannot insert: unsupported type of selection ' + JSON.stringify(selection))\n}\n\nexport function moveInsideParent(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  dragInsideAction: DragInsideAction\n): JSONPatchDocument {\n  if (!selection) {\n    return []\n  }\n\n  const beforePath = 'beforePath' in dragInsideAction ? dragInsideAction['beforePath'] : undefined\n  const append = 'append' in dragInsideAction ? dragInsideAction['append'] : undefined\n\n  const parentPath = initial(getFocusPath(selection))\n  const parent = getIn(json, parentPath)\n\n  if (\n    !append &&\n    !(beforePath && pathStartsWith(beforePath, parentPath) && beforePath.length > parentPath.length)\n  ) {\n    return []\n  }\n\n  const startPath = getStartPath(json, selection)\n  const endPath = getEndPath(json, selection)\n  const startKey = last(startPath) as string\n  const endKey = last(endPath) as string\n  const toKey: string | undefined = beforePath ? beforePath[parentPath.length] : undefined\n\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    const startIndex = keys.indexOf(startKey)\n    const endIndex = keys.indexOf(endKey)\n    const toIndex = append ? keys.length : toKey !== undefined ? keys.indexOf(toKey) : -1\n\n    if (startIndex !== -1 && endIndex !== -1 && toIndex !== -1) {\n      if (toIndex > startIndex) {\n        // moving down\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        return [...keys.slice(startIndex, endIndex + 1), ...keys.slice(toIndex, keys.length)].map(\n          (key) => moveDown(parentPath, key)\n        )\n      } else {\n        // moving up\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        return [...keys.slice(toIndex, startIndex), ...keys.slice(endIndex + 1, keys.length)].map(\n          (key) => moveDown(parentPath, key)\n        )\n      }\n    }\n  } else if (isJSONArray(parent)) {\n    // array\n    const startIndex = int(startKey)\n    const endIndex = int(endKey)\n    const toIndex = toKey !== undefined ? int(toKey) : parent.length\n    const count = endIndex - startIndex + 1\n\n    if (toIndex < startIndex) {\n      // move up\n      return times(count, (offset) => {\n        return {\n          op: 'move',\n          from: compileJSONPointer(parentPath.concat(String(startIndex + offset))),\n          path: compileJSONPointer(parentPath.concat(String(toIndex + offset)))\n        }\n      })\n    } else {\n      // move down\n      return times(count, () => {\n        return {\n          op: 'move',\n          from: compileJSONPointer(parentPath.concat(String(startIndex))),\n          path: compileJSONPointer(parentPath.concat(String(toIndex)))\n        }\n      })\n    }\n  } else {\n    throw new Error('Cannot create move operations: parent must be an Object or Array')\n  }\n\n  return []\n}\n\nexport function createNewValue(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  valueType: 'object' | 'array' | 'structure' | 'value'\n): unknown {\n  if (valueType === 'object') {\n    return {}\n  }\n\n  if (valueType === 'array') {\n    return []\n  }\n\n  if (valueType === 'structure' && json !== undefined) {\n    const parentPath = selection ? getParentPath(selection) : []\n    const parent = getIn(json, parentPath)\n\n    if (Array.isArray(parent) && !isEmpty(parent)) {\n      const jsonExample = first(parent)\n      if (isObjectOrArray(jsonExample)) {\n        return cloneDeepWith(jsonExample, (value) => {\n          return Array.isArray(value)\n            ? []\n            : isObject(value)\n              ? undefined // leave object as is, will recurse into it\n              : ''\n        })\n      } else {\n        // just a primitive value\n        return ''\n      }\n    }\n  }\n\n  // type === value,\n  // or type === structure but the parent is no array or an array containing\n  // primitive values (and no objects having any structure).\n  return ''\n}\n\n/**\n * Create a JSONPatch for a remove operation\n */\nexport function remove(path: JSONPath): JSONPatchDocument {\n  return [\n    {\n      op: 'remove',\n      path: compileJSONPointer(path)\n    }\n  ]\n}\n\n/**\n * Create a JSONPatch for a multiple remove operation\n */\nexport function removeAll(paths: JSONPath[]): JSONPatchDocument {\n  return paths\n    .map((path) => {\n      const operation: JSONPatchOperation = {\n        op: 'remove',\n        path: compileJSONPointer(path)\n      }\n\n      return operation\n    })\n    .reverse() // reverse is needed for arrays: delete the last index first\n}\n\n// helper function to move a key down in an object,\n// so another key can get positioned before the moved down keys\nfunction moveDown(parentPath: JSONPath, key: string): JSONPatchOperation {\n  return {\n    op: 'move',\n    from: compileJSONPointer(parentPath.concat(key)),\n    path: compileJSONPointer(parentPath.concat(key))\n  }\n}\n\nexport function clipboardToValues(clipboardText: string, parser: JSONParser): ClipboardValues {\n  const textIsObject = /^\\s*{/.test(clipboardText)\n  const textIsArray = /^\\s*\\[/.test(clipboardText)\n\n  const clipboardOriginal = parseAndRepairOrUndefined(clipboardText, parser)\n  const clipboardRepaired =\n    clipboardOriginal !== undefined\n      ? clipboardOriginal\n      : parsePartialJson(clipboardText, (text) => parseAndRepair(text, parser))\n\n  if (\n    (textIsObject && isObject(clipboardRepaired)) ||\n    (textIsArray && Array.isArray(clipboardRepaired))\n  ) {\n    return [{ key: 'New item', value: clipboardRepaired }]\n  }\n\n  if (Array.isArray(clipboardRepaired)) {\n    return clipboardRepaired.map((value, index) => {\n      return { key: 'New item ' + index, value }\n    })\n  }\n\n  if (isObject(clipboardRepaired)) {\n    return Object.keys(clipboardRepaired).map((key) => {\n      return { key, value: clipboardRepaired[key] }\n    })\n  }\n\n  // regular value\n  return [{ key: 'New item', value: clipboardRepaired }]\n}\n\n// TODO: write unit tests\nexport function createRemoveOperations(\n  json: unknown,\n  selection: JSONSelection\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  if (isKeySelection(selection)) {\n    // FIXME: DOESN'T work yet\n    const parentPath = initial(selection.path)\n    const parent = getIn(json, parentPath)\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const oldKey = last(selection.path) as string\n    const newKey = ''\n\n    const operations = rename(parentPath, keys, oldKey, newKey)\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return { operations, newSelection }\n  }\n\n  if (isValueSelection(selection)) {\n    const operations: JSONPatchDocument = [\n      {\n        op: 'replace',\n        path: compileJSONPointer(selection.path),\n        value: ''\n      }\n    ]\n\n    return { operations, newSelection: selection }\n  }\n\n  if (isMultiSelection(selection)) {\n    const paths = getSelectionPaths(json, selection)\n    const operations = removeAll(paths)\n    const lastPath = last(paths)\n\n    if (isEmpty(lastPath)) {\n      // there is no parent, this is the root document\n      const operations: JSONPatchDocument = [{ op: 'replace', path: '', value: '' }]\n\n      const newSelection = createValueSelection([])\n\n      return { operations, newSelection }\n    }\n\n    const parentPath = initial(lastPath)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const firstPath = first(paths)\n      const index = int(last(firstPath) as string)\n      const newSelection =\n        index === 0\n          ? createInsideSelection(parentPath)\n          : createAfterSelection(parentPath.concat(String(index - 1)))\n\n      return { operations, newSelection }\n    } else if (isJSONObject(parent)) {\n      // parent is object\n      const keys = Object.keys(parent)\n      const firstPath = first(paths)\n      const key = last(firstPath) as string\n      const index = keys.indexOf(key)\n      const previousKey = keys[index - 1]\n      const newSelection =\n        index === 0\n          ? createInsideSelection(parentPath)\n          : createAfterSelection(parentPath.concat(previousKey))\n\n      return { operations, newSelection }\n    } else {\n      throw new Error('Cannot create remove operations: parent must be an Object or Array')\n    }\n  }\n\n  // this should never happen\n  throw new Error('Cannot remove: unsupported type of selection ' + JSON.stringify(selection))\n}\n\nexport function revertJSONPatchWithMoveOperations(\n  json: unknown,\n  operations: JSONPatchDocument\n): JSONPatchDocument {\n  return dedupeKeepLast(\n    revertJSONPatch(json, operations, {\n      before: (json, operation, revertOperations) => {\n        if (isJSONPatchRemove(operation)) {\n          const path = parseJSONPointer(operation.path)\n          return {\n            revertOperations: [...revertOperations, ...createRevertMoveOperations(json, path)]\n          }\n        }\n\n        if (isJSONPatchMove(operation)) {\n          const from = parseJSONPointer(operation.from)\n          return {\n            revertOperations:\n              operation.from === operation.path\n                ? [operation, ...createRevertMoveOperations(json, from)] // move in-place (just for re-ordering object keys)\n                : [...revertOperations, ...createRevertMoveOperations(json, from)]\n          }\n        }\n\n        return { document: json }\n      }\n    })\n  )\n}\n\nfunction createRevertMoveOperations(json: unknown, path: JSONPath): JSONPatchOperation[] {\n  const parentPath = initial(path)\n  const afterKey = last(path) as string\n  const parent = getIn(json, parentPath)\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    const nextKeys = getNextKeys(keys, afterKey, false)\n\n    // move all lower down keys so the inserted key will maintain its position\n    return nextKeys.map((key) => moveDown(parentPath, key))\n  }\n\n  return []\n}\n\n/**\n * Add operations to create parent objects when missing before replacing a nested value\n */\nexport function createNestedValueOperations(operations: JSONPatchOperation[], json: unknown) {\n  return operations.flatMap((operation) => {\n    if (isJSONPatchReplace(operation)) {\n      const path = parseJSONPointer(operation.path)\n      if (path.length > 0) {\n        const extendedOperations: JSONPatchOperation[] = [operation]\n\n        let parentPath = initial(path)\n        while (parentPath.length > 0 && !existsIn(json, parentPath)) {\n          extendedOperations.unshift({\n            op: 'add',\n            path: compileJSONPointer(parentPath),\n            value: {}\n          })\n\n          parentPath = initial(parentPath)\n        }\n\n        return extendedOperations\n      }\n    }\n\n    return operation\n  })\n}\n","import type { JSONPatchDocument, JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, getIn, isJSONArray, isJSONObject } from 'immutable-json-patch'\nimport { forEachRight, initial, isEqual, last } from 'lodash-es'\nimport { getEnforceString, updateInRecursiveState } from './documentState.js'\nimport { createSelectionFromOperations } from './selection.js'\nimport { rename } from './operations.js'\nimport { stringConvert } from '../utils/typeUtils.js'\nimport type {\n  DocumentState,\n  ExtendedSearchResultItem,\n  JSONParser,\n  JSONSelection,\n  RecursiveStateFactory,\n  SearchOptions,\n  SearchResultDetails,\n  SearchResultItem,\n  SearchResults\n} from '$lib/types'\nimport { SearchField } from '$lib/types.js'\nimport {\n  hasSearchResults,\n  isArrayRecursiveState,\n  isObjectRecursiveState\n} from 'svelte-jsoneditor/typeguards.js'\n\n// TODO: comment\n// TODO: unit test\nexport function updateSearchResult(\n  newResultItems: SearchResultItem[],\n  previousResult: SearchResultDetails | undefined\n): SearchResultDetails {\n  const activePath = previousResult?.activeItem\n    ? getSearchResultPath(previousResult.activeItem)\n    : undefined\n\n  const matchingActiveIndex = newResultItems.findIndex((item) => {\n    return isEqual(activePath, getSearchResultPath(item))\n  })\n\n  const activeIndex =\n    matchingActiveIndex !== -1\n      ? matchingActiveIndex\n      : previousResult?.activeIndex !== undefined &&\n          previousResult?.activeIndex < newResultItems.length\n        ? previousResult?.activeIndex\n        : newResultItems.length > 0\n          ? 0\n          : -1\n\n  const items: ExtendedSearchResultItem[] = newResultItems.map((item, resultIndex) => {\n    return { resultIndex, ...item, active: resultIndex === activeIndex }\n  })\n\n  const activeItem = items[activeIndex]\n\n  return {\n    items,\n    activeItem,\n    activeIndex\n  }\n}\n\n// TODO: unit test\nexport function searchNext(searchResult: SearchResultDetails): SearchResultDetails {\n  const nextActiveIndex =\n    searchResult.activeIndex < searchResult.items.length - 1\n      ? searchResult.activeIndex + 1\n      : searchResult.items.length > 0\n        ? 0\n        : -1\n\n  const nextActiveItem = searchResult.items[nextActiveIndex]\n\n  const items: ExtendedSearchResultItem[] = searchResult.items.map((item, index) => {\n    return { ...item, active: index === nextActiveIndex }\n  })\n\n  return {\n    ...searchResult,\n    items,\n    activeItem: nextActiveItem,\n    activeIndex: nextActiveIndex\n  }\n}\n\n// TODO: unit test\nexport function searchPrevious(searchResult: SearchResultDetails): SearchResultDetails {\n  const previousActiveIndex =\n    searchResult.activeIndex > 0 ? searchResult.activeIndex - 1 : searchResult.items.length - 1\n\n  const previousActiveItem = searchResult.items[previousActiveIndex]\n\n  const items: ExtendedSearchResultItem[] = searchResult.items.map((item, index) => {\n    return { ...item, active: index === previousActiveIndex }\n  })\n\n  return {\n    ...searchResult,\n    items,\n    activeItem: previousActiveItem,\n    activeIndex: previousActiveIndex\n  }\n}\n\n// TODO: comment\nexport function search(\n  searchText: string,\n  json: unknown,\n  options: SearchOptions = {}\n): SearchResultItem[] {\n  const searchTextLowerCase = searchText.toLowerCase()\n  const maxResults = options?.maxResults ?? Infinity\n  const columns = options?.columns\n  const results: SearchResultItem[] = []\n  const path: JSONPath = [] // we reuse the same Array recursively, this is *much* faster than creating a new path every time\n\n  function onMatch(match: SearchResultItem) {\n    if (results.length >= maxResults) {\n      return\n    }\n\n    results.push(match)\n  }\n\n  function searchRecursive(searchTextLowerCase: string, value: unknown) {\n    if (isJSONArray(value)) {\n      const level = path.length\n      path.push('0')\n\n      for (let i = 0; i < value.length; i++) {\n        path[level] = String(i)\n\n        searchRecursive(searchTextLowerCase, value[i])\n\n        if (results.length >= maxResults) {\n          return\n        }\n      }\n\n      path.pop()\n    } else if (isJSONObject(value)) {\n      const keys = Object.keys(value)\n      const level = path.length\n\n      path.push('')\n\n      for (const key of keys) {\n        path[level] = key\n\n        findCaseInsensitiveMatches(key, searchTextLowerCase, path, SearchField.key, onMatch)\n\n        searchRecursive(searchTextLowerCase, value[key])\n\n        if (results.length >= maxResults) {\n          return\n        }\n      }\n\n      path.pop()\n    } else {\n      // type is a value\n      findCaseInsensitiveMatches(\n        String(value),\n        searchTextLowerCase,\n        path,\n        SearchField.value,\n        onMatch\n      )\n    }\n  }\n\n  if (searchText === '') {\n    return []\n  } else if (columns) {\n    if (!Array.isArray(json)) {\n      throw new Error('json must be an Array when option columns is defined')\n    }\n\n    for (let i = 0; i < json.length; i++) {\n      path[0] = String(i)\n\n      const item = json[i]\n\n      for (let c = 0; c < columns.length; c++) {\n        const column = columns[c]\n\n        if (column.length === 1) {\n          path[1] = column[0]\n        } else {\n          for (let p = 0; p < column.length; p++) {\n            path[p + 1] = column[p]\n          }\n        }\n        while (path.length > column.length + 1) {\n          path.pop()\n        }\n\n        const value = getIn(item, column)\n\n        searchRecursive(searchTextLowerCase, value)\n      }\n\n      if (results.length >= maxResults) {\n        break\n      }\n    }\n\n    return results\n  } else {\n    searchRecursive(searchTextLowerCase, json)\n    return results\n  }\n}\n\n/**\n * Do a case-insensitive search for a search text in a text\n */\nexport function findCaseInsensitiveMatches(\n  text: string,\n  searchTextLowerCase: string,\n  path: JSONPath,\n  field: SearchField,\n  onMatch: (searchResultItem: SearchResultItem) => void\n): void {\n  const textLower = text.toLowerCase()\n\n  let fieldIndex = 0\n  let position = -1\n  let index = -1\n\n  do {\n    index = textLower.indexOf(searchTextLowerCase, position)\n\n    if (index !== -1) {\n      position = index + searchTextLowerCase.length\n\n      onMatch({\n        path: path.slice(0), // path may be mutated in a later stage, therefore we store a copy\n        field,\n        fieldIndex,\n        start: index,\n        end: position\n      })\n\n      fieldIndex++\n    }\n  } while (index !== -1)\n}\n\n/**\n * Replace a search result item with a replacement text\n */\nexport function replaceText(text: string, replacementText: string, start: number, end: number) {\n  return text.substring(0, start) + replacementText + text.substring(end)\n}\n\n/**\n * Replace all matches with a replacement text\n */\nexport function replaceAllText(\n  text: string,\n  replacementText: string,\n  occurrences: Array<{ start: number; end: number }>\n): string {\n  let updatedText = text\n\n  forEachRight(occurrences, (occurrence) => {\n    updatedText = replaceText(updatedText, replacementText, occurrence.start, occurrence.end)\n  })\n\n  return updatedText\n}\n\nexport function createSearchAndReplaceOperations(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  replacementText: string,\n  searchResultItem: SearchResultItem,\n  parser: JSONParser\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  const { field, path, start, end } = searchResultItem\n\n  if (field === SearchField.key) {\n    // replace a key\n    const parentPath = initial(path)\n    const parent = getIn(json, parentPath)\n    const oldKey = last(path) as string\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const newKey = replaceText(oldKey, replacementText, start, end)\n\n    const operations = rename(parentPath, keys, oldKey, newKey)\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return {\n      newSelection,\n      operations\n    }\n  } else if (field === SearchField.value) {\n    // replace a value\n    const currentValue: unknown | undefined = getIn(json, path)\n    if (currentValue === undefined) {\n      throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`)\n    }\n    const currentValueText = typeof currentValue === 'string' ? currentValue : String(currentValue)\n\n    const enforceString = getEnforceString(json, documentState, path)\n    const value = replaceText(currentValueText, replacementText, start, end)\n\n    const operations: JSONPatchOperation[] = [\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: enforceString ? value : stringConvert(value, parser)\n      }\n    ]\n\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return {\n      newSelection,\n      operations\n    }\n  } else {\n    throw new Error(`Cannot replace: unknown type of search result field ${field}`)\n  }\n}\n\nexport function createSearchAndReplaceAllOperations(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  searchText: string,\n  replacementText: string,\n  parser: JSONParser\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  // TODO: to improve performance, we could reuse existing search results (except when hitting a maxResult limit)\n  const searchResultItems = search(searchText, json, { maxResults: Infinity })\n\n  interface Match {\n    path: JSONPath\n    field: string\n    items: SearchResultItem[]\n  }\n\n  // step 1: deduplicate matches inside the same field/value\n  // (filter, map, and group)\n  const deduplicatedMatches: Match[] = []\n  for (let i = 0; i < searchResultItems.length; i++) {\n    const previousItem = searchResultItems[i - 1]\n    const item = searchResultItems[i]\n    if (i === 0 || item.field !== previousItem.field || !isEqual(item.path, previousItem.path)) {\n      deduplicatedMatches.push({\n        path: item.path,\n        field: item.field,\n        items: [item]\n      })\n    } else {\n      ;(last(deduplicatedMatches) as Match).items.push(item)\n    }\n  }\n\n  // step 2: sort from deepest nested to least nested\n  // this is needed to replace in that order because paths may change\n  // if there are replacements in keys\n  deduplicatedMatches.sort((a, b) => {\n    // sort values first, properties next\n    if (a.field !== b.field) {\n      if (a.field === SearchField.key) {\n        return 1\n      } else {\n        return -1\n      }\n    }\n\n    // sort longest paths first, shortest last\n    return b.path.length - a.path.length\n  })\n\n  // step 3: call createSearchAndReplaceOperations for each of the matches\n  let allOperations: JSONPatchDocument = []\n  let lastNewSelection: JSONSelection | undefined\n  deduplicatedMatches.forEach((match) => {\n    // TODO: there is overlap with the logic of createSearchAndReplaceOperations. Can we extract and reuse this logic?\n    const { field, path, items } = match\n\n    if (field === SearchField.key) {\n      // replace a key\n      const parentPath = initial(path)\n      const parent = getIn(json, parentPath)\n      const oldKey = last(path) as string\n      const keys = Object.keys(parent as Record<string, unknown>)\n      const newKey = replaceAllText(oldKey, replacementText, items)\n\n      const operations = rename(parentPath, keys, oldKey, newKey)\n      allOperations = allOperations.concat(operations)\n\n      lastNewSelection = createSelectionFromOperations(json, operations)\n    } else if (field === SearchField.value) {\n      // replace a value\n      const currentValue: unknown | undefined = getIn(json, path)\n      if (currentValue === undefined) {\n        throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`)\n      }\n      const currentValueText =\n        typeof currentValue === 'string' ? currentValue : String(currentValue)\n      const enforceString = getEnforceString(json, documentState, path)\n      const value = replaceAllText(currentValueText, replacementText, items)\n\n      const operations: JSONPatchOperation[] = [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: enforceString ? value : stringConvert(value, parser)\n        }\n      ]\n      allOperations = allOperations.concat(operations)\n\n      lastNewSelection = createSelectionFromOperations(json, operations)\n    } else {\n      throw new Error(`Cannot replace: unknown type of search result field ${field}`)\n    }\n  })\n\n  return {\n    operations: allOperations,\n    newSelection: lastNewSelection\n  }\n}\n\nexport interface SplitValuePart {\n  text: string\n  type: 'normal' | 'highlight'\n  resultIndex: number | undefined\n  active: boolean\n}\n\n/**\n * Split the text into separate parts for each search result and the text\n * in between.\n */\nexport function splitValue(text: string, matches: ExtendedSearchResultItem[]): SplitValuePart[] {\n  const parts: SplitValuePart[] = []\n\n  let previousEnd = 0\n\n  for (const match of matches) {\n    const precedingText = text.slice(previousEnd, match.start)\n    if (precedingText !== '') {\n      parts.push({\n        resultIndex: undefined,\n        type: 'normal',\n        text: precedingText,\n        active: false\n      })\n    }\n\n    const matchingText = text.slice(match.start, match.end)\n    parts.push({\n      resultIndex: match.resultIndex,\n      type: 'highlight',\n      text: matchingText,\n      active: match.active\n    })\n\n    previousEnd = match.end\n  }\n\n  const lastMatch = last(matches)\n  if (lastMatch && lastMatch.end < text.length) {\n    parts.push({\n      type: 'normal',\n      text: text.slice(lastMatch.end),\n      resultIndex: undefined,\n      active: false\n    })\n  }\n\n  return parts\n}\n\n/**\n * Get the path of the search result property on a nested search result\n */\nfunction getSearchResultPath(searchResultItem: SearchResultItem): JSONPath {\n  return searchResultItem.path.concat(searchResultItem.field, String(searchResultItem.fieldIndex))\n}\n\n/**\n * Filter key search results.\n * Returns a non-empty array, or undefined if there are no key search results\n */\nexport function filterKeySearchResults(\n  searchResult: SearchResults | undefined\n): ExtendedSearchResultItem[] | undefined {\n  const filtered = hasSearchResults(searchResult)\n    ? searchResult.searchResults.filter((result) => result.field === SearchField.key)\n    : undefined\n\n  return filtered && filtered.length > 0 ? filtered : undefined\n}\n\n/**\n * Filter value search results.\n * Returns a non-empty array, or undefined if there are no value search results\n */\nexport function filterValueSearchResults(\n  searchResult: SearchResults | undefined\n): ExtendedSearchResultItem[] | undefined {\n  const filtered = hasSearchResults(searchResult)\n    ? searchResult.searchResults.filter((result) => result.field === SearchField.value)\n    : undefined\n\n  return filtered && filtered.length > 0 ? filtered : undefined\n}\n\nexport const searchResultsFactory: RecursiveStateFactory = {\n  createObjectDocumentState: () => ({ type: 'object', properties: {} }),\n  createArrayDocumentState: () => ({ type: 'array', items: [] }),\n  createValueDocumentState: () => ({ type: 'value' })\n}\n\nexport function updateInSearchResults(\n  json: unknown,\n  searchResults: SearchResults | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: SearchResults) => SearchResults\n): SearchResults {\n  return updateInRecursiveState(json, searchResults, path, transform, searchResultsFactory)\n}\n\nexport function toRecursiveSearchResults(\n  json: unknown,\n  searchResultItems: ExtendedSearchResultItem[]\n): SearchResults | undefined {\n  return searchResultItems.reduce(\n    (recursiveState, searchResult) => {\n      return updateInSearchResults(json, recursiveState, searchResult.path, (_, nestedState) => ({\n        ...nestedState,\n        searchResults: nestedState.searchResults\n          ? nestedState.searchResults.concat(searchResult)\n          : [searchResult]\n      }))\n    },\n    undefined as SearchResults | undefined\n  )\n}\n\nexport function flattenSearchResults(node: SearchResults | undefined): ExtendedSearchResultItem[] {\n  const self = node?.searchResults ?? []\n\n  const nested = isObjectRecursiveState(node)\n    ? Object.values(node.properties).flatMap(flattenSearchResults)\n    : isArrayRecursiveState(node)\n      ? node.items.flatMap(flattenSearchResults)\n      : []\n\n  return self.concat(nested)\n}\n","<script lang=\"ts\">\n  import { splitValue } from '$lib/logic/search.js'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import type { ExtendedSearchResultItem } from '$lib/types'\n\n  export let text: string\n  export let searchResultItems: ExtendedSearchResultItem[]\n\n  $: parts = splitValue(String(text), searchResultItems)\n</script>\n\n{#each parts as part}\n  {#if part.type === 'normal'}\n    {part.text}\n  {:else}\n    <span\n      class=\"jse-highlight\"\n      class:jse-active={part.active}\n      data-search-result-index={String(part.resultIndex)}>{addNewLineSuffix(part.text)}</span\n    >\n  {/if}\n{/each}\n\n<style src=\"./SearchResultHighlighter.scss\"></style>\n","/**\n * Return a human-readable document size\n * For example formatSize(7570718) outputs '7.6 MB'\n * This function uses 1000 for kilo (not 1024)\n * @param size\n * @return Returns a human-readable size\n */\nexport function formatSize(size: number): string {\n  const kilo = 1000\n  const factor = 0.9\n\n  if (size < factor * kilo) {\n    return size.toFixed() + ' B'\n  }\n\n  const KB = size / kilo\n  if (KB < factor * kilo) {\n    return KB.toFixed(1) + ' KB'\n  }\n\n  const MB = KB / kilo\n  if (MB < factor * kilo) {\n    return MB.toFixed(1) + ' MB'\n  }\n\n  const GB = MB / kilo\n  if (GB < factor * kilo) {\n    return GB.toFixed(1) + ' GB'\n  }\n\n  const TB = GB / kilo\n  return TB.toFixed(1) + ' TB'\n}\n","<script lang=\"ts\">\n  import type { Snippet } from 'svelte'\n\n  interface Props {\n    onclick?: () => void\n    children?: Snippet\n  }\n\n  const { onclick, children }: Props = $props()\n\n  const handleClick = $derived.by(() => {\n    return onclick\n      ? (event: MouseEvent) => {\n          event.preventDefault()\n          event.stopPropagation()\n          onclick()\n        }\n      : undefined\n  })\n</script>\n\n<button type=\"button\" class=\"jse-tag\" onclick={handleClick} disabled={!onclick}>\n  {@render children?.()}\n</button>\n\n<style lang=\"scss\">\n  @use '../../styles';\n  @use '../../themes/defaults';\n\n  .jse-tag {\n    border: none;\n    font-size: 80%;\n    font-family: defaults.$font-family;\n    color: defaults.$tag-color;\n    background: defaults.$tag-background;\n    border-radius: 2px;\n    cursor: pointer;\n    //position: relative;\n    display: inline-block;\n    padding: 0 4px;\n    line-height: normal;\n    margin: 1px 0;\n\n    &:hover {\n      opacity: 0.8;\n    }\n\n    &:disabled {\n      opacity: 0.7;\n      cursor: inherit;\n    }\n  }\n</style>\n","/** @import { Snippet } from 'svelte' */\n/** @import { Effect, TemplateNode } from '#client' */\n/** @import { Getters } from '#shared' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { branch, block, destroy_effect, teardown } from '../../reactivity/effects.js';\nimport {\n\tdev_current_component_function,\n\tset_dev_current_component_function\n} from '../../context.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\nimport { create_fragment_from_html } from '../reconciler.js';\nimport { assign_nodes } from '../template.js';\nimport * as w from '../../warnings.js';\nimport * as e from '../../errors.js';\nimport { DEV } from 'esm-env';\nimport { get_first_child, get_next_sibling } from '../operations.js';\nimport { noop } from '../../../shared/utils.js';\n\n/**\n * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn\n * @param {TemplateNode} node\n * @param {() => SnippetFn | null | undefined} get_snippet\n * @param {(() => any)[]} args\n * @returns {void}\n */\nexport function snippet(node, get_snippet, ...args) {\n\tvar anchor = node;\n\n\t/** @type {SnippetFn | null | undefined} */\n\t// @ts-ignore\n\tvar snippet = noop;\n\n\t/** @type {Effect | null} */\n\tvar snippet_effect;\n\n\tblock(() => {\n\t\tif (snippet === (snippet = get_snippet())) return;\n\n\t\tif (snippet_effect) {\n\t\t\tdestroy_effect(snippet_effect);\n\t\t\tsnippet_effect = null;\n\t\t}\n\n\t\tif (DEV && snippet == null) {\n\t\t\te.invalid_snippet();\n\t\t}\n\n\t\tsnippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * In development, wrap the snippet function so that it passes validation, and so that the\n * correct component context is set for ownership checks\n * @param {any} component\n * @param {(node: TemplateNode, ...args: any[]) => void} fn\n */\nexport function wrap_snippet(component, fn) {\n\treturn (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => {\n\t\tvar previous_component_function = dev_current_component_function;\n\t\tset_dev_current_component_function(component);\n\n\t\ttry {\n\t\t\treturn fn(node, ...args);\n\t\t} finally {\n\t\t\tset_dev_current_component_function(previous_component_function);\n\t\t}\n\t};\n}\n\n/**\n * Create a snippet programmatically\n * @template {unknown[]} Params\n * @param {(...params: Getters<Params>) => {\n *   render: () => string\n *   setup?: (element: Element) => void | (() => void)\n * }} fn\n * @returns {Snippet<Params>}\n */\nexport function createRawSnippet(fn) {\n\t// @ts-expect-error the types are a lie\n\treturn (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {\n\t\tvar snippet = fn(...params);\n\n\t\t/** @type {Element} */\n\t\tvar element;\n\n\t\tif (hydrating) {\n\t\t\telement = /** @type {Element} */ (hydrate_node);\n\t\t\thydrate_next();\n\t\t} else {\n\t\t\tvar html = snippet.render().trim();\n\t\t\tvar fragment = create_fragment_from_html(html);\n\t\t\telement = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (DEV && (get_next_sibling(element) !== null || element.nodeType !== 1)) {\n\t\t\t\tw.invalid_raw_snippet_render();\n\t\t\t}\n\n\t\t\tanchor.before(element);\n\t\t}\n\n\t\tconst result = snippet.setup?.(element);\n\t\tassign_nodes(element, element);\n\n\t\tif (typeof result === 'function') {\n\t\t\tteardown(result);\n\t\t}\n\t};\n}\n","<script lang=\"ts\">\n  import { isUrl } from '$lib/utils/typeUtils.js'\n  import { createEditValueSelection } from '$lib/logic/selection.js'\n  import SearchResultHighlighter from '../../../components/modes/treemode/highlight/SearchResultHighlighter.svelte'\n  import { getValueClass } from './utils/getValueClass.js'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import { type RenderValueProps } from '$lib/types.js'\n  import { isCtrlKeyDown } from 'svelte-jsoneditor/utils/keyBindings'\n  import { formatSize } from '$lib/utils/fileUtils'\n  import Tag from '../../../components/controls/Tag.svelte'\n\n  const {\n    path,\n    value,\n    mode,\n    truncateTextSize,\n    readOnly,\n    normalization,\n    parser,\n    onSelect,\n    searchResultItems\n  }: RenderValueProps = $props()\n\n  let doTruncate = $state(true)\n  const isTruncated = $derived(\n    doTruncate &&\n      typeof value === 'string' &&\n      value.length > truncateTextSize &&\n      (!searchResultItems ||\n        !searchResultItems.some((item) => item.active && item.end > truncateTextSize))\n  )\n  const truncatedValue = $derived(\n    isTruncated && typeof value === 'string' ? value.substring(0, truncateTextSize).trim() : value\n  )\n  const valueIsUrl = $derived(isUrl(value))\n\n  function handleValueClick(event: MouseEvent) {\n    if (typeof value === 'string' && valueIsUrl && isCtrlKeyDown(event)) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      window.open(value, '_blank')\n    }\n  }\n\n  function handleValueDoubleClick(event: MouseEvent) {\n    if (!readOnly) {\n      event.preventDefault()\n      onSelect(createEditValueSelection(path))\n    }\n  }\n\n  function handleShowMore() {\n    doTruncate = false\n  }\n</script>\n\n<!-- svelte-ignore a11y_click_events_have_key_events -->\n<div\n  role=\"button\"\n  tabindex=\"-1\"\n  data-type=\"selectable-value\"\n  class={getValueClass(value, mode, parser)}\n  onclick={handleValueClick}\n  ondblclick={handleValueDoubleClick}\n  title={valueIsUrl ? 'Ctrl+Click or Ctrl+Enter to open url in new window' : undefined}\n>\n  {#if searchResultItems}\n    <SearchResultHighlighter text={normalization.escapeValue(truncatedValue)} {searchResultItems} />\n  {:else}\n    {addNewLineSuffix(normalization.escapeValue(truncatedValue))}\n  {/if}\n  {#if isTruncated && typeof value === 'string'}\n    <Tag onclick={handleShowMore}>\n      Show more ({formatSize(value.length)})\n    </Tag>\n  {/if}\n</div>\n\n<style src=\"./ReadonlyValue.scss\"></style>\n","<script lang=\"ts\">\n  export let text: string\n</script>\n\n<div class=\"jse-tooltip\">\n  {text}\n</div>\n\n<style src=\"./Tooltip.scss\"></style>\n","import Tooltip from './Tooltip.svelte'\nimport type { SvelteComponent } from 'svelte'\nimport type { AbsolutePopupOptions } from '$lib/types'\n\nexport interface TooltipOptions {\n  text: string\n  openAbsolutePopup: (\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ) => number\n  closeAbsolutePopup: (popupId: number | undefined) => void\n}\n\nexport function tooltip(\n  node: Element,\n  { text, openAbsolutePopup, closeAbsolutePopup }: TooltipOptions\n) {\n  let popupId: number | undefined\n\n  function handleMouseEnter() {\n    const props = {\n      text\n    }\n\n    // opening popup will fail if there is already a popup open\n    popupId = openAbsolutePopup(Tooltip, props, {\n      position: 'top',\n      width: 10 * text.length, // rough estimate of the width of the message\n      offsetTop: 3,\n      anchor: node,\n      closeOnOuterClick: true\n    })\n  }\n\n  function handleMouseLeave() {\n    closeAbsolutePopup(popupId)\n  }\n\n  node.addEventListener('mouseenter', handleMouseEnter)\n  node.addEventListener('mouseleave', handleMouseLeave)\n\n  return {\n    destroy() {\n      node.removeEventListener('mouseenter', handleMouseEnter)\n      node.removeEventListener('mouseleave', handleMouseLeave)\n    }\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faClock } from '@fortawesome/free-regular-svg-icons'\n  import { getContext } from 'svelte'\n  import { tooltip } from '$lib/components/controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext } from '$lib/types'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let value: number\n\n  $: text = `Time: ${new Date(value).toString()}`\n</script>\n\n<div class=\"jse-timestamp\" use:tooltip={{ text, ...absolutePopupContext }}>\n  <Icon data={faClock} />\n</div>\n\n<style src=\"./TimestampTag.scss\"></style>\n","import { isBoolean, isColor, isTimestamp } from '$lib/utils/typeUtils.js'\nimport type { RenderValueComponentDescription, RenderValueProps } from '$lib/types'\nimport BooleanToggle from './components/BooleanToggle.svelte'\nimport ColorPicker from './components/ColorPicker.svelte'\nimport EditableValue from './components/EditableValue.svelte'\nimport ReadonlyValue from './components/ReadonlyValue.svelte'\nimport TimestampTag from './components/TimestampTag.svelte'\n\nexport function renderValue(props: RenderValueProps): RenderValueComponentDescription[] {\n  const renderers: RenderValueComponentDescription[] = []\n\n  if (!props.isEditing && isBoolean(props.value)) {\n    renderers.push({ component: BooleanToggle, props })\n  }\n\n  if (!props.isEditing && isColor(props.value)) {\n    renderers.push({ component: ColorPicker, props })\n  }\n\n  if (props.isEditing) {\n    renderers.push({ component: EditableValue, props })\n  }\n\n  if (!props.isEditing) {\n    renderers.push({ component: ReadonlyValue, props })\n  }\n\n  if (!props.isEditing && isTimestamp(props.value)) {\n    renderers.push({ component: TimestampTag, props })\n  }\n\n  return renderers\n}\n","import { isEmpty } from 'lodash-es'\nimport type { JSONPath } from 'immutable-json-patch'\nimport type { PathOption } from '$lib/types.js'\n\n/**\n **\n * Stringify an array with a path like ['items', '3', 'name'] into string like 'items[3].name'\n * Note that we allow all characters in a property name, like \"item with spaces[3].name\",\n * so this path is not usable as-is in JavaScript.\n */\nexport function stringifyJSONPath(path: JSONPath): string {\n  return path\n    .map((p, index) => {\n      return integerNumberRegex.test(p)\n        ? '[' + p + ']'\n        : /[.[\\]]/.test(p) || p === '' // match any character . or [ or ] and handle an empty string\n          ? '[\"' + escapeQuotes(p) + '\"]'\n          : (index > 0 ? '.' : '') + p\n    })\n    .join('')\n}\n\nfunction escapeQuotes(prop: string): string {\n  return prop.replace(/\"/g, '\\\\\"')\n}\n\n/**\n * Parse a JSON path like 'items[3].name' into a path like ['items', '3', 'name']\n */\nexport function parseJSONPath(pathStr: string): JSONPath {\n  const path: JSONPath = []\n  let i = 0\n\n  while (i < pathStr.length) {\n    if (pathStr[i] === '.') {\n      i++\n    }\n\n    if (pathStr[i] === '[') {\n      i++\n\n      if (pathStr[i] === '\"') {\n        i++\n        path.push(parseProp((c) => c === '\"', true))\n        eatCharacter('\"')\n      } else {\n        path.push(parseProp((c) => c === ']'))\n      }\n\n      eatCharacter(']')\n    } else {\n      path.push(parseProp((c) => c === '.' || c === '['))\n    }\n  }\n\n  function parseProp(isEnd: (char: string) => boolean, unescape = false) {\n    let prop = ''\n\n    while (i < pathStr.length && !isEnd(pathStr[i])) {\n      if (unescape && pathStr[i] === '\\\\' && pathStr[i + 1] === '\"') {\n        // escaped double quote\n        prop += '\"'\n        i += 2\n      } else {\n        prop += pathStr[i]\n        i++\n      }\n    }\n\n    return prop\n  }\n\n  function eatCharacter(char: string) {\n    if (pathStr[i] !== char) {\n      throw new SyntaxError(`Invalid JSON path: ${char} expected at position ${i}`)\n    }\n    i++\n  }\n\n  return path\n}\n\n/**\n * Convert a JSONPath into an option for use in a select box\n */\nexport function pathToOption(path: JSONPath): PathOption {\n  return {\n    value: path,\n    label: isEmpty(path) ? '(item root)' : stringifyJSONPath(path)\n  }\n}\n\n/**\n * Stringify a JSON path into a lodash path like:\n *\n *     [\"data\", 2, \"nested property\", \"name\"]\n *\n * into a lodash path like:\n *\n *     \"data[2].nested.name\"\n *\n */\nexport function createLodashPropertySelector(path: JSONPath): string {\n  return path.length === 0\n    ? ''\n    : path.every((prop) => integerNumberRegex.test(prop) || javaScriptPropertyRegex.test(prop))\n      ? \"'\" + path.map(stringifyLodashProperty).join('').replace(/^\\./, '') + \"'\"\n      : JSON.stringify(path)\n}\n\n/**\n * Stringify a single property of a JSON path. See also createLodashPropertySelector\n */\nfunction stringifyLodashProperty(prop: string): string {\n  if (integerNumberRegex.test(prop)) {\n    return '[' + prop + ']'\n  } else if (javaScriptPropertyRegex.test(prop)) {\n    return '.' + prop\n  } else {\n    const propStr = JSON.stringify(prop)\n    // remove enclosing double quotes, and unescape escaped double quotes \\\"\n    const jsonPathStr = propStr.substring(1, propStr.length - 1).replace(/\\\\\"/g, '\"')\n    return \"['\" + jsonPathStr + \"']\"\n  }\n}\n\n/**\n * Create a JavaScript property selector\n *\n * Turn a paths like:\n *\n *   ['location', 'latitude']\n *   ['address', 'full name']\n *\n * into a JavaScript selector (string) like:\n *\n *   '?.location?.latitude'\n *   '?.address?.[\"full name\"]'\n */\nexport function createPropertySelector(path: JSONPath): string {\n  return path\n    .map((prop) => {\n      if (integerNumberRegex.test(prop)) {\n        // an index\n        return `?.[${prop}]`\n      } else if (javaScriptPropertyRegex.test(prop)) {\n        // a key without special characters\n        return `?.${prop}`\n      } else {\n        // a key that may have special characters (like spaces or so)\n        return `?.[${JSON.stringify(prop)}]`\n      }\n    })\n    .join('')\n}\n\n// https://developer.mozilla.org/en-US/docs/Glossary/Identifier\n// Note: We can extend this regex to allow unicode characters too.\n// I'm too lazy to figure that out right now\nconst javaScriptPropertyRegex = /^[a-zA-Z$_][a-zA-Z$_\\d]*$/\nconst integerNumberRegex = /^\\d+$/\n","import type { QueryLanguageOptions } from '$lib/types.js'\n\nexport interface TransformModalState {\n  queryLanguageId: string\n  queryOptions: QueryLanguageOptions\n  query: string\n  isManual: boolean\n}\n\nexport const transformModalStates: Record<string, TransformModalState> = {}\n\nexport interface TransformModalStateShared {\n  showWizard: boolean\n  showOriginal: boolean\n}\n\nexport const transformModalStateShared: TransformModalStateShared = {\n  showWizard: true,\n  showOriginal: true\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","//@ts-ignore\nimport { arrow as arrowCore } from \"./core\";\nimport { autoUpdate as _autoUpdate, computePosition } from \"./dom/index.js\";\nimport { get } from \"svelte/store\";\nimport { onDestroy, tick } from 'svelte';\nexport function createFloatingActions(initOptions) {\n    let referenceElement;\n    let floatingElement;\n    const defaultOptions = {\n        autoUpdate: true\n    };\n    let options = initOptions;\n    const getOptions = (mixin) => {\n        return { ...defaultOptions, ...(initOptions || {}), ...(mixin || {}) };\n    };\n    const updatePosition = (updateOptions) => {\n        if (referenceElement && floatingElement) {\n            options = getOptions(updateOptions);\n            computePosition(referenceElement, floatingElement, options)\n                .then(v => {\n                Object.assign(floatingElement.style, {\n                    position: v.strategy,\n                    left: `${v.x}px`,\n                    top: `${v.y}px`,\n                });\n                options?.onComputed && options.onComputed(v);\n            });\n        }\n    };\n    const referenceAction = node => {\n        if ('subscribe' in node) {\n            setupVirtualElementObserver(node);\n            return {};\n        }\n        else {\n            referenceElement = node;\n            updatePosition();\n        }\n    };\n    const contentAction = (node, contentOptions) => {\n        let autoUpdateDestroy;\n        floatingElement = node;\n        options = getOptions(contentOptions);\n        setTimeout(() => updatePosition(contentOptions), 0); //tick doesn't work\n        updatePosition(contentOptions);\n        const destroyAutoUpdate = () => {\n            if (autoUpdateDestroy) {\n                autoUpdateDestroy();\n                autoUpdateDestroy = undefined;\n            }\n        };\n        const initAutoUpdate = ({ autoUpdate } = options || {}) => {\n            destroyAutoUpdate();\n            if (autoUpdate !== false) {\n                tick().then(() => {\n                    return _autoUpdate(referenceElement, floatingElement, () => updatePosition(options), (autoUpdate === true ? {} : autoUpdate));\n                });\n            }\n            return;\n        };\n        autoUpdateDestroy = initAutoUpdate();\n        return {\n            update(contentOptions) {\n                updatePosition(contentOptions);\n                autoUpdateDestroy = initAutoUpdate(contentOptions);\n            },\n            destroy() {\n                destroyAutoUpdate();\n            }\n        };\n    };\n    const setupVirtualElementObserver = (node) => {\n        const unsubscribe = node.subscribe(($node) => {\n            if (referenceElement === undefined) {\n                referenceElement = $node;\n                updatePosition();\n            }\n            else {\n                // Preserve the reference to the virtual element.\n                Object.assign(referenceElement, $node);\n                updatePosition();\n            }\n        });\n        onDestroy(unsubscribe);\n    };\n    return [\n        referenceAction,\n        contentAction,\n        updatePosition\n    ];\n}\nexport function arrow(options) {\n    return {\n        name: \"arrow\",\n        options,\n        fn(args) {\n            const element = get(options.element);\n            if (element) {\n                return arrowCore({\n                    element,\n                    padding: options.padding\n                }).fn(args);\n            }\n            return {};\n        }\n    };\n}\n","export default function filter({\n    loadOptions,\n    filterText,\n    items,\n    multiple,\n    value,\n    itemId,\n    groupBy,\n    filterSelectedItems,\n    itemFilter,\n    convertStringItemsToObjects,\n    filterGroupedItems,\n    label,\n}) {\n    if (items && loadOptions) return items;\n    if (!items) return [];\n\n    if (items && items.length > 0 && typeof items[0] !== 'object') {\n        items = convertStringItemsToObjects(items);\n    }\n\n    let filterResults = items.filter((item) => {\n        let matchesFilter = itemFilter(item[label], filterText, item);\n        if (matchesFilter && multiple && value?.length) {\n            matchesFilter = !value.some((x) => {\n                return filterSelectedItems ? x[itemId] === item[itemId] : false;\n            });\n        }\n\n        return matchesFilter;\n    });\n\n    if (groupBy) {\n        filterResults = filterGroupedItems(filterResults);\n    }\n\n    return filterResults;\n}\n","export default async function getItems({ dispatch, loadOptions, convertStringItemsToObjects, filterText }) {\n    let res = await loadOptions(filterText).catch((err) => {\n        console.warn('svelte-select loadOptions error :>> ', err);\n        dispatch('error', { type: 'loadOptions', details: err });\n    });\n\n    if (res && !res.cancelled) {        \n        if (res) {\n            if (res && res.length > 0 && typeof res[0] !== 'object') {\n                res = convertStringItemsToObjects(res);\n            }\n            \n            dispatch('loaded', { items: res });\n        } else {\n            res = [];\n        }\n\n        return {\n            filteredItems: res,\n            loading: false,\n            focused: true,\n            listOpen: true,\n        };\n    }\n}\n","<script>\n    import { beforeUpdate, createEventDispatcher, onDestroy, onMount } from 'svelte';\n    import { offset, flip, shift } from 'svelte-floating-ui/dom';\n    import { createFloatingActions } from 'svelte-floating-ui';\n\n    const dispatch = createEventDispatcher();\n\n    import _filter from './filter';\n    import _getItems from './get-items';\n\n    import ChevronIcon from './ChevronIcon.svelte';\n    import ClearIcon from './ClearIcon.svelte';\n    import LoadingIcon from './LoadingIcon.svelte';\n\n    export let justValue = null; // read-only\n\n    export let filter = _filter;\n    export let getItems = _getItems;\n\n    export let id = null;\n    export let name = null;\n    export let container = undefined;\n    export let input = undefined;\n    export let multiple = false;\n    export let multiFullItemClearable = false;\n    export let disabled = false;\n    export let focused = false;\n    export let value = null;\n    export let filterText = '';\n    export let placeholder = 'Please select';\n    export let placeholderAlwaysShow = false;\n    export let items = null;\n    export let label = 'label';\n    export let itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase());\n    export let groupBy = undefined;\n    export let groupFilter = (groups) => groups;\n    export let groupHeaderSelectable = false;\n    export let itemId = 'value';\n    export let loadOptions = undefined;\n    export let containerStyles = '';\n    export let hasError = false;\n    export let filterSelectedItems = true;\n    export let required = false;\n    export let closeListOnChange = true;\n    export let clearFilterTextOnBlur = true;\n\n    export let createGroupHeaderItem = (groupValue, item) => {\n        return {\n            value: groupValue,\n            [label]: groupValue,\n        };\n    };\n\n    export const getFilteredItems = () => {\n        return filteredItems;\n    };\n\n    export let searchable = true;\n    export let inputStyles = '';\n    export let clearable = true;\n    export let loading = false;\n    export let listOpen = false;\n\n    let timeout;\n    export let debounce = (fn, wait = 1) => {\n        clearTimeout(timeout);\n        timeout = setTimeout(fn, wait);\n    };\n\n    export let debounceWait = 300;\n    export let hideEmptyState = false;\n    export let inputAttributes = {};\n    export let listAutoWidth = true;\n    export let showChevron = false;\n    export let listOffset = 5;\n    export let hoverItemIndex = 0;\n    export let floatingConfig = {};\n\n    export { containerClasses as class };\n\n    let containerClasses = '';\n    let activeValue;\n    let prev_value;\n    let prev_filterText;\n    let prev_multiple;\n\n    function setValue() {\n        if (typeof value === 'string') {\n            let item = (items || []).find((item) => item[itemId] === value);\n            value = item || {\n                [itemId]: value,\n                label: value,\n            };\n        } else if (multiple && Array.isArray(value) && value.length > 0) {\n            value = value.map((item) => (typeof item === 'string' ? { value: item, label: item } : item));\n        }\n    }\n\n    let _inputAttributes;\n    function assignInputAttributes() {\n        _inputAttributes = Object.assign(\n            {\n                autocapitalize: 'none',\n                autocomplete: 'off',\n                autocorrect: 'off',\n                spellcheck: false,\n                tabindex: 0,\n                type: 'text',\n                'aria-autocomplete': 'list',\n            },\n            inputAttributes\n        );\n\n        if (id) {\n            _inputAttributes['id'] = id;\n        }\n\n        if (!searchable) {\n            _inputAttributes['readonly'] = true;\n        }\n    }\n\n    function convertStringItemsToObjects(_items) {\n        return _items.map((item, index) => {\n            return {\n                index,\n                value: item,\n                label: `${item}`,\n            };\n        });\n    }\n\n    function filterGroupedItems(_items) {\n        const groupValues = [];\n        const groups = {};\n\n        _items.forEach((item) => {\n            const groupValue = groupBy(item);\n\n            if (!groupValues.includes(groupValue)) {\n                groupValues.push(groupValue);\n                groups[groupValue] = [];\n\n                if (groupValue) {\n                    groups[groupValue].push(\n                        Object.assign(createGroupHeaderItem(groupValue, item), {\n                            id: groupValue,\n                            groupHeader: true,\n                            selectable: groupHeaderSelectable,\n                        })\n                    );\n                }\n            }\n\n            groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));\n        });\n\n        const sortedGroupedItems = [];\n\n        groupFilter(groupValues).forEach((groupValue) => {\n            if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);\n        });\n\n        return sortedGroupedItems;\n    }\n\n    function dispatchSelectedItem() {\n        if (multiple) {\n            if (JSON.stringify(value) !== JSON.stringify(prev_value)) {\n                if (checkValueForDuplicates()) {\n                    dispatch('input', value);\n                }\n            }\n            return;\n        }\n\n        if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {\n            dispatch('input', value);\n        }\n    }\n\n    function setupMulti() {\n        if (value) {\n            if (Array.isArray(value)) {\n                value = [...value];\n            } else {\n                value = [value];\n            }\n        }\n    }\n\n    function setupSingle() {\n        if (value) value = null;\n    }\n\n    $: if ((items, value)) setValue();\n    $: if (inputAttributes || !searchable) assignInputAttributes();\n    $: if (multiple) setupMulti();\n    $: if (prev_multiple && !multiple) setupSingle();\n    $: if (multiple && value && value.length > 1) checkValueForDuplicates();\n    $: if (value) dispatchSelectedItem();\n    $: if (!value && multiple && prev_value) dispatch('input', value);\n    $: if (!focused && input) closeList();\n    $: if (filterText !== prev_filterText) setupFilterText();\n    $: if (!multiple && listOpen && value && filteredItems) setValueIndexAsHoverIndex();\n    $: dispatchHover(hoverItemIndex);\n\n    function setValueIndexAsHoverIndex() {\n        const valueIndex = filteredItems.findIndex((i) => {\n            return i[itemId] === value[itemId];\n        });\n\n        checkHoverSelectable(valueIndex, true);\n    }\n\n    function dispatchHover(i) {\n        dispatch('hoverItem', i);\n    }\n\n    function checkHoverSelectable(startingIndex = 0, ignoreGroup) {\n        hoverItemIndex = startingIndex < 0 ? 0 : startingIndex;\n        if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {\n            setHoverIndex(1);\n        }\n    }\n\n    function setupFilterText() {\n        if (!loadOptions && filterText.length === 0) return;\n\n        if (loadOptions) {\n            debounce(async function () {\n                loading = true;\n                let res = await getItems({\n                    dispatch,\n                    loadOptions,\n                    convertStringItemsToObjects,\n                    filterText,\n                });\n\n                if (res) {\n                    loading = res.loading;\n                    listOpen = listOpen ? res.listOpen : filterText.length > 0 ? true : false;\n                    focused = listOpen && res.focused;\n                    items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems;\n                } else {\n                    loading = false;\n                    focused = true;\n                    listOpen = true;\n                }\n            }, debounceWait);\n        } else {\n            listOpen = true;\n\n            if (multiple) {\n                activeValue = undefined;\n            }\n        }\n    }\n\n    $: hasValue = multiple ? value && value.length > 0 : value;\n    $: hideSelectedItem = hasValue && filterText.length > 0;\n    $: showClear = hasValue && clearable && !disabled && !loading;\n    $: placeholderText =\n        placeholderAlwaysShow && multiple\n            ? placeholder\n            : multiple && value?.length === 0\n            ? placeholder\n            : value\n            ? ''\n            : placeholder;\n    $: ariaSelection = value ? handleAriaSelection(multiple) : '';\n    $: ariaContext = handleAriaContent({ filteredItems, hoverItemIndex, focused, listOpen });\n    $: updateValueDisplay(items);\n    $: justValue = computeJustValue(multiple, value, itemId);\n    $: if (!multiple && prev_value && !value) dispatch('input', value);\n    $: filteredItems = filter({\n        loadOptions,\n        filterText,\n        items,\n        multiple,\n        value,\n        itemId,\n        groupBy,\n        label,\n        filterSelectedItems,\n        itemFilter,\n        convertStringItemsToObjects,\n        filterGroupedItems,\n    });\n    $: if (listOpen && filteredItems && !multiple && !value) checkHoverSelectable();\n    $: handleFilterEvent(filteredItems);\n    $: if (container && floatingConfig) floatingUpdate(Object.assign(_floatingConfig, floatingConfig));\n    $: listDom = !!list;\n    $: listMounted(list, listOpen);\n    $: if (listOpen && container && list) setListWidth();\n    $: scrollToHoverItem = hoverItemIndex;\n    $: if (listOpen && multiple) hoverItemIndex = 0;\n    $: if (input && listOpen && !focused) handleFocus();\n    $: if (filterText) hoverItemIndex = 0;\n\n    function handleFilterEvent(items) {\n        if (listOpen) dispatch('filter', items);\n    }\n\n    beforeUpdate(async () => {\n        prev_value = value;\n        prev_filterText = filterText;\n        prev_multiple = multiple;\n    });\n\n    function computeJustValue() {\n        if (multiple) return value ? value.map((item) => item[itemId]) : null;\n        return value ? value[itemId] : value;\n    }\n\n    function checkValueForDuplicates() {\n        let noDuplicates = true;\n        if (value) {\n            const ids = [];\n            const uniqueValues = [];\n\n            value.forEach((val) => {\n                if (!ids.includes(val[itemId])) {\n                    ids.push(val[itemId]);\n                    uniqueValues.push(val);\n                } else {\n                    noDuplicates = false;\n                }\n            });\n\n            if (!noDuplicates) value = uniqueValues;\n        }\n        return noDuplicates;\n    }\n\n    function findItem(selection) {\n        let matchTo = selection ? selection[itemId] : value[itemId];\n        return items.find((item) => item[itemId] === matchTo);\n    }\n\n    function updateValueDisplay(items) {\n        if (!items || items.length === 0 || items.some((item) => typeof item !== 'object')) return;\n        if (!value || (multiple ? value.some((selection) => !selection || !selection[itemId]) : !value[itemId])) return;\n\n        if (Array.isArray(value)) {\n            value = value.map((selection) => findItem(selection) || selection);\n        } else {\n            value = findItem() || value;\n        }\n    }\n\n    async function handleMultiItemClear(i) {\n        const itemToRemove = value[i];\n\n        if (value.length === 1) {\n            value = undefined;\n        } else {\n            value = value.filter((item) => {\n                return item !== itemToRemove;\n            });\n        }\n\n        dispatch('clear', itemToRemove);\n    }\n\n    function handleKeyDown(e) {\n        if (!focused) return;\n        e.stopPropagation();\n        switch (e.key) {\n            case 'Escape':\n                e.preventDefault();\n                closeList();\n                break;\n            case 'Enter':\n                e.preventDefault();\n\n                if (listOpen) {\n                    if (filteredItems.length === 0) break;\n                    const hoverItem = filteredItems[hoverItemIndex];\n\n                    if (value && !multiple && value[itemId] === hoverItem[itemId]) {\n                        closeList();\n                        break;\n                    } else {\n                        handleSelect(filteredItems[hoverItemIndex]);\n                    }\n                }\n\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n\n                if (listOpen) {\n                    setHoverIndex(1);\n                } else {\n                    listOpen = true;\n                    activeValue = undefined;\n                }\n\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n\n                if (listOpen) {\n                    setHoverIndex(-1);\n                } else {\n                    listOpen = true;\n                    activeValue = undefined;\n                }\n\n                break;\n            case 'Tab':\n                if (listOpen && focused) {\n                    if (\n                        filteredItems.length === 0 ||\n                        (value && value[itemId] === filteredItems[hoverItemIndex][itemId])\n                    )\n                        return closeList();\n\n                    e.preventDefault();\n                    handleSelect(filteredItems[hoverItemIndex]);\n                    closeList();\n                }\n\n                break;\n            case 'Backspace':\n                if (!multiple || filterText.length > 0) return;\n\n                if (multiple && value && value.length > 0) {\n                    handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);\n                    if (activeValue === 0 || activeValue === undefined) break;\n                    activeValue = value.length > activeValue ? activeValue - 1 : undefined;\n                }\n\n                break;\n            case 'ArrowLeft':\n                if (!value || !multiple || filterText.length > 0) return;\n                if (activeValue === undefined) {\n                    activeValue = value.length - 1;\n                } else if (value.length > activeValue && activeValue !== 0) {\n                    activeValue -= 1;\n                }\n                break;\n            case 'ArrowRight':\n                if (!value || !multiple || filterText.length > 0 || activeValue === undefined) return;\n                if (activeValue === value.length - 1) {\n                    activeValue = undefined;\n                } else if (activeValue < value.length - 1) {\n                    activeValue += 1;\n                }\n                break;\n        }\n    }\n\n    function handleFocus(e) {\n        if (focused && input === document?.activeElement) return;\n        if (e) dispatch('focus', e);\n        input?.focus();\n        focused = true;\n    }\n\n    async function handleBlur(e) {\n        if (isScrolling) return;\n        if (listOpen || focused) {\n            dispatch('blur', e);\n            closeList();\n            focused = false;\n            activeValue = undefined;\n            input?.blur();\n        }\n    }\n\n    function handleClick() {\n        if (disabled) return;\n        if (filterText.length > 0) return listOpen = true;\n        listOpen = !listOpen;\n    }\n\n    export function handleClear() {\n        dispatch('clear', value);\n        value = undefined;\n        closeList();\n        handleFocus();\n    }\n\n    onMount(() => {\n        if (listOpen) focused = true;\n        if (focused && input) input.focus();\n    });\n\n    function itemSelected(selection) {\n        if (selection) {\n            filterText = '';\n            const item = Object.assign({}, selection);\n\n            if (item.groupHeader && !item.selectable) return;\n            value = multiple ? (value ? value.concat([item]) : [item]) : (value = item);\n\n            setTimeout(() => {\n                if (closeListOnChange) closeList();\n                activeValue = undefined;\n                dispatch('change', value);\n                dispatch('select', selection);\n            });\n        }\n    }\n\n    function closeList() {\n        if (clearFilterTextOnBlur) {\n            filterText = '';\n        }\n        listOpen = false;\n    }\n\n    export let ariaValues = (values) => {\n        return `Option ${values}, selected.`;\n    };\n\n    export let ariaListOpen = (label, count) => {\n        return `You are currently focused on option ${label}. There are ${count} results available.`;\n    };\n\n    export let ariaFocused = () => {\n        return `Select is focused, type to refine list, press down to open the menu.`;\n    };\n\n    function handleAriaSelection(_multiple) {\n        let selected = undefined;\n\n        if (_multiple && value.length > 0) {\n            selected = value.map((v) => v[label]).join(', ');\n        } else {\n            selected = value[label];\n        }\n\n        return ariaValues(selected);\n    }\n\n    function handleAriaContent() {\n        if (!filteredItems || filteredItems.length === 0) return '';\n        let _item = filteredItems[hoverItemIndex];\n        if (listOpen && _item) {\n            let count = filteredItems ? filteredItems.length : 0;\n            return ariaListOpen(_item[label], count);\n        } else {\n            return ariaFocused();\n        }\n    }\n\n    let list = null;\n\n    let isScrollingTimer;\n    function handleListScroll() {\n        clearTimeout(isScrollingTimer);\n        isScrollingTimer = setTimeout(() => {\n            isScrolling = false;\n        }, 100);\n    }\n\n    function handleClickOutside(event) {\n        if (!listOpen && !focused && container && !container.contains(event.target) && !list?.contains(event.target)) {\n            handleBlur();\n        }\n    }\n\n    onDestroy(() => {\n        list?.remove();\n    });\n\n    let isScrolling = false;\n\n    function handleSelect(item) {\n        if (!item || item.selectable === false) return;\n        itemSelected(item);\n    }\n\n    function handleHover(i) {\n        if (isScrolling) return;\n        hoverItemIndex = i;\n    }\n\n    function handleItemClick(args) {\n        const { item, i } = args;\n        if (item?.selectable === false) return;\n        if (value && !multiple && value[itemId] === item[itemId]) return closeList();\n        if (isItemSelectable(item)) {\n            hoverItemIndex = i;\n            handleSelect(item);\n        }\n    }\n\n    function setHoverIndex(increment) {\n        let selectableFilteredItems = filteredItems.filter(\n            (item) => !Object.hasOwn(item, 'selectable') || item.selectable === true\n        );\n\n        if (selectableFilteredItems.length === 0) {\n            return (hoverItemIndex = 0);\n        }\n\n        if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {\n            hoverItemIndex = 0;\n        } else if (increment < 0 && hoverItemIndex === 0) {\n            hoverItemIndex = filteredItems.length - 1;\n        } else {\n            hoverItemIndex = hoverItemIndex + increment;\n        }\n\n        const hover = filteredItems[hoverItemIndex];\n\n        if (hover && hover.selectable === false) {\n            if (increment === 1 || increment === -1) setHoverIndex(increment);\n            return;\n        }\n    }\n\n    function isItemActive(item, value, itemId) {\n        if (multiple) return;\n        return value && value[itemId] === item[itemId];\n    }\n\n    function isItemFirst(itemIndex) {\n        return itemIndex === 0;\n    }\n\n    function isItemSelectable(item) {\n        return (item.groupHeader && item.selectable) || item.selectable || !item.hasOwnProperty('selectable');\n    }\n\n    const activeScroll = scrollAction;\n    const hoverScroll = scrollAction;\n\n    function scrollAction(node) {\n        return {\n            update(args) {\n                if (args.scroll) {\n                    handleListScroll();\n                    node.scrollIntoView({ behavior: 'auto', block: 'nearest' });\n                }\n            },\n        };\n    }\n\n    function setListWidth() {\n        const { width } = container.getBoundingClientRect();\n        list.style.width = listAutoWidth ? width + 'px' : 'auto';\n    }\n\n    let _floatingConfig = {\n        strategy: 'absolute',\n        placement: 'bottom-start',\n        middleware: [offset(listOffset), flip(), shift()],\n        autoUpdate: false,\n    };\n\n    const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(_floatingConfig);\n\n    $: if (container && floatingConfig?.autoUpdate === undefined) {\n        _floatingConfig.autoUpdate = true;\n    }\n\n    let prefloat = true;\n    function listMounted(list, listOpen) {\n        if (!list || !listOpen) return (prefloat = true);\n        setTimeout(() => {\n            prefloat = false;\n        }, 0);\n    }\n</script>\n\n<svelte:window on:click={handleClickOutside} on:keydown={handleKeyDown} />\n\n<div\n    class=\"svelte-select {containerClasses}\"\n    class:multi={multiple}\n    class:disabled\n    class:focused\n    class:list-open={listOpen}\n    class:show-chevron={showChevron}\n    class:error={hasError}\n    style={containerStyles}\n    on:pointerup|preventDefault={handleClick}\n    bind:this={container}\n    use:floatingRef\n    role=\"none\">\n    {#if listOpen}\n        <div\n            use:floatingContent\n            bind:this={list}\n            class=\"svelte-select-list\"\n            class:prefloat\n            on:scroll={handleListScroll}\n            on:pointerup|preventDefault|stopPropagation\n            on:mousedown|preventDefault|stopPropagation\n\t\t\trole=\"none\">\n            {#if $$slots['list-prepend']}<slot name=\"list-prepend\" />{/if}\n            {#if $$slots.list}<slot name=\"list\" {filteredItems} />\n            {:else if filteredItems.length > 0}\n                {#each filteredItems as item, i}\n                    <div\n                        on:mouseover={() => handleHover(i)}\n                        on:focus={() => handleHover(i)}\n                        on:click|stopPropagation={() => handleItemClick({ item, i })}\n                        on:keydown|preventDefault|stopPropagation\n                        class=\"list-item\"\n                        tabindex=\"-1\"\n                        role=\"none\">\n                        <div\n                            use:activeScroll={{ scroll: isItemActive(item, value, itemId), listDom }}\n                            use:hoverScroll={{ scroll: scrollToHoverItem === i, listDom }}\n                            class=\"item\"\n                            class:list-group-title={item.groupHeader}\n                            class:active={isItemActive(item, value, itemId)}\n                            class:first={isItemFirst(i)}\n                            class:hover={hoverItemIndex === i}\n                            class:group-item={item.groupItem}\n                            class:not-selectable={item?.selectable === false}>\n                            <slot name=\"item\" {item} index={i}>\n                                {item?.[label]}\n                            </slot>\n                        </div>\n                    </div>\n                {/each}\n            {:else if !hideEmptyState}\n                <slot name=\"empty\">\n                    <div class=\"empty\">No options</div>\n                </slot>\n            {/if}\n            {#if $$slots['list-append']}<slot name=\"list-append\" />{/if}\n        </div>\n    {/if}\n\n    <span aria-live=\"polite\" aria-atomic=\"false\" aria-relevant=\"additions text\" class=\"a11y-text\">\n        {#if focused}\n            <span id=\"aria-selection\">{ariaSelection}</span>\n            <span id=\"aria-context\">\n                {ariaContext}\n            </span>\n        {/if}\n    </span>\n\n    <div class=\"prepend\">\n        <slot name=\"prepend\" />\n    </div>\n\n    <div class=\"value-container\">\n        {#if hasValue}\n            {#if multiple}\n                {#each value as item, i}\n                    <div\n                        class=\"multi-item\"\n                        class:active={activeValue === i}\n                        class:disabled\n                        on:click|preventDefault={() => (multiFullItemClearable ? handleMultiItemClear(i) : {})}\n                        on:keydown|preventDefault|stopPropagation\n                        role=\"none\">\n                        <span class=\"multi-item-text\">\n                            <slot name=\"selection\" selection={item} index={i}>\n                                {item[label]}\n                            </slot>\n                        </span>\n\n                        {#if !disabled && !multiFullItemClearable && ClearIcon}\n                            <div\n                                class=\"multi-item-clear\"\n                                on:pointerup|preventDefault|stopPropagation={() => handleMultiItemClear(i)}>\n                                <slot name=\"multi-clear-icon\">\n                                    <ClearIcon />\n                                </slot>\n                            </div>\n                        {/if}\n                    </div>\n                {/each}\n            {:else}\n                <div class=\"selected-item\" class:hide-selected-item={hideSelectedItem}>\n                    <slot name=\"selection\" selection={value}>\n                        {value[label]}\n                    </slot>\n                </div>\n            {/if}\n        {/if}\n\n        <input\n            on:keydown={handleKeyDown}\n            on:blur={handleBlur}\n            on:focus={handleFocus}\n            readOnly={!searchable}\n            {..._inputAttributes}\n            bind:this={input}\n            bind:value={filterText}\n            placeholder={placeholderText}\n            style={inputStyles}\n            {disabled} />\n    </div>\n\n    <div class=\"indicators\">\n        {#if loading}\n            <div class=\"icon loading\" aria-hidden=\"true\">\n                <slot name=\"loading-icon\">\n                    <LoadingIcon />\n                </slot>\n            </div>\n        {/if}\n\n        {#if showClear}\n            <button type=\"button\" class=\"icon clear-select\" on:click={handleClear}>\n                <slot name=\"clear-icon\">\n                    <ClearIcon />\n                </slot>\n            </button>\n        {/if}\n\n        {#if showChevron}\n            <div class=\"icon chevron\" aria-hidden=\"true\">\n                <slot name=\"chevron-icon\" {listOpen}>\n                    <ChevronIcon />\n                </slot>\n            </div>\n        {/if}\n    </div>\n\n    <slot name=\"input-hidden\" {value}>\n        <input {name} type=\"hidden\" value={value ? JSON.stringify(value) : null} />\n    </slot>\n\n    {#if required && (!value || value.length === 0)}\n        <slot name=\"required\" {value}>\n            <select class=\"required\" required tabindex=\"-1\" aria-hidden=\"true\" />\n        </slot>\n    {/if}\n</div>\n\n<style>\n    .svelte-select {\n        /* deprecating camelCase custom props in favour of kebab-case for v5 */\n        --borderRadius: var(--border-radius);\n        --clearSelectColor: var(--clear-select-color);\n        --clearSelectWidth: var(--clear-select-width);\n        --disabledBackground: var(--disabled-background);\n        --disabledBorderColor: var(--disabled-border-color);\n        --disabledColor: var(--disabled-color);\n        --disabledPlaceholderColor: var(--disabled-placeholder-color);\n        --disabledPlaceholderOpacity: var(--disabled-placeholder-opacity);\n        --errorBackground: var(--error-background);\n        --errorBorder: var(--error-border);\n        --groupItemPaddingLeft: var(--group-item-padding-left);\n        --groupTitleColor: var(--group-title-color);\n        --groupTitleFontSize: var(--group-title-font-size);\n        --groupTitleFontWeight: var(--group-title-font-weight);\n        --groupTitlePadding: var(--group-title-padding);\n        --groupTitleTextTransform: var(--group-title-text-transform);\n        --groupTitleBorderColor: var(--group-title-border-color);\n        --groupTitleBorderWidth: var(--group-title-border-width);\n        --groupTitleBorderStyle: var(--group-title-border-style);\n        --indicatorColor: var(--chevron-color);\n        --indicatorHeight: var(--chevron-height);\n        --indicatorWidth: var(--chevron-width);\n        --inputColor: var(--input-color);\n        --inputLeft: var(--input-left);\n        --inputLetterSpacing: var(--input-letter-spacing);\n        --inputMargin: var(--input-margin);\n        --inputPadding: var(--input-padding);\n        --itemActiveBackground: var(--item-active-background);\n        --itemColor: var(--item-color);\n        --itemFirstBorderRadius: var(--item-first-border-radius);\n        --itemHoverBG: var(--item-hover-bg);\n        --itemHoverColor: var(--item-hover-color);\n        --itemIsActiveBG: var(--item-is-active-bg);\n        --itemIsActiveColor: var(--item-is-active-color);\n        --itemIsNotSelectableColor: var(--item-is-not-selectable-color);\n        --itemPadding: var(--item-padding);\n        --listBackground: var(--list-background);\n        --listBorder: var(--list-border);\n        --listBorderRadius: var(--list-border-radius);\n        --listEmptyColor: var(--list-empty-color);\n        --listEmptyPadding: var(--list-empty-padding);\n        --listEmptyTextAlign: var(--list-empty-text-align);\n        --listMaxHeight: var(--list-max-height);\n        --listPosition: var(--list-position);\n        --listShadow: var(--list-shadow);\n        --listZIndex: var(--list-z-index);\n        --multiItemBG: var(--multi-item-bg);\n        --multiItemBorderRadius: var(--multi-item-border-radius);\n        --multiItemDisabledHoverBg: var(--multi-item-disabled-hover-bg);\n        --multiItemDisabledHoverColor: var(--multi-item-disabled-hover-color);\n        --multiItemHeight: var(--multi-item-height);\n        --multiItemMargin: var(--multi-item-margin);\n        --multiItemPadding: var(--multi-item-padding);\n        --multiSelectInputMargin: var(--multi-select-input-margin);\n        --multiSelectInputPadding: var(--multi-select-input-padding);\n        --multiSelectPadding: var(--multi-select-padding);\n        --placeholderColor: var(--placeholder-color);\n        --placeholderOpacity: var(--placeholder-opacity);\n        --selectedItemPadding: var(--selected-item-padding);\n        --spinnerColor: var(--spinner-color);\n        --spinnerHeight: var(--spinner-height);\n        --spinnerWidth: var(--spinner-width);\n\n        --internal-padding: 0 0 0 16px;\n\n        border: var(--border, 1px solid #d8dbdf);\n        border-radius: var(--border-radius, 6px);\n        min-height: var(--height, 42px);\n        position: relative;\n        display: flex;\n        align-items: stretch;\n        padding: var(--padding, var(--internal-padding));\n        background: var(--background, #fff);\n        margin: var(--margin, 0);\n        width: var(--width, 100%);\n        font-size: var(--font-size, 16px);\n        max-height: var(--max-height);\n    }\n\n    * {\n        box-sizing: var(--box-sizing, border-box);\n    }\n\n    .svelte-select:hover {\n        border: var(--border-hover, 1px solid #b2b8bf);\n    }\n\n    .value-container {\n        display: flex;\n        flex: 1 1 0%;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: 5px 10px;\n        padding: var(--value-container-padding, 5px 0);\n        position: relative;\n        overflow: var(--value-container-overflow, hidden);\n        align-self: stretch;\n    }\n\n    .prepend,\n    .indicators {\n        display: flex;\n        flex-shrink: 0;\n        align-items: center;\n    }\n\n    .indicators {\n        position: var(--indicators-position);\n        top: var(--indicators-top);\n        right: var(--indicators-right);\n        bottom: var(--indicators-bottom);\n    }\n\n    input {\n        position: absolute;\n        cursor: default;\n        border: none;\n        color: var(--input-color, var(--item-color));\n        padding: var(--input-padding, 0);\n        letter-spacing: var(--input-letter-spacing, inherit);\n        margin: var(--input-margin, 0);\n        min-width: 10px;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background: transparent;\n        font-size: var(--font-size, 16px);\n    }\n\n    :not(.multi) > .value-container > input {\n        width: 100%;\n        height: 100%;\n    }\n\n    input::placeholder {\n        color: var(--placeholder-color, #78848f);\n        opacity: var(--placeholder-opacity, 1);\n    }\n\n    input:focus {\n        outline: none;\n    }\n\n    .svelte-select.focused {\n        border: var(--border-focused, 1px solid #006fe8);\n        border-radius: var(--border-radius-focused, var(--border-radius, 6px));\n    }\n\n    .disabled {\n        background: var(--disabled-background, #ebedef);\n        border-color: var(--disabled-border-color, #ebedef);\n        color: var(--disabled-color, #c1c6cc);\n    }\n\n    .disabled input::placeholder {\n        color: var(--disabled-placeholder-color, #c1c6cc);\n        opacity: var(--disabled-placeholder-opacity, 1);\n    }\n\n    .selected-item {\n        position: relative;\n        overflow: var(--selected-item-overflow, hidden);\n        padding: var(--selected-item-padding, 0 20px 0 0);\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        color: var(--selected-item-color, inherit);\n        font-size: var(--font-size, 16px);\n    }\n\n    .multi .selected-item {\n        position: absolute;\n        line-height: var(--height, 42px);\n        height: var(--height, 42px);\n    }\n\n    .selected-item:focus {\n        outline: none;\n    }\n\n    .hide-selected-item {\n        opacity: 0;\n    }\n\n    .icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .clear-select {\n        all: unset;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: var(--clear-select-width, 40px);\n        height: var(--clear-select-height, 100%);\n        color: var(--clear-select-color, var(--icons-color));\n        margin: var(--clear-select-margin, 0);\n        pointer-events: all;\n        flex-shrink: 0;\n    }\n\n    .clear-select:focus {\n        outline: var(--clear-select-focus-outline, 1px solid #006fe8);\n    }\n\n    .loading {\n        width: var(--loading-width, 40px);\n        height: var(--loading-height);\n        color: var(--loading-color, var(--icons-color));\n        margin: var(--loading--margin, 0);\n        flex-shrink: 0;\n    }\n\n    .chevron {\n        width: var(--chevron-width, 40px);\n        height: var(--chevron-height, 40px);\n        background: var(--chevron-background, transparent);\n        pointer-events: var(--chevron-pointer-events, none);\n        color: var(--chevron-color, var(--icons-color));\n        border: var(--chevron-border, 0 0 0 1px solid #d8dbdf);\n        flex-shrink: 0;\n    }\n\n    .multi {\n        padding: var(--multi-select-padding, var(--internal-padding));\n    }\n\n    .multi input {\n        padding: var(--multi-select-input-padding, 0);\n        position: relative;\n        margin: var(--multi-select-input-margin, 5px 0);\n        flex: 1 1 40px;\n    }\n\n    .svelte-select.error {\n        border: var(--error-border, 1px solid #ff2d55);\n        background: var(--error-background, #fff);\n    }\n\n    .a11y-text {\n        z-index: 9999;\n        border: 0px;\n        clip: rect(1px, 1px, 1px, 1px);\n        height: 1px;\n        width: 1px;\n        position: absolute;\n        overflow: hidden;\n        padding: 0px;\n        white-space: nowrap;\n    }\n\n    .multi-item {\n        background: var(--multi-item-bg, #ebedef);\n        margin: var(--multi-item-margin, 0);\n        outline: var(--multi-item-outline, 1px solid #ddd);\n        border-radius: var(--multi-item-border-radius, 4px);\n        height: var(--multi-item-height, 25px);\n        line-height: var(--multi-item-height, 25px);\n        display: flex;\n        cursor: default;\n        padding: var(--multi-item-padding, 0 5px);\n        overflow: hidden;\n        gap: var(--multi-item-gap, 4px);\n        outline-offset: -1px;\n        max-width: var(--multi-max-width, none);\n        color: var(--multi-item-color, var(--item-color));\n    }\n\n    .multi-item.disabled:hover {\n        background: var(--multi-item-disabled-hover-bg, #ebedef);\n        color: var(--multi-item-disabled-hover-color, #c1c6cc);\n    }\n\n    .multi-item-text {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n    }\n\n    .multi-item-clear {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        --clear-icon-color: var(--multi-item-clear-icon-color, #000);\n    }\n\n    .multi-item.active {\n        outline: var(--multi-item-active-outline, 1px solid #006fe8);\n    }\n\n    .svelte-select-list {\n        box-shadow: var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));\n        border-radius: var(--list-border-radius, 4px);\n        max-height: var(--list-max-height, 252px);\n        overflow-y: auto;\n        background: var(--list-background, #fff);\n        position: var(--list-position, absolute);\n        z-index: var(--list-z-index, 2);\n        border: var(--list-border);\n    }\n\n    .prefloat {\n        opacity: 0;\n        pointer-events: none;\n    }\n\n    .list-group-title {\n        color: var(--group-title-color, #8f8f8f);\n        cursor: default;\n        font-size: var(--group-title-font-size, 16px);\n        font-weight: var(--group-title-font-weight, 600);\n        height: var(--height, 42px);\n        line-height: var(--height, 42px);\n        padding: var(--group-title-padding, 0 20px);\n        text-overflow: ellipsis;\n        overflow-x: hidden;\n        white-space: nowrap;\n        text-transform: var(--group-title-text-transform, uppercase);\n        border-width: var(--group-title-border-width, medium);\n        border-style: var(--group-title-border-style, none);\n        border-color: var(--group-title-border-color, color);\n    }\n\n    .empty {\n        text-align: var(--list-empty-text-align, center);\n        padding: var(--list-empty-padding, 20px 0);\n        color: var(--list-empty-color, #78848f);\n    }\n\n    .item {\n        cursor: default;\n        height: var(--item-height, var(--height, 42px));\n        line-height: var(--item-line-height, var(--height, 42px));\n        padding: var(--item-padding, 0 20px);\n        color: var(--item-color, inherit);\n        text-overflow: ellipsis;\n        overflow: hidden;\n        white-space: nowrap;\n        transition: var(--item-transition, all 0.2s);\n        align-items: center;\n        width: 100%;\n    }\n\n    .item.group-item {\n        padding-left: var(--group-item-padding-left, 40px);\n    }\n\n    .item:active {\n        background: var(--item-active-background, #b9daff);\n    }\n\n    .item.active {\n        background: var(--item-is-active-bg, #007aff);\n        color: var(--item-is-active-color, #fff);\n    }\n\n    .item.first {\n        border-radius: var(--item-first-border-radius, 4px 4px 0 0);\n    }\n\n    .item.hover:not(.active) {\n        background: var(--item-hover-bg, #e7f2ff);\n        color: var(--item-hover-color, inherit);\n    }\n\n    .item.not-selectable,\n    .item.hover.item.not-selectable,\n    .item.active.item.not-selectable,\n    .item.not-selectable:active {\n        color: var(--item-is-not-selectable-color, #999);\n        background: transparent;\n    }\n\n    .required {\n        opacity: 0;\n        z-index: -1;\n        position: absolute;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n    }\n</style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Select from 'svelte-select'\n  import { getNestedPaths } from '$lib/utils/arrayUtils.js'\n  import { pathToOption } from '$lib/utils/pathUtils.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { isEqual } from 'lodash-es'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { setIn } from 'immutable-json-patch'\n  import type { PathOption, QueryLanguageOptions } from '$lib/types.js'\n\n  const debug = createDebug('jsoneditor:TransformWizard')\n\n  export let json: unknown\n  export let queryOptions: QueryLanguageOptions = {}\n  export let onChange: (queryOptions: QueryLanguageOptions) => void\n\n  // options\n  $: jsonIsArray = Array.isArray(json)\n  $: paths = jsonIsArray ? getNestedPaths(json) : []\n  $: pathsIncludingObjects = jsonIsArray ? getNestedPaths(json, true) : []\n  $: fieldOptions = paths.map(pathToOption)\n  $: projectionOptions = pathsIncludingObjects ? pathsIncludingObjects.map(pathToOption) : []\n\n  const filterRelationOptions = ['==', '!=', '<', '<=', '>', '>='].map((relation) => ({\n    value: relation,\n    label: relation\n  }))\n\n  const sortDirectionOptions = [\n    { value: 'asc', label: 'ascending' },\n    { value: 'desc', label: 'descending' }\n  ]\n\n  // TODO: the binding with the select boxes is very cumbersome. Can we simplify this?\n  let filterPath = queryOptions?.filter?.path ? pathToOption(queryOptions.filter.path) : undefined\n  let filterRelation =\n    filterRelationOptions.find((option) => option.value === queryOptions.filter?.relation) ??\n    filterRelationOptions[0]\n  let filterValue = queryOptions?.filter?.value || ''\n  let sortPath = queryOptions?.sort?.path ? pathToOption(queryOptions.sort.path) : undefined\n  let sortDirection =\n    sortDirectionOptions.find((option) => option.value === queryOptions.sort?.direction) ??\n    sortDirectionOptions[0]\n\n  $: projectionPaths =\n    queryOptions?.projection?.paths && projectionOptions\n      ? (queryOptions.projection.paths\n          .map((path) => projectionOptions.find((option) => isEqual(option.value, path)))\n          .filter((option) => !!option) as PathOption[])\n      : undefined\n\n  function changeFilterPath(path: JSONPath | undefined) {\n    if (!isEqual(queryOptions?.filter?.path, path)) {\n      debug('changeFilterPath', path)\n      queryOptions = setIn(queryOptions, ['filter', 'path'], path, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeFilterRelation(relation: string | undefined) {\n    if (!isEqual(queryOptions?.filter?.relation, relation)) {\n      debug('changeFilterRelation', relation)\n      queryOptions = setIn(queryOptions, ['filter', 'relation'], relation, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeFilterValue(value: string | undefined) {\n    if (!isEqual(queryOptions?.filter?.value, value)) {\n      debug('changeFilterValue', value)\n      queryOptions = setIn(queryOptions, ['filter', 'value'], value, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeSortPath(path: JSONPath | undefined) {\n    if (!isEqual(queryOptions?.sort?.path, path)) {\n      debug('changeSortPath', path)\n      queryOptions = setIn(queryOptions, ['sort', 'path'], path, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeSortDirection(direction: string | undefined) {\n    if (!isEqual(queryOptions?.sort?.direction, direction)) {\n      debug('changeSortDirection', direction)\n      queryOptions = setIn(queryOptions, ['sort', 'direction'], direction, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeProjectionPaths(paths: JSONPath[] | unknown) {\n    if (!isEqual(queryOptions?.projection?.paths, paths)) {\n      debug('changeProjectionPaths', paths)\n      queryOptions = setIn(queryOptions, ['projection', 'paths'], paths, true)\n      onChange(queryOptions)\n    }\n  }\n\n  $: changeFilterPath(filterPath?.value)\n  $: changeFilterRelation(filterRelation?.value)\n  $: changeFilterValue(filterValue)\n  $: changeSortPath(sortPath?.value)\n  $: changeSortDirection(sortDirection?.value)\n  $: changeProjectionPaths(projectionPaths ? projectionPaths.map((item) => item.value) : undefined)\n</script>\n\n<table class=\"jse-transform-wizard\">\n  <tbody>\n    <tr>\n      <th>Filter</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select\n            class=\"jse-filter-path\"\n            showChevron\n            items={fieldOptions}\n            bind:value={filterPath}\n          />\n          <Select\n            class=\"jse-filter-relation\"\n            showChevron\n            clearable={false}\n            items={filterRelationOptions}\n            bind:value={filterRelation}\n          />\n          <input class=\"jse-filter-value\" bind:value={filterValue} />\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th>Sort</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select class=\"jse-sort-path\" showChevron items={fieldOptions} bind:value={sortPath} />\n          <Select\n            class=\"jse-sort-direction\"\n            showChevron\n            clearable={false}\n            items={sortDirectionOptions}\n            bind:value={sortDirection}\n          />\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th>Pick</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select\n            class=\"jse-projection-paths\"\n            multiple\n            showChevron\n            items={projectionOptions}\n            bind:value={projectionPaths}\n          />\n        </div>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<style src=\"./TransformWizard.scss\"></style>\n","<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faCheckSquare, faSquare } from '@fortawesome/free-regular-svg-icons'\n  import type { QueryLanguage, OnChangeQueryLanguage } from '$lib/types.js'\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n  }\n</script>\n\n<div class=\"jse-select-query-language\">\n  <div class=\"jse-select-query-language-container\">\n    {#each queryLanguages as queryLanguage}\n      <button\n        type=\"button\"\n        on:click={() => handleChangeQueryLanguage(queryLanguage.id)}\n        class=\"jse-query-language\"\n        class:selected={queryLanguage.id === queryLanguageId}\n        title={`Select ${queryLanguage.name} as query language`}\n      >\n        {#if queryLanguage.id === queryLanguageId}\n          <Icon data={faCheckSquare} />\n        {:else}\n          <Icon data={faSquare} />\n        {/if}\n        {queryLanguage.name}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./SelectQueryLanguage.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import {\n    faDownLeftAndUpRightToCenter,\n    faTimes,\n    faUpRightAndDownLeftFromCenter\n  } from '@fortawesome/free-solid-svg-icons'\n\n  export let title = 'Modal'\n  export let fullScreenButton: boolean = false\n  export let fullscreen: boolean = false\n  export let onClose: (() => void) | undefined = undefined\n</script>\n\n<div class=\"jse-header\">\n  <div class=\"jse-title\">\n    {title}\n  </div>\n  <slot name=\"actions\" />\n  {#if fullScreenButton}\n    <button\n      type=\"button\"\n      class=\"jse-fullscreen\"\n      title=\"Toggle full screen\"\n      on:click={() => (fullscreen = !fullscreen)}\n    >\n      <Icon data={fullscreen ? faDownLeftAndUpRightToCenter : faUpRightAndDownLeftFromCenter} />\n    </button>\n  {/if}\n  <button type=\"button\" class=\"jse-close\" on:click={() => onClose?.()}>\n    <Icon data={faTimes} />\n  </button>\n</div>\n\n<style src=\"./Header.scss\"></style>\n","import { createDebug } from '$lib/utils/debug.js'\nimport {\n  AUTO_SCROLL_INTERVAL,\n  AUTO_SCROLL_SPEED_FAST,\n  AUTO_SCROLL_SPEED_NORMAL,\n  AUTO_SCROLL_SPEED_SLOW\n} from '$lib/constants.js'\n\nconst debug = createDebug('jsoneditor:AutoScrollHandler')\n\nexport function createAutoScrollHandler(scrollableElement: Element) {\n  debug('createAutoScrollHandler', scrollableElement)\n\n  let autoScrollSpeed: number | undefined // pixels per second\n  let autoScrollTimer: number | undefined\n\n  function calculateSpeed(diff: number) {\n    return diff < 20\n      ? AUTO_SCROLL_SPEED_SLOW\n      : diff < 50\n        ? AUTO_SCROLL_SPEED_NORMAL\n        : AUTO_SCROLL_SPEED_FAST\n  }\n\n  function autoScrollCallback() {\n    if (scrollableElement) {\n      // debug('auto scroll...')\n      const diff = (autoScrollSpeed || 0) * (AUTO_SCROLL_INTERVAL / 1000)\n\n      scrollableElement.scrollTop += diff\n    }\n  }\n\n  function startAutoScroll(speed: number) {\n    if (!autoScrollTimer || speed !== autoScrollSpeed) {\n      stopAutoScroll()\n\n      debug('startAutoScroll', speed)\n      autoScrollSpeed = speed\n      autoScrollTimer = setInterval(autoScrollCallback, AUTO_SCROLL_INTERVAL) as unknown as number\n    }\n  }\n\n  function stopAutoScroll() {\n    if (autoScrollTimer) {\n      debug('stopAutoScroll')\n\n      clearInterval(autoScrollTimer)\n      autoScrollTimer = undefined\n      autoScrollSpeed = undefined\n    }\n  }\n\n  function onDrag(event: MouseEvent) {\n    if (scrollableElement) {\n      const y = event.clientY\n      const { top, bottom } = scrollableElement.getBoundingClientRect()\n\n      if (y < top) {\n        const speed = calculateSpeed(top - y)\n        startAutoScroll(-speed)\n      } else if (y > bottom) {\n        const speed = calculateSpeed(y - bottom)\n        startAutoScroll(speed)\n      } else {\n        stopAutoScroll()\n      }\n    }\n  }\n\n  function onDragEnd() {\n    stopAutoScroll()\n  }\n\n  return {\n    onDrag,\n    onDragEnd\n  }\n}\n","// Robert Penner's easeInOutQuad\n\n// find the rest of his easing functions here: http://robertpenner.com/easing/\n// find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js\n\nexport default (t: number, b: number, c: number, d: number): number => {\n  t /= d / 2\n  if (t < 1) {\n    return (c / 2) * t * t + b\n  }\n  t--\n  return (-c / 2) * (t * (t - 2) - 1) + b\n}\n","import easeInOutQuad from './easing.js'\n\ntype Easing = (t: number, b: number, c: number, d: number) => number\ntype Duration = number | ((distance: number) => number)\n\ninterface JumpOptions {\n  duration?: Duration\n  offset?: number\n  callback?: () => void\n  easing?: Easing\n  a11y?: boolean\n  container?: Element | string\n}\n\nexport const createJump = () => {\n  // private variable cache\n  // no variables are created during a jump, preventing memory leaks\n\n  let container: Element // container element to be scrolled       (node)\n  let element: Element | undefined // element to scroll to                   (node)\n\n  let start: number // where scroll starts                    (px)\n  let stop: number // where scroll stops                     (px)\n\n  let offset // adjustment from the stop position      (px)\n  let easing: Easing // easing function                        (function)\n  let a11y: boolean // accessibility support flag             (boolean)\n\n  let distance: number // distance of scroll                     (px)\n  let duration: number // scroll duration                        (ms)\n\n  let timeStart: number // time scroll started                    (ms)\n  let timeElapsed: number // time spent scrolling thus far          (ms)\n\n  let next: number // next scroll position                   (px)\n\n  let callback: (() => void) | undefined // to call when done scrolling            (function)\n\n  let scrolling: boolean // true whilst scrolling                  (boolean)\n\n  // scroll position helper\n\n  function location() {\n    return container.scrollTop\n  }\n\n  // element offset helper\n\n  function top(element: Element) {\n    const elementTop = element.getBoundingClientRect().top\n    const containerTop = container.getBoundingClientRect ? container.getBoundingClientRect().top : 0\n\n    return elementTop - containerTop + start\n  }\n\n  // scrollTo helper\n\n  function scrollTo(top: number) {\n    if (container.scrollTo) {\n      container.scrollTo(container.scrollLeft, top) // window\n    } else {\n      container.scrollTop = top // custom container\n    }\n  }\n\n  // rAF loop helper\n\n  function loop(timeCurrent: number) {\n    // store time scroll started, if not started already\n    if (!timeStart) {\n      timeStart = timeCurrent\n    }\n\n    // determine time spent scrolling so far\n    timeElapsed = timeCurrent - timeStart\n\n    // calculate next scroll position\n    next = easing(timeElapsed, start, distance, duration)\n\n    // scroll to it\n    scrollTo(next)\n\n    scrolling = true\n\n    // check progress\n    if (timeElapsed < duration) {\n      requestAnimationFrame(loop) // continue scroll loop\n    } else {\n      done() // scrolling is done\n    }\n  }\n\n  // scroll finished helper\n\n  function done() {\n    // account for rAF time rounding inaccuracies\n    scrollTo(start + distance)\n\n    // if scrolling to an element, and accessibility is enabled\n    if (element && a11y) {\n      // add tabindex indicating programmatic focus\n      element.setAttribute('tabindex', '-1')\n\n      // focus the element\n      const htmlElement = element as HTMLElement\n      htmlElement.focus()\n    }\n\n    // if it exists, fire the callback\n    if (typeof callback === 'function') {\n      callback()\n    }\n\n    // reset time for next jump\n    timeStart = 0\n\n    // we're done scrolling\n    scrolling = false\n  }\n\n  // API\n\n  function jump(target: Element | number | string, options: JumpOptions = {}) {\n    // resolve options, or use defaults\n    duration = 1000\n    offset = options.offset || 0\n    callback = options.callback // \"undefined\" is a suitable default, and won't be called\n    easing = options.easing || easeInOutQuad\n    a11y = options.a11y || false\n\n    // resolve container\n    switch (typeof options.container) {\n      case 'object':\n        // we assume container is an HTML element (Node)\n        container = options.container\n        break\n\n      case 'string':\n        container = document.querySelector(options.container) as Element\n        break\n\n      default:\n        container = window.document.documentElement\n    }\n\n    // cache starting position\n    start = location()\n\n    // resolve target\n    switch (typeof target) {\n      // scroll from current position\n      case 'number':\n        element = undefined // no element to scroll to\n        a11y = false // make sure accessibility is off\n        stop = start + target\n        break\n\n      // scroll to element (node)\n      // bounding rect is relative to the viewport\n      case 'object':\n        element = target\n        stop = top(element)\n        break\n\n      // scroll to element (selector)\n      // bounding rect is relative to the viewport\n      case 'string':\n        element = document.querySelector(target) as unknown as Element\n        stop = top(element)\n        break\n\n      default:\n    }\n\n    // resolve scroll distance, accounting for offset\n    distance = stop - start + offset\n\n    // resolve duration\n    switch (typeof options.duration) {\n      // number in ms\n      case 'number':\n        duration = options.duration\n        break\n\n      // function passed the distance of the scroll\n      case 'function':\n        duration = options.duration(distance)\n        break\n\n      default:\n    }\n\n    // start the loop if we're not already scrolling\n    if (!scrolling) {\n      requestAnimationFrame(loop)\n    } else {\n      // reset time for next jump\n      timeStart = 0\n    }\n  }\n\n  // expose only the jump method\n  return jump\n}\n\n// export singleton\n\nconst singleton = createJump()\n\nexport default singleton\n","/**\n * Measure how long a callback takes to execute.\n * Returns the response from the callback\n * The measured duration is returned via the onDuration callback\n */\nexport function measure<T>(callback: () => T, onDuration: (duration: number) => void): T {\n  const start = Date.now()\n  const result = callback()\n  const end = Date.now()\n\n  onDuration(end - start)\n\n  return result\n}\n","import { initial, isEmpty } from 'lodash-es'\nimport type {\n  ContentErrors,\n  JSONParser,\n  RecursiveStateFactory,\n  ValidationErrors,\n  ValidationError,\n  Validator\n} from '$lib/types.js'\nimport { ValidationSeverity } from '$lib/types.js'\nimport { MAX_AUTO_REPAIRABLE_SIZE, MAX_VALIDATABLE_SIZE } from '../constants.js'\nimport { measure } from '../utils/timeUtils.js'\nimport { normalizeJsonParseError } from '../utils/jsonUtils.js'\nimport { createDebug } from '../utils/debug.js'\nimport { jsonrepair } from 'jsonrepair'\nimport { updateInRecursiveState } from './documentState.js'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst debug = createDebug('validation')\n\nexport const validationErrorsFactory: RecursiveStateFactory = {\n  createObjectDocumentState: () => ({ type: 'object', properties: {} }),\n  createArrayDocumentState: () => ({ type: 'array', items: [] }),\n  createValueDocumentState: () => ({ type: 'value' })\n}\n\nexport function updateInValidationErrors(\n  json: unknown,\n  errors: ValidationErrors | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: ValidationErrors) => ValidationErrors\n): ValidationErrors {\n  return updateInRecursiveState(json, errors, path, transform, validationErrorsFactory)\n}\n\n/**\n * Create a flat map with validation errors, where the key is the stringified path\n * and also create error messages for the parent nodes of the nodes having an error.\n *\n * Returns a nested object containing the validation errors\n */\nexport function toRecursiveValidationErrors(\n  json: unknown,\n  validationErrors: ValidationError[]\n): ValidationErrors | undefined {\n  let output: ValidationErrors | undefined\n\n  // first generate the errors themselves\n  validationErrors.forEach((validationError) => {\n    output = updateInValidationErrors(json, output, validationError.path, (_, state) => ({\n      ...state,\n      validationError\n    }))\n  })\n\n  // create error entries for all parent nodes (displayed when the node is collapsed)\n  validationErrors.forEach((validationError) => {\n    let parentPath = validationError.path\n\n    while (parentPath.length > 0) {\n      parentPath = initial(parentPath)\n\n      output = updateInValidationErrors(json, output, parentPath, (_, state) => {\n        return state.validationError\n          ? state\n          : {\n              ...state,\n              validationError: {\n                isChildError: true,\n                path: parentPath,\n                message: 'Contains invalid data',\n                severity: ValidationSeverity.warning\n              }\n            }\n      })\n    }\n  })\n\n  return output\n}\n\nexport function validateJSON(\n  json: unknown,\n  validator: Validator | undefined,\n  parser: JSONParser,\n  validationParser: JSONParser\n): ValidationError[] {\n  debug('validateJSON')\n\n  if (!validator) {\n    return []\n  }\n\n  if (parser !== validationParser) {\n    // if needed, convert for example Lossless JSON to native JSON\n    // (like replace bigint or LosslessNumber into regular numbers)\n    const text = parser.stringify(json)\n    const convertedJSON = text !== undefined ? validationParser.parse(text) : undefined\n    return validator(convertedJSON)\n  } else {\n    return validator(json)\n  }\n}\n\nexport function validateText(\n  text: string,\n  validator: Validator | undefined,\n  parser: JSONParser,\n  validationParser: JSONParser\n): ContentErrors | undefined {\n  debug('validateText')\n\n  if (text.length > MAX_VALIDATABLE_SIZE) {\n    const validationError: ValidationError = {\n      path: [],\n      message: 'Validation turned off: the document is too large',\n      severity: ValidationSeverity.info\n    }\n\n    return {\n      validationErrors: [validationError]\n    }\n  }\n\n  if (text.length === 0) {\n    // new, empty document, do not try to parse\n    return undefined\n  }\n\n  try {\n    // parse with the \"main\" parser (not the validation parser) to get parse errors\n    // (like syntax errors and duplicate keys errors)\n    const json = measure(\n      () => parser.parse(text),\n      (duration) => debug(`validate: parsed json in ${duration} ms`)\n    )\n\n    if (!validator) {\n      return undefined\n    }\n\n    // if needed, parse with the validationParser to be able to feed the json to the validator\n    const convertedJSON =\n      parser === validationParser\n        ? json\n        : measure(\n            () => validationParser.parse(text),\n            (duration) => debug(`validate: parsed json with the validationParser in ${duration} ms`)\n          )\n\n    // actually validate the json\n    const validationErrors = measure(\n      () => validator(convertedJSON),\n      (duration) => debug(`validate: validated json in ${duration} ms`)\n    )\n\n    return !isEmpty(validationErrors) ? { validationErrors } : undefined\n  } catch (err) {\n    const isRepairable = measure(\n      () => canAutoRepair(text, parser),\n      (duration) => debug(`validate: checked whether repairable in ${duration} ms`)\n    )\n\n    const parseError = normalizeJsonParseError(\n      text,\n      (err as Error).message || (err as Error).toString()\n    )\n\n    return {\n      parseError,\n      isRepairable\n    }\n  }\n}\n\nfunction canAutoRepair(text: string, parser: JSONParser): boolean {\n  if (text.length > MAX_AUTO_REPAIRABLE_SIZE) {\n    return false\n  }\n\n  try {\n    parser.parse(jsonrepair(text))\n\n    return true\n  } catch {\n    return false\n  }\n}\n","import { createDebug } from '$lib/utils/debug.js'\n\nconst debug = createDebug('jsoneditor:FocusTracker')\n\nexport interface FocusTrackerProps {\n  onMount: (callback: () => void) => void\n  onDestroy: (callback: () => void) => void\n  getWindow: () => Window | undefined\n  hasFocus: () => boolean\n  onFocus: () => void\n  onBlur: () => void\n}\n\nexport function createFocusTracker({\n  onMount,\n  onDestroy,\n  getWindow,\n  hasFocus,\n  onFocus,\n  onBlur\n}: FocusTrackerProps) {\n  let blurTimeoutHandle: number | undefined\n  let focus = false\n\n  function handleFocusIn() {\n    const newFocus = hasFocus()\n\n    if (newFocus) {\n      clearTimeout(blurTimeoutHandle)\n      if (!focus) {\n        debug('focus')\n        onFocus()\n        focus = newFocus\n      }\n    }\n  }\n\n  function handleFocusOut() {\n    if (focus) {\n      // We set focus to false after timeout. Often, you get a blur and directly\n      // another focus when moving focus from one button to another.\n      // The focusIn handler will cancel any pending blur timer in those cases\n      clearTimeout(blurTimeoutHandle)\n      blurTimeoutHandle = setTimeout(() => {\n        if (!hasFocus()) {\n          debug('blur')\n          focus = false\n          onBlur()\n        }\n      }) as unknown as number\n    }\n  }\n\n  onMount(() => {\n    debug('mount FocusTracker')\n    const window = getWindow()\n    if (window) {\n      window.addEventListener('focusin', handleFocusIn, true)\n      window.addEventListener('focusout', handleFocusOut, true)\n    }\n  })\n\n  onDestroy(() => {\n    debug('destroy FocusTracker')\n    const window = getWindow()\n    if (window) {\n      window.removeEventListener('focusin', handleFocusIn, true)\n      window.removeEventListener('focusout', handleFocusOut, true)\n    }\n  })\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import type { MessageAction } from '$lib/types'\n  import type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\n  import { onDestroy } from 'svelte'\n\n  export let type: 'success' | 'error' | 'warning' | 'info' = 'success'\n  export let icon: IconDefinition | undefined = undefined\n  export let message: string | undefined = undefined\n  export let actions: MessageAction[] = []\n  export let onClick: (() => void) | undefined = undefined\n  export let onClose: (() => void) | undefined = undefined\n\n  if (onClose) {\n    onDestroy(onClose)\n  }\n\n  function handleClick() {\n    if (onClick) {\n      onClick()\n    }\n  }\n</script>\n\n<div class=\"jse-message jse-{type}\">\n  <!-- svelte-ignore a11y-click-events-have-key-events -->\n  <div\n    role=\"button\"\n    tabindex=\"-1\"\n    class=\"jse-text\"\n    class:jse-clickable={!!onClick}\n    on:click={handleClick}\n  >\n    <div class=\"jse-text-centered\">\n      {#if icon}\n        <Icon data={icon} />\n      {/if}\n      {message}\n    </div>\n  </div>\n  <div class=\"jse-actions\">\n    {#each actions as action}\n      <button\n        type=\"button\"\n        on:click={() => {\n          if (action.onClick) {\n            action.onClick()\n          }\n        }}\n        on:mousedown={() => {\n          if (action.onMouseDown) {\n            action.onMouseDown()\n          }\n        }}\n        class=\"jse-button jse-action jse-primary\"\n        title={action.title}\n        disabled={action.disabled}\n      >\n        {#if action.icon}\n          <Icon data={action.icon} />\n        {/if}\n        {action.text}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./Message.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faAngleDown,\n    faAngleRight,\n    faExclamationTriangle\n  } from '@fortawesome/free-solid-svg-icons'\n  import { isEmpty } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { ValidationSeverity, type ValidationError } from '$lib/types.js'\n  import { MAX_VALIDATION_ERRORS } from '$lib/constants.js'\n  import { limit } from '$lib/utils/arrayUtils.js'\n\n  export let validationErrors: ValidationError[]\n  export let selectError: (error: ValidationError) => void\n\n  $: count = validationErrors.length\n\n  let expanded = true\n\n  function collapse() {\n    expanded = false\n  }\n\n  function expand() {\n    expanded = true\n  }\n\n  function getMaxSeverity(errors: ValidationError[]): ValidationSeverity | undefined {\n    const severities = [\n      ValidationSeverity.error,\n      ValidationSeverity.warning,\n      ValidationSeverity.info\n    ]\n\n    return severities.find((severity) => errors.some((error) => error.severity === severity))\n  }\n</script>\n\n{#if !isEmpty(validationErrors)}\n  <div class=\"jse-validation-errors-overview\">\n    {#if expanded || count === 1}\n      <table class=\"jse-validation-errors-overview-expanded\">\n        <tbody>\n          {#each limit(validationErrors, MAX_VALIDATION_ERRORS) as validationError, index}\n            <tr\n              class=\"jse-validation-{validationError.severity}\"\n              tabindex=\"0\"\n              on:click={() => {\n                // trigger on the next tick to prevent the editor not getting focus\n                setTimeout(() => selectError(validationError))\n              }}\n            >\n              <td class=\"jse-validation-error-icon\">\n                <Icon data={faExclamationTriangle} />\n              </td>\n              <td class=\"jse-validation-error-path\">\n                {stringifyJSONPath(validationError.path)}\n              </td>\n              <td class=\"jse-validation-error-message\">\n                {validationError.message}\n              </td>\n              <td class=\"jse-validation-error-action\">\n                {#if index === 0 && validationErrors.length > 1}\n                  <button\n                    type=\"button\"\n                    class=\"jse-validation-errors-collapse\"\n                    on:click|stopPropagation={collapse}\n                    title=\"Collapse validation errors\"\n                  >\n                    <Icon data={faAngleDown} />\n                  </button>\n                {/if}\n              </td>\n            </tr>\n          {/each}\n\n          {#if count > MAX_VALIDATION_ERRORS}\n            <tr class=\"jse-validation-error\">\n              <td></td>\n              <td></td>\n              <td>(and {count - MAX_VALIDATION_ERRORS} more errors)</td>\n              <td></td>\n            </tr>\n          {/if}\n        </tbody>\n      </table>\n    {:else}\n      <table class=\"jse-validation-errors-overview-collapsed\">\n        <tbody>\n          <tr class=\"jse-validation-{getMaxSeverity(validationErrors)}\" on:click={expand}>\n            <td class=\"jse-validation-error-icon\">\n              <Icon data={faExclamationTriangle} />\n            </td>\n            <td class=\"jse-validation-error-count\">\n              {count} validation errors\n              <div class=\"jse-validation-errors-expand\">\n                <Icon data={faAngleRight} />\n              </div>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    {/if}\n  </div>\n{/if}\n\n<style src=\"./ValidationErrorsOverview.scss\"></style>\n","type Callback = () => void\n\n/**\n * The provided callback is invoked when the user presses Escape, and then stops propagation of the event.\n */\nexport function onEscape(element: HTMLElement | undefined, callback: Callback) {\n  if (!element) {\n    return undefined\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      event.preventDefault()\n      event.stopPropagation()\n      callback()\n    }\n  }\n\n  element.addEventListener('keydown', handleKeyDown)\n\n  return {\n    destroy() {\n      element.removeEventListener('keydown', handleKeyDown)\n    }\n  }\n}\n","<script lang=\"ts\">\n  // code based on: https://svelte.dev/examples/modal\n  import { onEscape } from '$lib/actions/onEscape.js'\n  import { onDestroy, onMount } from 'svelte'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let className: string | undefined = undefined\n  export let fullscreen = false\n  export let onClose: () => void\n\n  let dialog: HTMLDialogElement\n\n  onMount(() => dialog.showModal())\n  onDestroy(() => dialog.close())\n\n  function close() {\n    onClose()\n  }\n</script>\n\n<dialog\n  bind:this={dialog}\n  on:close={close}\n  on:pointerdown|self={close}\n  on:cancel|preventDefault\n  use:onEscape={close}\n  class={classnames('jse-modal', className)}\n  class:jse-fullscreen={fullscreen}\n>\n  <div class=\"jse-modal-inner\">\n    <slot />\n  </div>\n</dialog>\n\n<style lang=\"scss\">\n  @use '../../themes/defaults.scss';\n  @use '../../styles.scss';\n\n  dialog.jse-modal {\n    border-radius: styles.$border-radius;\n    font-size: defaults.$padding; // for some reason that I don't understand, the font-size of the dialog is used as margin around the dialog\n    border: none;\n    padding: 0;\n    display: flex;\n    min-width: 0;\n    margin: auto;\n    overflow: visible;\n    transition:\n      width 0.1s ease-in-out,\n      height 0.1s ease-in-out;\n\n    &.jse-sort-modal {\n      width: 400px;\n    }\n\n    &.jse-repair-modal {\n      width: 600px;\n      height: 500px;\n    }\n\n    &.jse-jsoneditor-modal {\n      width: 800px;\n      height: 600px;\n    }\n\n    &.jse-transform-modal {\n      width: 1200px;\n      height: 800px;\n    }\n\n    &.jse-fullscreen {\n      width: 100%;\n      height: 100%;\n    }\n\n    &::backdrop {\n      background: defaults.$modal-overlay-background;\n    }\n\n    &[open] {\n      animation: zoom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n    }\n\n    &[open]::backdrop {\n      animation: fade 0.2s ease-out;\n    }\n\n    & .jse-modal-inner {\n      @include styles.jse-modal-style;\n    }\n\n    @keyframes zoom {\n      from {\n        transform: scale(0.95);\n      }\n      to {\n        transform: scale(1);\n      }\n    }\n\n    @keyframes fade {\n      from {\n        opacity: 0;\n      }\n      to {\n        opacity: 1;\n      }\n    }\n\n    // styling for the select box, svelte-select\n    // see docs: https://github.com/rob-balfre/svelte-select#css-custom-properties-variables\n    :global(.svelte-select) {\n      --border: #{defaults.$svelte-select-border};\n      --item-is-active-bg: #{defaults.$svelte-select-item-is-active-bg};\n      --border-radius: #{defaults.$svelte-select-border-radius};\n      --background: #{defaults.$svelte-select-background};\n      --padding: #{defaults.$svelte-select-padding};\n      --multi-select-padding: #{defaults.$svelte-select-multi-select-padding};\n      --font-size: #{defaults.$svelte-select-font-size};\n      --height: 36px;\n      --multi-item-height: 28px;\n      --multi-item-margin: 2px;\n      --multi-item-padding: 2px 8px;\n      --multi-item-border-radius: 6px;\n      --indicator-top: 8px;\n    }\n  }\n</style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isMacDevice } from '$lib/utils/navigatorUtils.js'\n  import Header from './Header.svelte'\n  import Modal from './Modal.svelte'\n\n  export let onClose: () => void\n\n  const ctrl = isMacDevice() ? '⌘' : 'Ctrl'\n</script>\n\n<Modal {onClose} className=\"jse-copy-paste\">\n  <Header title=\"Copying and pasting\" {onClose} />\n\n  <div class=\"jse-modal-contents\">\n    <div>Clipboard permission is disabled by your browser. You can use:</div>\n\n    <div class=\"jse-shortcuts\">\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+C\n        </div>\n        for copy\n      </div>\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+X\n        </div>\n        for cut\n      </div>\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+V\n        </div>\n        for paste\n      </div>\n    </div>\n\n    <div class=\"jse-actions\">\n      <button type=\"button\" class=\"jse-primary\" on:click={onClose}> Close </button>\n    </div>\n  </div>\n</Modal>\n\n<style src=\"./CopyPasteModal.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import type { MenuItem } from '$lib/types'\n  import { isMenuButton, isMenuSeparator, isMenuSpace } from '$lib/typeguards.js'\n\n  export let items: MenuItem[] = []\n\n  function unknownMenuItem(item: MenuItem): string {\n    console.error('Unknown type of menu item', item)\n    return '???'\n  }\n</script>\n\n<div class=\"jse-menu\">\n  <slot name=\"left\" />\n\n  {#each items as item}\n    {#if isMenuSeparator(item)}\n      <div class=\"jse-separator\"></div>\n    {:else if isMenuSpace(item)}\n      <div class=\"jse-space\"></div>\n    {:else if isMenuButton(item)}\n      <button\n        type=\"button\"\n        class=\"jse-button {item.className}\"\n        on:click={item.onClick}\n        title={item.title}\n        disabled={item.disabled || false}\n      >\n        {#if item.icon}\n          <Icon data={item.icon} />\n        {/if}\n        {#if item.text}\n          {item.text}\n        {/if}\n      </button>\n    {:else}\n      {unknownMenuItem(item)}\n    {/if}\n  {/each}\n\n  <slot name=\"right\" />\n</div>\n\n<style src=\"./Menu.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faArrowDown,\n    faCheck,\n    faExclamationTriangle,\n    faTimes,\n    faWrench\n  } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import Message from '../../controls/Message.svelte'\n  import { normalizeJsonParseError } from '$lib/utils/jsonUtils.js'\n  import Menu from '../../controls/Menu.svelte'\n  import type { MenuItem, ParseError } from '$lib/types.js'\n\n  export let text = ''\n  export let readOnly = false\n  export let onParse: (text: string) => void\n  export let onRepair: (text: string) => string\n  export let onChange: ((updatedText: string) => void) | undefined = undefined\n  export let onApply: (repairedText: string) => void\n  export let onCancel: () => void\n\n  const debug = createDebug('jsoneditor:JSONRepair')\n\n  let domTextArea: HTMLTextAreaElement\n\n  $: error = getErrorMessage(text)\n  $: repairable = isRepairable(text)\n\n  $: debug('error', error)\n\n  function getErrorMessage(jsonText: string): ParseError | undefined {\n    try {\n      onParse(jsonText)\n      return undefined\n    } catch (err) {\n      return normalizeJsonParseError(jsonText, (err as Error).message)\n    }\n  }\n\n  function isRepairable(jsonText: string) {\n    try {\n      onRepair(jsonText)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  function goToError() {\n    if (domTextArea && error) {\n      const position = error.position !== undefined ? error.position : 0\n      domTextArea.setSelectionRange(position, position)\n      domTextArea.focus()\n    }\n  }\n\n  function handleChange(event: Event & { currentTarget: EventTarget & HTMLTextAreaElement }) {\n    debug('handleChange')\n\n    const value = (event.target as HTMLTextAreaElement).value\n\n    if (text === value) {\n      return\n    }\n\n    text = value\n\n    if (onChange) {\n      onChange(text)\n    }\n  }\n\n  function handleApply() {\n    onApply(text)\n  }\n\n  function handleRepair() {\n    try {\n      // TODO: simpleJsonRepair should also partially apply fixes. Now it's all or nothing\n      text = onRepair(text)\n\n      if (onChange) {\n        onChange(text)\n      }\n    } catch {\n      // no need to do something with the error\n    }\n  }\n\n  let items: MenuItem[]\n  $: items = [\n    {\n      type: 'space'\n    },\n    {\n      type: 'button',\n      icon: faTimes,\n      title: 'Cancel repair',\n      className: 'jse-cancel',\n      onClick: onCancel\n    }\n  ]\n\n  $: gotoAction = {\n    icon: faArrowDown,\n    text: 'Show me',\n    title: 'Scroll to the error location',\n    onClick: goToError\n  }\n\n  $: repairAction = {\n    icon: faWrench,\n    text: 'Auto repair',\n    title: 'Automatically repair JSON',\n    onClick: handleRepair\n  }\n\n  $: errorActions = repairable ? [gotoAction, repairAction] : [gotoAction]\n\n  $: successActions = [\n    {\n      icon: faCheck,\n      text: 'Apply',\n      title: 'Apply fixed JSON',\n      disabled: readOnly,\n      onClick: handleApply\n    }\n  ]\n</script>\n\n<div class=\"jse-json-repair-component\">\n  <Menu {items}>\n    <div slot=\"left\" class=\"jse-info\">Repair invalid JSON, then click apply</div>\n  </Menu>\n\n  {#if error}\n    <Message\n      type=\"error\"\n      icon={faExclamationTriangle}\n      message={`Cannot parse JSON: ${error.message}`}\n      actions={errorActions}\n    />\n  {:else}\n    <Message\n      type=\"success\"\n      message=\"JSON is valid now and can be parsed.\"\n      actions={successActions}\n    />\n  {/if}\n  <textarea\n    bind:this={domTextArea}\n    on:input={handleChange}\n    readonly={readOnly}\n    class=\"jse-json-text\"\n    autocomplete=\"off\"\n    autocapitalize=\"off\"\n    spellcheck=\"false\">{text}</textarea\n  >\n</div>\n\n<style src=\"./JSONRepairComponent.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import JSONRepairComponent from './repair/JSONRepairComponent.svelte'\n  import Modal from './Modal.svelte'\n\n  export let text: string\n  export let onParse: (text: string) => void\n  export let onRepair: (text: string) => string\n  export let onApply: (repairedText: string) => void\n  export let onClose: () => void\n\n  function handleApply(repairedText: string) {\n    onApply(repairedText)\n    onClose()\n  }\n\n  function handleCancel() {\n    onClose()\n  }\n</script>\n\n<Modal {onClose} className=\"jse-repair-modal\">\n  <JSONRepairComponent\n    bind:text\n    {onParse}\n    {onRepair}\n    onApply={handleApply}\n    onCancel={handleCancel}\n  />\n</Modal>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getExpandItemsSections } from '$lib/logic/expandItemsSections.js'\n  import type { JSONSelection, Section, VisibleSection, JSONEditorContext } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { pathInSelection } from '$lib/logic/selection.js'\n\n  export let visibleSections: VisibleSection[]\n  export let sectionIndex: number\n  export let total: number\n  export let path: JSONPath\n  export let selection: JSONSelection | undefined\n  export let onExpandSection: (path: JSONPath, section: Section) => void\n  export let context: JSONEditorContext\n\n  $: visibleSection = visibleSections[sectionIndex]\n\n  $: startIndex = visibleSection.end\n  $: endIndex = visibleSections[sectionIndex + 1] ? visibleSections[sectionIndex + 1].start : total\n\n  $: selected = pathInSelection(context.getJson(), selection, path.concat(String(startIndex)))\n\n  $: expandItemsSections = getExpandItemsSections(startIndex, endIndex)\n\n  function handleMouseMove(event: MouseEvent) {\n    // prevent the whole array from being selected whilst dragging over\n    // a section with collapsed items\n    event.stopPropagation()\n  }\n</script>\n\n<div\n  role=\"none\"\n  class=\"jse-collapsed-items\"\n  class:jse-selected={selected}\n  on:mousemove={handleMouseMove}\n  style:--level={path.length + 2}\n>\n  <div>\n    <div class=\"jse-text\">Items {startIndex}-{endIndex}</div>\n    {#each expandItemsSections as expandItemsSection}<button\n        type=\"button\"\n        class=\"jse-expand-items\"\n        on:click={() => onExpandSection(path, expandItemsSection)}\n      >\n        show {expandItemsSection.start}-{expandItemsSection.end}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./CollapsedItems.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCaretDown } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import {\n    CONTEXT_MENU_EXPLANATION,\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH\n  } from '$lib/constants.js'\n  import type { OnContextMenu } from '$lib/types'\n\n  export let root: boolean = false\n  export let insert: boolean = false\n  export let selected: boolean\n  export let onContextMenu: OnContextMenu\n\n  function handleClick(event: MouseEvent & { currentTarget: EventTarget & HTMLButtonElement }) {\n    let buttonElem: Element | undefined = event.target as HTMLButtonElement\n    while (buttonElem && buttonElem.nodeName !== 'BUTTON') {\n      buttonElem = buttonElem.parentNode as Element\n    }\n\n    if (buttonElem) {\n      onContextMenu({\n        anchor: buttonElem,\n        left: 0,\n        top: 0,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        offsetTop: 2,\n        offsetLeft: 0,\n        showTip: true\n      })\n    }\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-context-menu-pointer\"\n  class:jse-root={root}\n  class:jse-insert={insert}\n  class:jse-selected={selected}\n  title={CONTEXT_MENU_EXPLANATION}\n  on:click={handleClick}\n>\n  <Icon data={faCaretDown} />\n</button>\n\n<style src=\"./ContextMenuPointer.scss\"></style>\n","<script lang=\"ts\">\n  import type { ExtendedSearchResultItem, JSONEditorContext, JSONSelection } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { isEditingSelection, isValueSelection } from '$lib/logic/selection.js'\n  import { isSvelteActionRenderer } from '$lib/typeguards.js'\n\n  interface Props {\n    path: JSONPath\n    value: unknown\n    context: JSONEditorContext\n    enforceString: boolean\n    selection: JSONSelection | undefined\n    searchResultItems: ExtendedSearchResultItem[] | undefined\n  }\n\n  const { path, value, context, enforceString, selection, searchResultItems }: Props = $props()\n\n  const isEditing = $derived(isValueSelection(selection) && isEditingSelection(selection))\n\n  const renderers = $derived(\n    context.onRenderValue({\n      path,\n      value,\n      mode: context.mode,\n      truncateTextSize: context.truncateTextSize,\n      readOnly: context.readOnly,\n      enforceString,\n      isEditing,\n      parser: context.parser,\n      normalization: context.normalization,\n      selection,\n      searchResultItems,\n      onPatch: context.onPatch,\n      onPasteJson: context.onPasteJson,\n      onSelect: context.onSelect,\n      onFind: context.onFind,\n      findNextInside: context.findNextInside,\n      focus: context.focus\n    })\n  )\n</script>\n\n{#each renderers as renderer}\n  {#if isSvelteActionRenderer(renderer)}\n    {@const action = renderer.action}\n    <div\n      role=\"button\"\n      tabindex=\"-1\"\n      class=\"jse-value\"\n      data-type=\"selectable-value\"\n      use:action={renderer.props}\n    ></div>\n  {:else}\n    {@const Component = renderer.component}\n    <Component {...renderer.props} />\n  {/if}\n{/each}\n","// used by JSONNode during dragging\nimport type { JSONPath } from 'immutable-json-patch'\n\nexport const singleton: Singleton = {\n  selecting: false,\n  selectionAnchor: undefined, // Path\n  selectionAnchorType: undefined, // Selection type\n  selectionFocus: undefined, // Path\n\n  dragging: false\n}\n\ninterface Singleton {\n  selecting: boolean\n  selectionAnchor: JSONPath | undefined\n  selectionAnchorType: string | undefined\n  selectionFocus: JSONPath | undefined\n\n  dragging: boolean\n}\n","import { createMultiSelection, getEndPath, getStartPath } from './selection.js'\nimport { initial, isEqual } from 'lodash-es'\nimport type { JSONPatchDocument } from 'immutable-json-patch'\nimport { getIn } from 'immutable-json-patch'\nimport { moveInsideParent } from './operations.js'\nimport type {\n  DragInsideAction,\n  DragInsideProps,\n  JSONSelection,\n  MultiSelection,\n  RenderedItem\n} from '$lib/types'\n\nexport interface MoveSelectionProps {\n  json: unknown\n  selection: JSONSelection | undefined\n  deltaY: number\n  items: RenderedItem[]\n}\n\nexport interface MoveSelectionResult {\n  operations: JSONPatchDocument | undefined\n  updatedSelection: JSONSelection | undefined\n  offset: number\n}\n\nexport function onMoveSelection({\n  json,\n  selection,\n  deltaY,\n  items\n}: MoveSelectionProps): MoveSelectionResult {\n  if (!selection) {\n    return {\n      operations: undefined,\n      updatedSelection: undefined,\n      offset: 0\n    }\n  }\n\n  const dragInsideAction =\n    deltaY < 0\n      ? findSwapPathUp({ json, selection, deltaY, items })\n      : findSwapPathDown({ json, selection, deltaY, items })\n\n  if (!dragInsideAction || dragInsideAction.offset === 0) {\n    return {\n      operations: undefined,\n      updatedSelection: undefined,\n      offset: 0\n    }\n  }\n\n  const operations = moveInsideParent(json, selection, dragInsideAction)\n\n  const path = initial(getStartPath(json, selection))\n  const value = getIn(json, path)\n  if (Array.isArray(value)) {\n    const updatedSelection = createUpdatedArraySelection({\n      items,\n      json,\n      selection,\n      offset: dragInsideAction.offset\n    })\n\n    return {\n      operations,\n      updatedSelection,\n      offset: dragInsideAction.offset\n    }\n  } else {\n    // object\n    return {\n      operations,\n      updatedSelection: undefined,\n      offset: dragInsideAction.offset\n    }\n  }\n}\n\nfunction findSwapPathUp({\n  json,\n  items,\n  selection,\n  deltaY\n}: DragInsideProps): DragInsideAction | undefined {\n  const initialPath = getStartPath(json, selection)\n  const initialIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n\n  const prevHeight = () => items[index - 1]?.height\n\n  let index = initialIndex\n  let cumulativeHeight = 0\n\n  while (prevHeight() !== undefined && Math.abs(deltaY) > cumulativeHeight + prevHeight() / 2) {\n    cumulativeHeight += prevHeight()\n    index -= 1\n  }\n\n  const beforePath = items[index].path\n  const offset = index - initialIndex\n\n  return index !== initialIndex && items[index] !== undefined ? { beforePath, offset } : undefined\n}\n\nfunction findSwapPathDown({\n  json,\n  items,\n  selection,\n  deltaY\n}: DragInsideProps): DragInsideAction | undefined {\n  const initialPath = getEndPath(json, selection)\n  const initialIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n\n  let cumulativeHeight = 0\n  let index = initialIndex\n\n  const nextHeight = () => items[index + 1]?.height\n\n  while (nextHeight() !== undefined && Math.abs(deltaY) > cumulativeHeight + nextHeight() / 2) {\n    cumulativeHeight += nextHeight()\n    index += 1\n  }\n\n  const parentPath = initial(initialPath)\n  const parent = getIn(json, parentPath)\n  const isArray = Array.isArray(parent)\n  const beforeIndex = isArray ? index : index + 1\n  const beforePath = items[beforeIndex]?.path\n  const offset = index - initialIndex\n\n  return beforePath ? { beforePath, offset } : { append: true, offset }\n}\n\ninterface UpdatedArraySelectionProps {\n  items: RenderedItem[]\n  json: unknown\n  selection: JSONSelection\n  offset: number\n}\n\nfunction createUpdatedArraySelection({\n  items,\n  json,\n  selection,\n  offset\n}: UpdatedArraySelectionProps): MultiSelection {\n  const startPath = getStartPath(json, selection)\n  const endPath = getEndPath(json, selection)\n\n  const startIndex = items.findIndex((item) => isEqual(item.path, startPath))\n  const endIndex = items.findIndex((item) => isEqual(item.path, endPath))\n\n  const anchorPath = items[startIndex + offset]?.path\n  const focusPath = items[endIndex + offset]?.path\n\n  return createMultiSelection(anchorPath, focusPath)\n}\n","<script lang=\"ts\">\n  import { faExclamationTriangle } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import { getContext } from 'svelte'\n  import { tooltip } from '../../controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext, NestedValidationError, ValidationError } from '$lib/types.js'\n  import { isNestedValidationError } from '$lib/typeguards.js'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let validationError: NestedValidationError | ValidationError\n  export let onExpand: (event: MouseEvent) => void\n\n  $: text =\n    isNestedValidationError(validationError) && validationError.isChildError\n      ? 'Contains invalid data'\n      : validationError.message\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-validation-{validationError.severity}\"\n  on:click={onExpand}\n  use:tooltip={{ text, ...absolutePopupContext }}\n>\n  <Icon data={faExclamationTriangle} />\n</button>\n\n<style src=\"./ValidationErrorIcon.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\n  import type { JSONPath, JSONPointer } from 'immutable-json-patch'\n  import { appendToJSONPointer, parseJSONPointer } from 'immutable-json-patch'\n  import { initial, isEqual, last, range } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import {\n    DEFAULT_VISIBLE_SECTIONS,\n    HOVER_COLLECTION,\n    HOVER_INSERT_AFTER,\n    HOVER_INSERT_INSIDE,\n    INSERT_EXPLANATION\n  } from '$lib/constants.js'\n  import { getEnforceString, getVisibleCaretPositions } from '$lib/logic/documentState.js'\n  import { rename } from '$lib/logic/operations.js'\n  import {\n    createAfterSelection,\n    createInsideSelection,\n    createMultiSelection,\n    fromCaretPosition,\n    fromSelectionType,\n    getAnchorPath,\n    getEndPath,\n    getFocusPath,\n    getSelectionPaths,\n    getStartPath,\n    isAfterSelection,\n    isEditingSelection,\n    isInsideSelection,\n    isKeySelection,\n    isMultiSelection,\n    isValueSelection,\n    pathInSelection,\n    selectionIfOverlapping\n  } from '$lib/logic/selection.js'\n  import {\n    getDataPathFromTarget,\n    getSelectionTypeFromTarget,\n    isChildOfAttribute,\n    isChildOfNodeName,\n    isContentEditableDiv\n  } from '$lib/utils/domUtils.js'\n  import CollapsedItems from './CollapsedItems.svelte'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n  import JSONKey from './JSONKey.svelte'\n  import JSONValue from './JSONValue.svelte'\n  import { singleton } from './singleton.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { onMoveSelection } from '$lib/logic/dragging.js'\n  import { forEachIndex, moveItems } from '$lib/utils/arrayUtils.js'\n  import type {\n    AbsolutePopupOptions,\n    CaretPosition,\n    DocumentState,\n    DraggingState,\n    JSONSelection,\n    NestedValidationError,\n    SearchResults,\n    ValidationErrors,\n    RenderedItem,\n    TreeModeContext,\n    VisibleSection\n  } from '$lib/types'\n  import { SelectionType } from '$lib/types.js'\n  import {\n    isArrayRecursiveState,\n    isExpandableState,\n    isObjectRecursiveState\n  } from '$lib/typeguards.js'\n  import { filterKeySearchResults, filterValueSearchResults } from '$lib/logic/search.js'\n  import ValidationErrorIcon from './ValidationErrorIcon.svelte'\n  import { isObject } from '$lib/utils/typeUtils.js'\n  import { classnames } from '$lib/utils/cssUtils.js'\n  import { isCtrlKeyDown } from 'svelte-jsoneditor/utils/keyBindings'\n  import Tag from '../../../components/controls/Tag.svelte'\n\n  // We pass `pointer` instead of `path` because pointer (a string) is immutable.\n  // Without it, *all* nodes would re-render on *every* change in JSON or DocumentState,\n  // because the path changes every time by re-creating it.\n  export let pointer: JSONPointer\n  export let value: unknown\n  export let state: DocumentState | undefined\n  export let validationErrors: ValidationErrors | undefined\n  export let searchResults: SearchResults | undefined\n  export let selection: JSONSelection | undefined\n  export let context: TreeModeContext\n  export let onDragSelectionStart: (\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) => void\n\n  const debug = createDebug('jsoneditor:JSONNode')\n\n  let hover: string | undefined = undefined\n  let hoverTimer: number | undefined = undefined\n  let dragging: DraggingState | undefined = undefined\n\n  let path: JSONPath\n  $: path = parseJSONPointer(pointer)\n  $: dataPath = encodeURIComponent(pointer) // This is the same as encodeDataPath(path) but faster\n\n  let expanded: boolean\n  $: expanded = isExpandableState(state) ? state.expanded : false\n\n  let enforceString: boolean\n  $: enforceString = getEnforceString(value, state, [])\n\n  let visibleSections: VisibleSection[] | undefined\n  $: visibleSections = isArrayRecursiveState(state) ? state.visibleSections : undefined\n\n  let validationError: NestedValidationError | undefined\n  $: validationError = validationErrors?.validationError\n\n  let isNodeSelected: boolean\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: isNodeSelected = pathInSelection(context.getJson(), selection, path)\n\n  $: root = path.length === 0\n\n  /**\n   * Get sorted keys, applying dragging order\n   */\n  function getKeys(object: Record<string, unknown>, dragging: DraggingState | undefined): string[] {\n    const keys = Object.keys(object)\n\n    // reorder the keys whilst dragging\n    if (dragging && dragging.offset !== 0) {\n      return moveItems(\n        keys,\n        dragging.selectionStartIndex,\n        dragging.selectionItemsCount,\n        dragging.offset\n      )\n    }\n\n    return keys\n  }\n\n  interface ItemIndex {\n    index: number\n    gutterIndex: number\n  }\n\n  function getItems(\n    array: Array<unknown>,\n    visibleSection: VisibleSection,\n    dragging: DraggingState | undefined\n  ): ItemIndex[] {\n    const start = visibleSection.start\n    const end = Math.min(visibleSection.end, array.length)\n    const indices = range(start, end)\n\n    // reorder the items whilst dragging\n    if (dragging && dragging.offset !== 0) {\n      return moveItems(\n        indices,\n        dragging.selectionStartIndex,\n        dragging.selectionItemsCount,\n        dragging.offset\n      ).map((index, gutterIndex) => ({ index, gutterIndex }))\n    }\n\n    return indices.map((index) => ({ index, gutterIndex: index }))\n  }\n\n  function toggleExpand(event: MouseEvent) {\n    event.stopPropagation()\n\n    const recursive = isCtrlKeyDown(event)\n    context.onExpand(path, !expanded, recursive)\n  }\n\n  function handleExpand() {\n    context.onExpand(path, true)\n  }\n\n  function handleUpdateKey(oldKey: string, newKey: string): string {\n    const operations = rename(path, Object.keys(value as Record<string, unknown>), oldKey, newKey)\n    context.onPatch(operations)\n\n    // It is possible that the applied key differs from newKey,\n    // to prevent duplicate keys. Here we figure out the actually applied key\n    return last(parseJSONPointer(operations[0].path)) as string\n  }\n\n  function handleMouseDown(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    // only handle when the left or right mouse button is pressed, not the middle mouse button (scroll wheel)\n    if (event.buttons !== 1 && event.buttons !== 2) {\n      return\n    }\n\n    // check if the mouse down is not happening in the key or value input fields or on a button\n    if (\n      isContentEditableDiv(event.target as HTMLElement) ||\n      (event.buttons === 1 && isChildOfNodeName(event.target as Element, 'BUTTON')) // left mouse on a button\n    ) {\n      return\n    }\n\n    event.stopPropagation()\n    event.preventDefault()\n\n    // due to event.stopPropagation here and there, the focus tracker does not receive this mouse event.\n    // make sure the editor has focus\n    context.focus()\n\n    // we attach the mousemove and mouseup event listeners to the global document,\n    // so we will not miss if the mouse events happen outside the editor\n    document.addEventListener('mousemove', handleMouseMoveGlobal, true)\n    document.addEventListener('mouseup', handleMouseUpGlobal)\n\n    const anchorType = getSelectionTypeFromTarget(event.target as Element)\n    const json = context.getJson()\n    const documentState = context.getDocumentState()\n\n    if (\n      selection &&\n      anchorType !== SelectionType.after &&\n      anchorType !== SelectionType.inside &&\n      (selection.type === anchorType || selection.type === SelectionType.multi) &&\n      pathInSelection(json, selection, path)\n    ) {\n      // when right-clicking inside the current selection, do nothing: context menu will open\n      // when left-clicking inside the current selection, do nothing: it can be the start of dragging\n      if (event.button === 0) {\n        onDragSelectionStart(event)\n      }\n\n      return\n    }\n\n    // TODO: refactor dragging, there are now two separate mechanisms handling mouse movement: with dragging.* and with singleton.*\n    singleton.selecting = true\n    singleton.selectionAnchor = path\n    singleton.selectionAnchorType = anchorType\n    singleton.selectionFocus = path\n\n    if (event.shiftKey) {\n      // Shift+Click will select multiple entries\n      const fullSelection = context.getSelection()\n      if (fullSelection) {\n        context.onSelect(createMultiSelection(getAnchorPath(fullSelection), path))\n      }\n    } else {\n      if (anchorType === SelectionType.multi) {\n        if (root && (event.target as Element).hasAttribute('data-path')) {\n          const lastCaretPosition = last(\n            getVisibleCaretPositions(value, documentState)\n          ) as CaretPosition\n          context.onSelect(fromCaretPosition(lastCaretPosition))\n        } else {\n          context.onSelect(createMultiSelection(path, path))\n        }\n      } else if (json !== undefined) {\n        context.onSelect(fromSelectionType(anchorType, path))\n      }\n    }\n  }\n\n  function handleMouseMove(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    if (singleton.selecting) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if (singleton.selectionFocus === undefined) {\n        // First move event, no selection yet.\n        // Clear the default selection of the browser\n        if (window.getSelection) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          window.getSelection().empty()\n        }\n      }\n\n      const selectionType = getSelectionTypeFromTarget(event.target as Element)\n\n      if (\n        !isEqual(path, singleton.selectionFocus) ||\n        selectionType !== singleton.selectionAnchorType\n      ) {\n        singleton.selectionFocus = path\n        singleton.selectionAnchorType = selectionType // TODO: this is a bit ugly\n\n        context.onSelect(\n          createMultiSelection(\n            singleton.selectionAnchor || singleton.selectionFocus,\n            singleton.selectionFocus\n          )\n        )\n      }\n    }\n  }\n\n  function handleMouseMoveGlobal(event: MouseEvent) {\n    context.onDrag(event)\n  }\n\n  function handleMouseUpGlobal(event: Event) {\n    if (singleton.selecting) {\n      singleton.selecting = false\n\n      event.stopPropagation()\n    }\n\n    context.onDragEnd()\n\n    document.removeEventListener('mousemove', handleMouseMoveGlobal, true)\n    document.removeEventListener('mouseup', handleMouseUpGlobal)\n  }\n\n  function findContentTop() {\n    return context.findElement([])?.getBoundingClientRect()?.top || 0\n  }\n\n  function calculateDeltaY(dragging: DraggingState, event: MouseEvent) {\n    // calculate the contentOffset, this changes when scrolling\n    const contentTop = findContentTop()\n    const contentOffset = contentTop - dragging.initialContentTop\n\n    // calculate the vertical mouse movement\n    const clientOffset = event.clientY - dragging.initialClientY\n\n    return clientOffset - contentOffset\n  }\n\n  function handleDragSelectionStart(\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) {\n    if (context.readOnly || !selection) {\n      return\n    }\n\n    const selectionParentPath = initial(getFocusPath(selection))\n    if (!isEqual(path, selectionParentPath)) {\n      // pass to parent\n      onDragSelectionStart(event)\n\n      return\n    }\n\n    // note that the returned items will be of one section only,\n    // and when the selection is spread over multiple sections,\n    // no items will be returned: this is not (yet) supported\n    const items = getVisibleItemsWithHeights(selection, visibleSections || DEFAULT_VISIBLE_SECTIONS)\n\n    debug('dragSelectionStart', { selection, items })\n\n    if (!items) {\n      debug('Cannot drag the current selection (probably spread over multiple sections)')\n      return\n    }\n\n    const json = context.getJson()\n    if (json === undefined) {\n      return\n    }\n    const initialPath = getStartPath(json, selection)\n    const selectionStartIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n    const { offset } = onMoveSelection({\n      json,\n      selection: context.getSelection(),\n      deltaY: 0,\n      items\n    })\n\n    dragging = {\n      initialTarget: event.target as Element,\n      initialClientY: event.clientY,\n      initialContentTop: findContentTop(),\n      selectionStartIndex,\n      selectionItemsCount: getSelectionPaths(json, selection).length,\n      items,\n      offset,\n      didMoveItems: false // whether items have been moved during dragging or not\n    }\n    singleton.dragging = true\n\n    document.addEventListener('mousemove', handleDragSelection, true)\n    document.addEventListener('mouseup', handleDragSelectionEnd)\n  }\n\n  function handleDragSelection(event: MouseEvent) {\n    if (dragging) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return\n      }\n\n      const deltaY = calculateDeltaY(dragging, event)\n      const { offset } = onMoveSelection({\n        json,\n        selection: context.getSelection(),\n        deltaY,\n        items: dragging.items\n      })\n\n      if (offset !== dragging.offset) {\n        debug('drag selection', offset, deltaY)\n\n        dragging = {\n          ...dragging,\n          offset,\n          didMoveItems: true\n        }\n      }\n    }\n  }\n\n  function handleDragSelectionEnd(event: MouseEvent) {\n    if (dragging) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return\n      }\n      const deltaY = calculateDeltaY(dragging, event)\n      const { operations, updatedSelection } = onMoveSelection({\n        json,\n        selection: context.getSelection(),\n        deltaY,\n        items: dragging.items\n      })\n\n      if (operations) {\n        context.onPatch(operations, (_, patchedState) => ({\n          state: patchedState,\n          selection: updatedSelection ?? selection\n        }))\n      } else {\n        // the user did click inside the selection and no contents have been dragged,\n        // select the clicked item\n        if (event.target === dragging.initialTarget && !dragging.didMoveItems) {\n          const selectionType = getSelectionTypeFromTarget(event.target as Element)\n          const path = getDataPathFromTarget(event.target as Element)\n          if (path) {\n            context.onSelect(fromSelectionType(selectionType, path))\n          }\n        }\n      }\n\n      dragging = undefined\n      singleton.dragging = false\n\n      document.removeEventListener('mousemove', handleDragSelection, true)\n      document.removeEventListener('mouseup', handleDragSelectionEnd)\n    }\n  }\n\n  /**\n   * Get a list with all visible items and their rendered heights inside\n   * this object or array\n   */\n  // TODO: extract and unit test getVisibleItemsWithHeights\n  function getVisibleItemsWithHeights(\n    selection: JSONSelection,\n    visibleSections: VisibleSection[]\n  ): RenderedItem[] | undefined {\n    const items: RenderedItem[] = []\n\n    function addHeight(prop: string) {\n      const itemPath = path.concat(prop)\n      const element = context.findElement(itemPath)\n      if (element !== undefined) {\n        items.push({\n          path: itemPath,\n          height: element.clientHeight\n        })\n      }\n    }\n\n    if (Array.isArray(value)) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return undefined\n      }\n      const startPath = getStartPath(json, selection)\n      const endPath = getEndPath(json, selection)\n      const startIndex = parseInt(last(startPath) as string, 10)\n      const endIndex = parseInt(last(endPath) as string, 10)\n\n      // find the section where the selection is\n      // if the selection is spread over multiple visible sections,\n      // we will not return any items, so dragging will not work there.\n      // We do this to keep things simple for now.\n      const currentSection = visibleSections.find((visibleSection) => {\n        return startIndex >= visibleSection.start && endIndex <= visibleSection.end\n      })\n\n      if (!currentSection) {\n        return undefined\n      }\n\n      const { start, end } = currentSection\n      forEachIndex(start, Math.min(value.length, end), (index) => addHeight(String(index)))\n    } else {\n      // value is Object\n      Object.keys(value as Record<string, unknown>).forEach(addHeight)\n    }\n\n    return items\n  }\n\n  function handleMouseOver(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    if (singleton.selecting || singleton.dragging) {\n      return\n    }\n\n    event.stopPropagation()\n\n    if (isChildOfAttribute(event.target as Element, 'data-type', 'selectable-value')) {\n      hover = HOVER_COLLECTION\n    } else if (isChildOfAttribute(event.target as Element, 'data-type', 'selectable-key')) {\n      hover = undefined\n    } else if (\n      isChildOfAttribute(event.target as Element, 'data-type', 'insert-selection-area-inside')\n    ) {\n      hover = HOVER_INSERT_INSIDE\n    } else if (\n      isChildOfAttribute(event.target as Element, 'data-type', 'insert-selection-area-after')\n    ) {\n      hover = HOVER_INSERT_AFTER\n    }\n\n    clearTimeout(hoverTimer)\n  }\n\n  function handleMouseOut(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    event.stopPropagation()\n\n    // to prevent \"flickering\" in the hovering state when hovering on the edge\n    // of the insert area context menu button: it's visibility toggles when\n    // `hover` toggles, which will alternating mouseout and mouseover events\n    hoverTimer = window.setTimeout(() => (hover = undefined))\n  }\n\n  function handleInsertInside(event: MouseEvent) {\n    if (!event.shiftKey) {\n      event.stopPropagation()\n      event.preventDefault()\n\n      context.onSelect(createInsideSelection(path))\n    }\n  }\n\n  function handleInsertAfter(event: MouseEvent) {\n    if (!event.shiftKey) {\n      event.stopPropagation()\n      event.preventDefault()\n\n      context.onSelect(createAfterSelection(path))\n    }\n  }\n\n  function handleInsertInsideOpenContextMenu(contextMenuProps: AbsolutePopupOptions) {\n    context.onSelect(createInsideSelection(path))\n    context.onContextMenu(contextMenuProps)\n  }\n\n  function handleInsertAfterOpenContextMenu(contextMenuProps: AbsolutePopupOptions) {\n    context.onSelect(createAfterSelection(path))\n    context.onContextMenu(contextMenuProps)\n  }\n</script>\n\n<!-- svelte-ignore a11y-mouse-events-have-key-events -->\n<div\n  role=\"treeitem\"\n  tabindex=\"-1\"\n  class={classnames(\n    'jse-json-node',\n    { 'jse-expanded': expanded },\n    context.onClassName(path, value)\n  )}\n  data-path={dataPath}\n  aria-selected={isNodeSelected}\n  style:--level={path.length}\n  class:jse-root={root}\n  class:jse-selected={isNodeSelected && isMultiSelection(selection)}\n  class:jse-selected-value={isNodeSelected && isValueSelection(selection)}\n  class:jse-readonly={context.readOnly}\n  class:jse-hovered={hover === HOVER_COLLECTION}\n  on:mousedown={handleMouseDown}\n  on:mousemove={handleMouseMove}\n  on:mouseover={handleMouseOver}\n  on:mouseout={handleMouseOut}\n>\n  {#if Array.isArray(value)}\n    <div class=\"jse-header-outer\">\n      <div class=\"jse-header\">\n        <button\n          type=\"button\"\n          class=\"jse-expand\"\n          on:click={toggleExpand}\n          title=\"Expand or collapse this array (Ctrl+Click to expand/collapse recursively)\"\n        >\n          {#if expanded}\n            <Icon data={faCaretDown} />\n          {:else}\n            <Icon data={faCaretRight} />\n          {/if}\n        </button>\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-meta\">\n          <div class=\"jse-meta-inner\" data-type=\"selectable-value\">\n            {#if expanded}\n              <div class=\"jse-bracket\">[</div>\n              <Tag>\n                {value.length}\n                {value.length === 1 ? 'item' : 'items'}\n              </Tag>\n              &nbsp;\n            {:else}\n              <div class=\"jse-bracket\">[</div>\n              <Tag onclick={handleExpand}>\n                {value.length}\n                {value.length === 1 ? 'item' : 'items'}\n              </Tag>\n              <div class=\"jse-bracket\">]</div>\n            {/if}\n          </div>\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError && (!expanded || !validationError.isChildError)}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if expanded}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-inside\"\n          data-type=\"insert-selection-area-inside\"\n          on:click={handleInsertInside}\n        ></div>\n      {:else}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n    {#if expanded}\n      <div class=\"jse-items\">\n        {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isNodeSelected && isInsideSelection(selection)))}\n          <div\n            class=\"jse-insert-area jse-inside\"\n            class:jse-hovered={hover === HOVER_INSERT_INSIDE}\n            class:jse-selected={isNodeSelected && isInsideSelection(selection)}\n            data-type=\"insert-selection-area-inside\"\n            style:--level={path.length + 1}\n            title={INSERT_EXPLANATION}\n          >\n            <ContextMenuPointer\n              insert={true}\n              selected={isNodeSelected && isInsideSelection(selection)}\n              onContextMenu={handleInsertInsideOpenContextMenu}\n            />\n          </div>\n        {/if}\n        {#each visibleSections || DEFAULT_VISIBLE_SECTIONS as visibleSection, sectionIndex (sectionIndex)}\n          {#each getItems(value, visibleSection, dragging) as item (item.index)}\n            {@const nestedValidationErrors = isArrayRecursiveState(validationErrors)\n              ? validationErrors.items[item.index]\n              : undefined}\n\n            {@const nestedSelection = selectionIfOverlapping(\n              context.getJson(),\n              selection,\n              path.concat(String(item.index))\n            )}\n\n            <svelte:self\n              value={value[item.index]}\n              pointer={appendToJSONPointer(pointer, item.index)}\n              state={isArrayRecursiveState(state) ? state.items[item.index] : undefined}\n              validationErrors={nestedValidationErrors}\n              searchResults={isArrayRecursiveState(searchResults)\n                ? searchResults.items[item.index]\n                : undefined}\n              selection={nestedSelection}\n              {context}\n              onDragSelectionStart={handleDragSelectionStart}\n            >\n              <div slot=\"identifier\" class=\"jse-identifier\">\n                <div class=\"jse-index\">{item.gutterIndex}</div>\n              </div>\n            </svelte:self>\n          {/each}\n          {#if visibleSection.end < value.length}\n            <CollapsedItems\n              visibleSections={visibleSections || DEFAULT_VISIBLE_SECTIONS}\n              {sectionIndex}\n              total={value.length}\n              {path}\n              onExpandSection={context.onExpandSection}\n              {selection}\n              {context}\n            />\n          {/if}\n        {/each}\n      </div>\n      <div class=\"jse-footer-outer\">\n        <div data-type=\"selectable-value\" class=\"jse-footer\">\n          <span class=\"jse-bracket\">]</span>\n        </div>\n        {#if !root}\n          <div\n            role=\"none\"\n            class=\"jse-insert-selection-area jse-after\"\n            data-type=\"insert-selection-area-after\"\n            on:click={handleInsertAfter}\n          ></div>\n        {/if}\n      </div>\n    {/if}\n  {:else if isObject(value)}\n    <div class=\"jse-header-outer\">\n      <div class=\"jse-header\">\n        <button\n          type=\"button\"\n          class=\"jse-expand\"\n          on:click={toggleExpand}\n          title=\"Expand or collapse this object (Ctrl+Click to expand/collapse recursively)\"\n        >\n          {#if expanded}\n            <Icon data={faCaretDown} />\n          {:else}\n            <Icon data={faCaretRight} />\n          {/if}\n        </button>\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-meta\" data-type=\"selectable-value\">\n          <div class=\"jse-meta-inner\">\n            {#if expanded}\n              <div class=\"jse-bracket jse-expanded\">&lbrace;</div>\n            {:else}\n              <div class=\"jse-bracket\">&lbrace;</div>\n              <Tag onclick={handleExpand}>\n                {Object.keys(value).length}\n                {Object.keys(value).length === 1 ? 'prop' : 'props'}\n              </Tag>\n              <div class=\"jse-bracket\">&rbrace;</div>\n            {/if}\n          </div>\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError && (!expanded || !validationError.isChildError)}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if expanded}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-inside\"\n          data-type=\"insert-selection-area-inside\"\n          on:click={handleInsertInside}\n        ></div>\n      {:else if !root}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n    {#if expanded}\n      <div class=\"jse-props\">\n        {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isNodeSelected && isInsideSelection(selection)))}\n          <div\n            class=\"jse-insert-area jse-inside\"\n            class:jse-hovered={hover === HOVER_INSERT_INSIDE}\n            class:jse-selected={isNodeSelected && isInsideSelection(selection)}\n            data-type=\"insert-selection-area-inside\"\n            style:--level={path.length + 1}\n            title={INSERT_EXPLANATION}\n          >\n            <ContextMenuPointer\n              insert={true}\n              selected={isNodeSelected && isInsideSelection(selection)}\n              onContextMenu={handleInsertInsideOpenContextMenu}\n            />\n          </div>\n        {/if}\n        {#each getKeys(value, dragging) as key}\n          {@const propPointer = appendToJSONPointer(pointer, key)}\n\n          {@const nestedSearchResults = isObjectRecursiveState(searchResults)\n            ? searchResults.properties[key]\n            : undefined}\n\n          {@const nestedValidationErrors = isObjectRecursiveState(validationErrors)\n            ? validationErrors.properties[key]\n            : undefined}\n\n          {@const nestedPath = path.concat(key)}\n\n          {@const nestedSelection = selectionIfOverlapping(\n            context.getJson(),\n            selection,\n            nestedPath\n          )}\n\n          <svelte:self\n            value={value[key]}\n            pointer={propPointer}\n            state={isObjectRecursiveState(state) ? state.properties[key] : undefined}\n            validationErrors={nestedValidationErrors}\n            searchResults={nestedSearchResults}\n            selection={nestedSelection}\n            {context}\n            onDragSelectionStart={handleDragSelectionStart}\n          >\n            <div\n              slot=\"identifier\"\n              class=\"jse-key-outer\"\n              class:jse-selected-key={isKeySelection(nestedSelection) &&\n                isEqual(nestedSelection.path, nestedPath)}\n            >\n              <JSONKey\n                pointer={propPointer}\n                {key}\n                selection={nestedSelection}\n                searchResultItems={filterKeySearchResults(nestedSearchResults)}\n                {context}\n                onUpdateKey={handleUpdateKey}\n              />\n            </div>\n          </svelte:self>\n        {/each}\n      </div>\n      <div class=\"jse-footer-outer\">\n        <div data-type=\"selectable-value\" class=\"jse-footer\">\n          <div class=\"jse-bracket\">&rbrace;</div>\n        </div>\n        {#if !root}\n          <div\n            role=\"none\"\n            class=\"jse-insert-selection-area jse-after\"\n            data-type=\"insert-selection-area-after\"\n            on:click={handleInsertAfter}\n          ></div>\n        {/if}\n      </div>\n    {/if}\n  {:else}\n    <div class=\"jse-contents-outer\">\n      <div class=\"jse-contents\">\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-value-outer\">\n          <JSONValue\n            {path}\n            {value}\n            {enforceString}\n            selection={isNodeSelected ? selection : undefined}\n            searchResultItems={filterValueSearchResults(searchResults)}\n            {context}\n          />\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if !root}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n  {/if}\n  {#if !context.readOnly && (hover === HOVER_INSERT_AFTER || (isNodeSelected && isAfterSelection(selection)))}\n    <div\n      class=\"jse-insert-area jse-after\"\n      class:jse-hovered={hover === HOVER_INSERT_AFTER}\n      class:jse-selected={isNodeSelected && isAfterSelection(selection)}\n      data-type=\"insert-selection-area-after\"\n      title={INSERT_EXPLANATION}\n    >\n      <ContextMenuPointer\n        insert={true}\n        selected={isNodeSelected && isAfterSelection(selection)}\n        onContextMenu={handleInsertAfterOpenContextMenu}\n      />\n    </div>\n  {/if}\n</div>\n\n<style src=\"./JSONNode.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { initial, isEqual } from 'lodash-es'\n  import {\n    createEditKeySelection,\n    createKeySelection,\n    createValueSelection,\n    isEditingSelection,\n    isKeySelection\n  } from '$lib/logic/selection.js'\n  import SearchResultHighlighter from './highlight/SearchResultHighlighter.svelte'\n  import EditableDiv from '../../controls/EditableDiv.svelte'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import type { ExtendedSearchResultItem, JSONSelection, TreeModeContext } from '$lib/types.js'\n  import { UpdateSelectionAfterChange } from '$lib/types.js'\n  import { type JSONPath, type JSONPointer, parseJSONPointer } from 'immutable-json-patch'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n\n  export let pointer: JSONPointer\n  export let key: string\n  export let selection: JSONSelection | undefined\n  export let searchResultItems: ExtendedSearchResultItem[] | undefined\n  export let onUpdateKey: (oldKey: string, newKey: string) => string\n\n  export let context: TreeModeContext\n\n  let path: JSONPath\n  $: path = parseJSONPointer(pointer)\n\n  $: isKeySelected = isKeySelection(selection) && isEqual(selection.path, path)\n  $: isEditingKey = isKeySelected && isEditingSelection(selection)\n\n  function handleKeyDoubleClick(\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) {\n    if (!isEditingKey && !context.readOnly) {\n      event.preventDefault()\n      context.onSelect(createEditKeySelection(path))\n    }\n  }\n\n  function handleChangeValue(newKey: string, updateSelection: UpdateSelectionAfterChange) {\n    const updatedKey = onUpdateKey(key, context.normalization.unescapeValue(newKey))\n    const updatedPath = initial(path).concat(updatedKey)\n\n    context.onSelect(\n      updateSelection === UpdateSelectionAfterChange.nextInside\n        ? createValueSelection(updatedPath)\n        : createKeySelection(updatedPath)\n    )\n\n    if (updateSelection !== UpdateSelectionAfterChange.self) {\n      context.focus()\n    }\n  }\n\n  function handleCancelChange() {\n    context.onSelect(createKeySelection(path))\n    context.focus()\n  }\n</script>\n\n{#if !context.readOnly && isEditingKey}\n  <EditableDiv\n    value={context.normalization.escapeValue(key)}\n    initialValue={isEditingSelection(selection) ? selection.initialValue : undefined}\n    label=\"Edit key\"\n    shortText\n    onChange={handleChangeValue}\n    onCancel={handleCancelChange}\n    onFind={context.onFind}\n  />\n{:else}\n  <div\n    role=\"none\"\n    data-type=\"selectable-key\"\n    class=\"jse-key\"\n    class:jse-empty={key === ''}\n    on:dblclick={handleKeyDoubleClick}\n  >\n    {#if searchResultItems}\n      <SearchResultHighlighter text={context.normalization.escapeValue(key)} {searchResultItems} />\n    {:else}\n      {addNewLineSuffix(context.normalization.escapeValue(key))}\n    {/if}\n  </div>\n{/if}\n{#if !context.readOnly && isKeySelected && !isEditingKey}\n  <ContextMenuPointer selected={true} onContextMenu={context.onContextMenu} />\n{/if}\n\n<style src=\"./JSONKey.scss\"></style>\n","import type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\nimport type { IconName } from '@fortawesome/fontawesome-common-types'\n\nexport const faJSONEditorExpand: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-expand' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,448 V 512 h 512 v -64 z ' +\n      'M 0,0 V 64 H 512 V 0 Z ' +\n      'M 256,96 128,224 h 256 z ' +\n      'M 256,416 384,288 H 128 Z'\n  ]\n}\n\nexport const faJSONEditorCollapse: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-collapse' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'm 0,224 v 64 h 512 v -64 z ' + 'M 256,192 384,64 H 128 Z ' + 'M 256,320 128,448 h 256 z'\n  ]\n}\n\nexport const faJSONEditorFormat: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-format' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,32 v 64 h 416 v -64 z ' +\n      'M 160,160 v 64 h 352 v -64 z ' +\n      'M 160,288 v 64 h 288 v -64 z ' +\n      'M 0,416 v 64 h 320 v -64 z'\n  ]\n}\n\nexport const faJSONEditorCompact: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-compact' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,32 v 64 h 512 v -64 z ' + 'M 0,160 v 64 h 512 v -64 z ' + 'M 0,288 v 64 h 352 v -64 z'\n  ]\n}\n","<script lang=\"ts\">\n  interface Props {\n    readOnly: boolean\n    onCreateArray: () => void\n    onCreateObject: () => void\n    onClick: () => void\n  }\n\n  const { readOnly, onCreateArray, onCreateObject, onClick }: Props = $props()\n\n  function handleCreateObject(event: MouseEvent) {\n    event.stopPropagation()\n    onCreateObject()\n  }\n\n  function handleCreateArray(event: MouseEvent) {\n    event.stopPropagation()\n    onCreateArray()\n  }\n</script>\n\n<div class=\"jse-welcome\" onclick={() => onClick()} role=\"none\">\n  <div class=\"jse-space jse-before\"></div>\n  <div class=\"jse-contents\">\n    <div class=\"jse-welcome-title\">Empty document</div>\n    {#if !readOnly}\n      <div class=\"jse-welcome-info\">\n        You can paste clipboard data using <b>Ctrl+V</b>, or use the following options:\n      </div>\n      <button title={\"Create an empty JSON object (press '{')\"} onclick={handleCreateObject}\n        >Create object</button\n      >\n      <button title={\"Create an empty JSON array (press '[')\"} onclick={handleCreateArray}\n        >Create array</button\n      >\n    {/if}\n  </div>\n  <div class=\"jse-space jse-after\"></div>\n</div>\n\n<style src=\"./Welcome.scss\"></style>\n","import diffSequence from '../generated/diffSequence.js'\nimport type { JSONPatchDocument, JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport {\n  compileJSONPointer,\n  getIn,\n  isJSONArray,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  parseFrom,\n  parsePath,\n  setIn\n} from 'immutable-json-patch'\nimport { first, initial, isEmpty, isEqual, last } from 'lodash-es'\nimport naturalCompare from 'natural-compare-lite'\nimport { int } from '../utils/numberUtils.js'\nimport { isObject } from '../utils/typeUtils.js'\n\nexport function caseInsensitiveNaturalCompare(a: unknown, b: unknown) {\n  const aLower = typeof a === 'string' ? a.toLowerCase() : a\n  const bLower = typeof b === 'string' ? b.toLowerCase() : b\n\n  return naturalCompare(aLower, bLower)\n}\n\n/**\n * Sort a JSON object or array\n * @param json           The the JSON containing the (optionally nested)\n *                       object to be sorted\n * @param [rootPath=[]]  Relative path when the array was located\n * @param [itemPath=[]]  Item path by which to sort items in case of an array\n * @param [direction=1]  Pass 1 to sort ascending, -1 to sort descending\n * @return               Returns a JSONPatch document with move operation\n *                       to get the array sorted.\n */\nexport function sortJson(\n  json: unknown,\n  rootPath: JSONPath = [],\n  itemPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const value = getIn(json, rootPath)\n\n  if (isJSONArray(value)) {\n    if (itemPath === undefined) {\n      throw new Error('Cannot sort: no property selected by which to sort the array')\n    }\n\n    return sortArray(json, rootPath, itemPath, direction)\n  }\n\n  if (isObject(value)) {\n    return sortObjectKeys(json, rootPath, direction)\n  }\n\n  throw new Error('Cannot sort: no array or object')\n}\n\n/**\n * Sort the keys of an object\n * @param json           The the JSON containing the (optionally nested)\n *                       object to be sorted\n * @param [rootPath=[]]  Relative path when the array was located\n * @param [direction=1]  Pass 1 to sort ascending, -1 to sort descending\n * @return               Returns a JSONPatch document with operations\n *                       to get the array sorted.\n */\nexport function sortObjectKeys(\n  json: unknown,\n  rootPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const object = getIn(json, rootPath) as Record<string, unknown>\n  const keys = Object.keys(object as unknown as Record<string, unknown>)\n  const sortedKeys = keys.slice()\n\n  sortedKeys.sort((keyA, keyB) => {\n    return direction * caseInsensitiveNaturalCompare(keyA, keyB)\n  })\n\n  // for performance reasons, do a full replace (we could also create a move operation for every key)\n  const sortedObject: Record<string, unknown> = {}\n  sortedKeys.forEach((key) => (sortedObject[key] = object[key]))\n\n  return [\n    {\n      op: 'replace',\n      path: compileJSONPointer(rootPath),\n      value: sortedObject\n    }\n  ]\n}\n\n/**\n * Sort the items of an array\n * @param json               The document containing (optionally nested)\n *                           the array to be sorted.\n * @param [rootPath=[]]      Relative path when the array was located\n * @param [propertyPath=[]]  Nested path to the property on which to sort the contents\n * @param [direction=1]      Pass 1 to sort ascending, -1 to sort descending\n * @return                   Returns a JSONPatch document with move operation\n *                           to get the array sorted.\n */\nexport function sortArray(\n  json: unknown,\n  rootPath: JSONPath = [],\n  propertyPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const comparator = createObjectComparator(propertyPath, direction)\n\n  // TODO: make the mechanism to sort configurable? Like use sortOperationsMove and sortOperationsMoveAdvanced\n  const array = getIn(json, rootPath) as Array<unknown>\n  return [\n    {\n      op: 'replace',\n      path: compileJSONPointer(rootPath),\n      value: array.slice(0).sort(comparator)\n    }\n  ]\n}\n\n/**\n * Create a comparator function to compare nested properties in an array\n */\nfunction createObjectComparator(propertyPath: JSONPath, direction: 1 | -1) {\n  return function comparator(a: unknown, b: unknown) {\n    const valueA = getIn(a, propertyPath)\n    const valueB = getIn(b, propertyPath)\n\n    if (valueA === undefined) {\n      return direction\n    }\n    if (valueB === undefined) {\n      return -direction\n    }\n\n    if (typeof valueA !== 'string' && typeof valueB !== 'string') {\n      // both values are a number, boolean, or null -> use simple, fast sorting\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return valueA > valueB ? direction : valueA < valueB ? -direction : 0\n    }\n\n    return direction * caseInsensitiveNaturalCompare(valueA, valueB)\n  }\n}\n\n/**\n * Create a list with JSON Patch move operations\n * needed to sort the array contents.\n */\nexport function sortOperationsMove<T>(\n  array: T[],\n  comparator: (a: T, b: T) => number\n): JSONPatchOperation[] {\n  const operations: JSONPatchOperation[] = []\n  const sorted = []\n\n  // TODO: rewrite the function to pass a callback instead of returning an array?\n  for (let i = 0; i < array.length; i++) {\n    // TODO: can we simplify the following code?\n    const item = array[i]\n    if (i > 0 && comparator(sorted[i - 1], item) > 0) {\n      let j = i - 1\n      while (j > 0 && comparator(sorted[j - 1], item) > 0) {\n        j--\n      }\n\n      operations.push({\n        op: 'move',\n        from: '/' + i,\n        path: '/' + j\n      })\n\n      sorted.splice(j, 0, item)\n    } else {\n      sorted.push(item)\n    }\n  }\n\n  return operations\n}\n\n/**\n * Create an array containing all move operations\n * needed to sort the array contents.\n */\nexport function sortOperationsMoveAdvanced<T>(\n  array: T[],\n  comparator: (a: T, b: T) => number\n): JSONPatchOperation[] {\n  const moves: { from: number; to: number }[] = []\n\n  const sortedIndices = array\n    .map((item, index) => ({ item, index }))\n    .sort((a, b) => comparator(a.item, b.item))\n    .map((entry) => entry.index)\n\n  let bIndex = 0\n\n  function foundSubsequence(nCommon: number, aCommon: number, bCommon: number) {\n    for (let b = bIndex; b < bCommon; b++) {\n      moves.push({\n        from: sortedIndices[b],\n        to: aCommon\n      })\n    }\n\n    bIndex = bCommon + nCommon\n  }\n\n  const size = array.length\n\n  function isCommon(aIndex: number, bIndex: number) {\n    return aIndex === sortedIndices[bIndex]\n  }\n\n  diffSequence(size, size, isCommon, foundSubsequence)\n  foundSubsequence(0, size, size)\n\n  // every move will change the actual indices, so we've to adjust for that\n  // in all moves that still have to be executed\n  for (let i = 0; i < moves.length; i++) {\n    if (moves[i].to > moves[i].from) {\n      moves[i].to--\n    }\n\n    const { from, to } = moves[i]\n\n    for (let j = i + 1; j < moves.length; j++) {\n      const other = moves[j]\n      if (other.from >= from) {\n        other.from--\n      }\n      if (other.to >= from) {\n        other.to--\n      }\n      if (other.from >= to) {\n        other.from++\n      }\n      if (other.to >= to) {\n        other.to++\n      }\n    }\n  }\n\n  return moves.map(({ from, to }) => {\n    return {\n      op: 'move',\n      from: '/' + from,\n      path: '/' + to\n    }\n  })\n}\n\n/**\n * Fast solution to apply many JSON patch move operations inside a single array,\n * like applying all moves needed to sort an array.\n *\n * Throws an error when not all operations are move operation inside the same\n * array.\n */\n// TODO: write unit tests\nexport function fastPatchSort(json: unknown, operations: JSONPatchDocument): unknown {\n  if (isEmpty(operations)) {\n    // nothing to do :)\n    return json\n  }\n\n  // validate whether all operations are \"move\" operations\n  const invalidOp = operations.find((operation) => {\n    return operation.op !== 'move'\n  })\n  if (invalidOp) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not a \"move\" operation ' +\n        '(actual: ' +\n        JSON.stringify(invalidOp) +\n        ')'\n    )\n  }\n\n  // parse all paths\n  const parsedOperations: Array<{ from: JSONPath | undefined; path: JSONPath }> = operations.map(\n    (operation) => ({\n      from:\n        isJSONPatchCopy(operation) || isJSONPatchMove(operation)\n          ? parseFrom(operation.from)\n          : undefined,\n      path: parsePath(json, operation.path)\n    })\n  )\n\n  // validate whether the move actions take place in an array\n  const arrayPath = initial(first(parsedOperations)?.path)\n  const array = getIn(json, arrayPath)\n  if (!Array.isArray(array)) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not an Array ' + '(path: ' + JSON.stringify(arrayPath) + ')'\n    )\n  }\n\n  // validate whether all paths are in the same array\n  const invalidPath = parsedOperations.find((parsedOperation) => {\n    return (\n      !isEqual(arrayPath, initial(parsedOperation.path)) ||\n      !isEqual(arrayPath, initial(parsedOperation.from))\n    )\n  })\n  if (invalidPath) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not all move operations are in the same array ' +\n        '(expected: ' +\n        JSON.stringify(arrayPath) +\n        ', actual: ' +\n        JSON.stringify(invalidPath) +\n        ')'\n    )\n  }\n\n  // apply the actual operations on the same array. Only copy the only array once\n  const updatedArray = array.slice(0)\n  parsedOperations.forEach((parsedOperation) => {\n    const toIndex = int(last(parsedOperation.path) || '-1')\n    const fromIndex = int(last(parsedOperation.from) || '-1')\n\n    const value = updatedArray.splice(fromIndex, 1)[0]\n    updatedArray.splice(toIndex, 0, value)\n  })\n\n  return setIn(json, arrayPath, updatedArray)\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { limit } from '$lib/utils/arrayUtils.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n\n  export let items: (string | number)[]\n  export let selectedItem: string | number\n  export let onSelect: (item: string | number) => void\n\n  const MAX_ITEMS = 100\n  const MAX_ITEM_CHARACTERS = 30\n</script>\n\n<div class=\"jse-navigation-bar-dropdown\">\n  {#each limit(items, MAX_ITEMS) as item (item)}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-dropdown-item\"\n      class:jse-selected={item === selectedItem}\n      on:click|stopPropagation={() => onSelect(item)}\n      title={item.toString()}\n    >\n      {truncate(item.toString(), MAX_ITEM_CHARACTERS)}\n    </button>\n  {/each}\n  {#if items.length > MAX_ITEMS}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-dropdown-item\"\n      title=\"Limited to {MAX_ITEMS} items\"\n    >\n      ...\n    </button>\n  {/if}\n</div>\n\n<style src=\"./NavigationBarDropdown.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faAngleRight } from '@fortawesome/free-solid-svg-icons'\n  import NavigationBarDropdown from '../../../components/controls/navigationBar/NavigationBarDropdown.svelte'\n  import { getContext } from 'svelte'\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { AbsolutePopupContext } from '$lib/types'\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let index: number\n  export let onSelect: (path: JSONPath) => void\n  export let getItems: (path: JSONPath) => string[]\n\n  let refNavigationBarItem: Element | undefined\n  let open = false\n  let popupId: number | undefined\n\n  $: itemPath = path.slice(0, index)\n  $: selectedItem = path[index]\n\n  function handleSelectItem(item: string) {\n    closeAbsolutePopup(popupId)\n    onSelect(itemPath.concat(item))\n  }\n\n  function openDropdown() {\n    if (refNavigationBarItem) {\n      open = true\n\n      const props = {\n        items: getItems(itemPath),\n        selectedItem,\n        onSelect: handleSelectItem\n      }\n\n      popupId = openAbsolutePopup(NavigationBarDropdown, props, {\n        anchor: refNavigationBarItem,\n        closeOnOuterClick: true,\n        onClose: () => {\n          open = false\n        }\n      })\n    }\n  }\n</script>\n\n<div class=\"jse-navigation-bar-item\" bind:this={refNavigationBarItem}>\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-button jse-navigation-bar-arrow\"\n    class:jse-open={open}\n    on:click={openDropdown}\n  >\n    <Icon data={faAngleRight} />\n  </button>\n  {#if selectedItem !== undefined}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-button\"\n      on:click={() => handleSelectItem(selectedItem)}\n    >\n      {selectedItem}\n    </button>\n  {/if}\n</div>\n\n<style src=\"./NavigationBarItem.scss\"></style>\n","export default function copyToClipBoard(text: string): Promise<void> {\n  if (navigator.clipboard) {\n    return navigator.clipboard.writeText(text)\n  }\n  // Compatible with old browsers such as Chrome <=65, Edge <=18 & IE\n  // Compatible with HTTP\n  else if (document.queryCommandSupported?.('copy')) {\n    const textarea = document.createElement('textarea')\n    textarea.value = text\n\n    textarea.style.position = 'fixed' // Avoid scrolling to bottom\n    textarea.style.opacity = '0'\n\n    document.body.appendChild(textarea)\n    textarea.select()\n\n    // Security exception may be thrown by some browsers\n    try {\n      document.execCommand('copy')\n    } catch (e) {\n      console.error(e)\n    } finally {\n      document.body.removeChild(textarea)\n    }\n\n    return Promise.resolve()\n  } else {\n    console.error('Copy failed.')\n\n    return Promise.resolve()\n  }\n}\n","<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { getContext, onDestroy, onMount } from 'svelte'\n  import copyToClipBoard from '$lib/utils/copyToClipboard.js'\n  import { faCopy, faExclamationTriangle } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { tooltip } from '../../controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext, JSONPathParser, OnError } from '$lib/types.js'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let pathParser: JSONPathParser\n  export let onChange: (updatedPath: JSONPath) => void\n  export let onClose: () => void\n  export let onError: OnError\n  export let pathExists: (path: JSONPath) => boolean\n\n  let inputRef: HTMLInputElement\n  let inputPath: string\n  let validationActive = false\n  $: inputPath = pathParser.stringify(path)\n  $: inputValidationError = validationActive ? parseAndValidate(inputPath).error : undefined\n\n  let copiedTimer: number | undefined = undefined\n  let copied = false\n  const copiedDelay = 1000 // ms\n\n  onMount(() => {\n    focus()\n  })\n\n  onDestroy(() => {\n    clearTimeout(copiedTimer)\n  })\n\n  function focus() {\n    inputRef.focus()\n  }\n\n  function parseAndValidate(pathStr: string): {\n    path: JSONPath | undefined\n    error: Error | undefined\n  } {\n    try {\n      const path = pathParser.parse(pathStr)\n      validatePathExists(path)\n      return {\n        path,\n        error: undefined\n      }\n    } catch (error) {\n      return {\n        path: undefined,\n        error: error as Error\n      }\n    }\n  }\n\n  function validatePathExists(path: JSONPath) {\n    if (!pathExists(path)) {\n      throw new Error('Path does not exist in current document')\n    }\n  }\n\n  function handleInput(event: Event & { currentTarget: EventTarget & HTMLInputElement }) {\n    inputPath = event.currentTarget.value\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Escape') {\n      event.preventDefault()\n      onClose()\n    }\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n\n      validationActive = true\n      const result = parseAndValidate(inputPath)\n      if (result.path !== undefined) {\n        onChange(result.path)\n      } else {\n        onError(result.error as Error)\n      }\n    }\n  }\n\n  function handleCopy() {\n    copyToClipBoard(inputPath)\n    copied = true\n    copiedTimer = window.setTimeout(() => (copied = false), copiedDelay)\n    focus()\n  }\n</script>\n\n<div class=\"jse-navigation-bar-path-editor\" class:error={inputValidationError}>\n  <input\n    type=\"text\"\n    class=\"jse-navigation-bar-text\"\n    value={inputPath}\n    bind:this={inputRef}\n    on:keydown|stopPropagation={handleKeyDown}\n    on:input={handleInput}\n  />\n  {#if inputValidationError}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-validation-error\"\n      use:tooltip={{\n        text: String(inputValidationError || ''),\n        ...absolutePopupContext\n      }}\n    >\n      <Icon data={faExclamationTriangle} />\n    </button>\n  {/if}\n  {#if copied}\n    <div class=\"jse-copied-text\">Copied!</div>\n  {/if}\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-copy\"\n    class:copied\n    title=\"Copy selected path to the clipboard\"\n    on:click={handleCopy}\n  >\n    <Icon data={faCopy} />\n  </button>\n</div>\n\n<style src=\"./NavigationBarPathEditor.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { existsIn, getIn } from 'immutable-json-patch'\n  import { range } from 'lodash-es'\n  import { isObject, isObjectOrArray } from '$lib/utils/typeUtils.js'\n  import { createMultiSelection, getFocusPath } from '$lib/logic/selection.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { caseInsensitiveNaturalCompare } from '$lib/logic/sort.js'\n  import type { JSONPathParser, JSONSelection, OnError, OnJSONSelect } from '$lib/types.js'\n  import Icon from 'svelte-awesome'\n  import { faClose, faEdit } from '@fortawesome/free-solid-svg-icons'\n  import NavigationBarItem from './NavigationBarItem.svelte'\n  import NavigationBarPathEditor from './NavigationBarPathEditor.svelte'\n\n  const debug = createDebug('jsoneditor:NavigationBar')\n\n  export let json: unknown\n  export let selection: JSONSelection | undefined\n  export let onSelect: OnJSONSelect\n  export let onError: OnError\n  export let pathParser: JSONPathParser\n\n  let refNavigationBar: Element | undefined\n  let editing = false\n\n  $: path = selection ? getFocusPath(selection) : []\n  $: hasNextItem = isObjectOrArray(getIn(json, path))\n\n  // we have an unused parameter path to trigger scrollToLastItem when path changes,\n  // see $: scrollToLastItem(path)\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function scrollToLastItem(path: JSONPath) {\n    setTimeout(() => {\n      if (refNavigationBar && refNavigationBar.scrollTo) {\n        const left = refNavigationBar.scrollWidth - refNavigationBar.clientWidth\n        if (left > 0) {\n          debug('scrollTo ', left)\n          refNavigationBar.scrollTo({ left, behavior: 'smooth' })\n        }\n      }\n    })\n  }\n\n  // trigger scrollToLastItem when path changes\n  $: scrollToLastItem(path)\n\n  function getItems(path: JSONPath): string[] {\n    debug('get items for path', path)\n\n    const node = getIn(json, path)\n    if (Array.isArray(node)) {\n      return range(0, node.length).map(String)\n    } else if (isObject(node)) {\n      const keys = Object.keys(node)\n\n      const sortedKeys = keys.slice(0)\n      sortedKeys.sort(caseInsensitiveNaturalCompare)\n\n      return sortedKeys\n    } else {\n      // never happens but just for robustness...\n      return []\n    }\n  }\n\n  function pathExists(path: JSONPath): boolean {\n    return existsIn(json, path)\n  }\n\n  function handleSelect(path: JSONPath) {\n    debug('select path', JSON.stringify(path))\n\n    onSelect(createMultiSelection(path, path))\n  }\n\n  function toggleEditing() {\n    editing = !editing\n  }\n\n  function handleCloseEditor() {\n    editing = false\n  }\n\n  function handleChangePath(path: JSONPath) {\n    handleCloseEditor()\n    handleSelect(path)\n  }\n</script>\n\n<div class=\"jse-navigation-bar\" bind:this={refNavigationBar}>\n  {#if !editing}\n    <!-- eslint-disable-next-line @typescript-eslint/no-unused-vars -->\n    {#each path as item, index (index)}\n      <NavigationBarItem {getItems} {path} {index} onSelect={handleSelect} />\n    {/each}\n    {#if hasNextItem}\n      <NavigationBarItem {getItems} {path} index={path.length} onSelect={handleSelect} />\n    {/if}\n  {:else}\n    <NavigationBarPathEditor\n      {path}\n      onClose={handleCloseEditor}\n      onChange={handleChangePath}\n      {onError}\n      {pathExists}\n      {pathParser}\n    />\n  {/if}\n\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-edit\"\n    class:flex={!editing}\n    class:editing\n    title={editing ? 'Cancel editing the selected path' : 'Edit the selected path'}\n    on:click={toggleEditing}\n  >\n    <span class=\"jse-navigation-bar-space\">\n      <!-- ensure the right height (arrows have less height than the text) -->\n      {!isObjectOrArray(json) && !editing ? 'Navigation bar' : '\\u00A0'}\n    </span>\n\n    <Icon data={editing ? faClose : faEdit} />\n  </button>\n</div>\n\n<style src=\"./NavigationBar.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { debounce } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import {\n    faCaretDown,\n    faCaretRight,\n    faChevronDown,\n    faChevronUp,\n    faCircleNotch,\n    faSearch,\n    faTimes\n  } from '@fortawesome/free-solid-svg-icons'\n  import { DEBOUNCE_DELAY, MAX_SEARCH_RESULTS } from '$lib/constants.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { DocumentState, JSONParser, OnPatch, SearchResultDetails } from '$lib/types.js'\n  import {\n    createSearchAndReplaceAllOperations,\n    createSearchAndReplaceOperations,\n    search,\n    searchNext,\n    searchPrevious,\n    updateSearchResult\n  } from '$lib/logic/search.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { flushSync } from 'svelte'\n\n  const debug = createDebug('jsoneditor:SearchBox')\n\n  export let json: unknown\n  export let documentState: DocumentState | undefined\n  export let parser: JSONParser\n  export let showSearch: boolean\n  export let showReplace: boolean\n  export let readOnly: boolean\n  export let columns: JSONPath[] | undefined\n  export let onSearch: (result: SearchResultDetails | undefined) => void\n  export let onFocus: (path: JSONPath, resultIndex: number) => Promise<void>\n  export let onPatch: OnPatch\n  export let onClose: () => void\n\n  let text = ''\n  let appliedText = ''\n  let replaceText = ''\n  let searching = false\n  let searchResult: SearchResultDetails | undefined\n\n  $: resultCount = searchResult?.items?.length || 0\n  $: activeIndex = searchResult?.activeIndex || 0\n  $: formattedResultCount =\n    resultCount >= MAX_SEARCH_RESULTS ? `${MAX_SEARCH_RESULTS - 1}+` : String(resultCount)\n\n  $: onSearch(searchResult)\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyChangedShowSearch(showSearch)\n\n  const applyChangedSearchTextDebounced = debounce(applyChangedSearchText, DEBOUNCE_DELAY)\n  $: applyChangedSearchTextDebounced(text)\n\n  const applyChangedJsonDebounced = debounce(applyChangedJson, DEBOUNCE_DELAY)\n  $: applyChangedJsonDebounced(json)\n\n  function toggleShowReplace() {\n    showReplace = !showReplace && !readOnly\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    // key events must not be handled by the generic keydown handler of the\n    // whole JSONEditor.\n    event.stopPropagation()\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n\n      const pendingChanges = text !== appliedText\n      if (pendingChanges) {\n        applyChangedSearchTextDebounced.flush()\n      } else {\n        handleNext()\n      }\n    }\n\n    if (combo === 'Shift+Enter') {\n      event.preventDefault()\n      handlePrevious()\n    }\n\n    if (combo === 'Ctrl+Enter') {\n      event.preventDefault()\n\n      if (showReplace) {\n        handleReplace()\n      } else {\n        handleNext()\n        // TODO: move focus to the active element so you can start editing?\n      }\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      toggleShowReplace()\n    }\n\n    if (combo === 'Escape') {\n      event.preventDefault()\n\n      handleClose()\n    }\n  }\n\n  function handleReplaceKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n      event.stopPropagation()\n\n      handleReplace()\n    }\n  }\n\n  async function handlePaste() {\n    flushSync()\n    await applyChangedSearchTextDebounced.flush()\n  }\n\n  async function handleReplace() {\n    if (readOnly) {\n      return\n    }\n\n    const activeItem = searchResult?.activeItem\n    debug('handleReplace', { replaceText, activeItem })\n\n    if (!searchResult || !activeItem || json === undefined) {\n      return\n    }\n\n    // move to the next search result *before* applying the replacement\n    searchResult = {\n      ...searchNext(searchResult),\n      activeIndex // trick to prevent shortly flickering of index from 1 to 2 and then to 1 again after the next search\n    }\n\n    const { operations, newSelection } = createSearchAndReplaceOperations(\n      json,\n      documentState,\n      replaceText,\n      activeItem,\n      parser\n    )\n\n    onPatch(operations, (_, patchedState) => ({\n      state: patchedState,\n      selection: newSelection\n    }))\n\n    // immediately trigger updating the search results\n    flushSync()\n    await applyChangedJsonDebounced.flush()\n\n    // focus to the next search result\n    await handleFocus()\n  }\n\n  async function handleReplaceAll() {\n    if (readOnly) {\n      return\n    }\n\n    debug('handleReplaceAll', { text, replaceText })\n\n    const { operations, newSelection } = createSearchAndReplaceAllOperations(\n      json,\n      documentState,\n      text,\n      replaceText,\n      parser\n    )\n\n    onPatch(operations, (_, patchedState) => ({\n      state: patchedState,\n      selection: newSelection\n    }))\n\n    await handleFocus()\n  }\n\n  function initSearchInput(element: HTMLInputElement) {\n    element.select()\n  }\n\n  async function handleNext() {\n    searchResult = searchResult ? searchNext(searchResult) : undefined\n\n    await handleFocus()\n  }\n\n  async function handlePrevious() {\n    searchResult = searchResult ? searchPrevious(searchResult) : undefined\n\n    await handleFocus()\n  }\n\n  async function handleFocus() {\n    debug('handleFocus', searchResult)\n\n    const activeItem = searchResult?.activeItem\n    if (activeItem && json !== undefined) {\n      await onFocus(activeItem.path, activeItem.resultIndex)\n    }\n  }\n\n  async function applyChangedShowSearch(showSearch: boolean) {\n    await applySearch(showSearch, text, json)\n  }\n\n  async function applyChangedSearchText(text: string) {\n    await applySearch(showSearch, text, json)\n    await handleFocus()\n  }\n\n  async function applyChangedJson(json: unknown) {\n    await applySearch(showSearch, text, json)\n  }\n\n  // we pass searchText and json as argument to trigger search when these variables change,\n  // via various listeners like applyChangedSearchText\n  async function applySearch(showSearch: boolean, text: string, json: unknown): Promise<void> {\n    if (!showSearch) {\n      if (searchResult) {\n        searchResult = undefined\n      }\n\n      return Promise.resolve()\n    }\n\n    debug('applySearch', { showSearch, text })\n\n    if (text === '') {\n      debug('clearing search result')\n\n      if (searchResult !== undefined) {\n        searchResult = undefined\n      }\n\n      return Promise.resolve()\n    }\n\n    appliedText = text\n    searching = true\n\n    return new Promise<void>((resolve) => {\n      setTimeout(() => {\n        // wait until the search icon has been rendered\n        const newResultItems = search(text, json, { maxResults: MAX_SEARCH_RESULTS, columns })\n        searchResult = updateSearchResult(newResultItems, searchResult)\n\n        searching = false\n        resolve()\n      })\n    })\n  }\n\n  function handleClose() {\n    debug('handleClose')\n    applyChangedSearchTextDebounced.cancel()\n    applyChangedJsonDebounced.cancel()\n    applySearch(false, text, json) // will clear the search results\n    onClose()\n  }\n</script>\n\n{#if showSearch}\n  <div class=\"jse-search-box\">\n    <!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n    <form class=\"jse-search-form\" on:keydown={handleKeyDown}>\n      {#if !readOnly}\n        <button\n          type=\"button\"\n          class=\"jse-replace-toggle\"\n          title=\"Toggle visibility of replace options (Ctrl+H)\"\n          on:click={toggleShowReplace}\n        >\n          <Icon data={showReplace ? faCaretDown : faCaretRight} />\n        </button>\n      {/if}\n      <div class=\"jse-search-contents\">\n        <div class=\"jse-search-section\">\n          <div class=\"jse-search-icon\">\n            {#if searching}\n              <Icon data={faCircleNotch} spin />\n            {:else}\n              <Icon data={faSearch} />\n            {/if}\n          </div>\n          <label class=\"jse-search-input-label\" about=\"jse-search input\">\n            <input\n              class=\"jse-search-input\"\n              title=\"Enter text to search\"\n              type=\"text\"\n              placeholder=\"Find\"\n              bind:value={text}\n              use:initSearchInput\n              on:paste={handlePaste}\n            />\n          </label>\n          <div class=\"jse-search-count\" class:jse-visible={text !== ''}>\n            {activeIndex !== -1 && activeIndex < resultCount\n              ? `${activeIndex + 1}/`\n              : ''}{formattedResultCount}\n          </div>\n          <button\n            type=\"button\"\n            class=\"jse-search-next\"\n            title=\"Go to next search result (Enter)\"\n            on:click={handleNext}\n          >\n            <Icon data={faChevronDown} />\n          </button>\n          <button\n            type=\"button\"\n            class=\"jse-search-previous\"\n            title=\"Go to previous search result (Shift+Enter)\"\n            on:click={handlePrevious}\n          >\n            <Icon data={faChevronUp} />\n          </button>\n          <button\n            type=\"button\"\n            class=\"jse-search-clear\"\n            title=\"Close search box (Esc)\"\n            on:click={handleClose}\n          >\n            <Icon data={faTimes} />\n          </button>\n        </div>\n        {#if showReplace && !readOnly}\n          <div class=\"jse-replace-section\">\n            <input\n              class=\"jse-replace-input\"\n              title=\"Enter replacement text\"\n              type=\"text\"\n              placeholder=\"Replace\"\n              bind:value={replaceText}\n              on:keydown={handleReplaceKeyDown}\n            />\n            <button\n              type=\"button\"\n              title=\"Replace current occurrence (Ctrl+Enter)\"\n              on:click={handleReplace}>Replace</button\n            >\n            <button type=\"button\" title=\"Replace all occurrences\" on:click={handleReplaceAll}\n              >All</button\n            >\n          </div>\n        {/if}\n      </div>\n    </form>\n  </div>\n{/if}\n\n<style src=\"./SearchBox.scss\"></style>\n","import type { JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport {\n  compileJSONPointer,\n  isJSONArray,\n  isJSONObject,\n  parseJSONPointer\n} from 'immutable-json-patch'\nimport { groupBy, isEmpty, isEqual, mapValues, partition } from 'lodash-es'\nimport type { JSONSelection, SortedColumn, TableCellIndex, ValidationError } from '$lib/types.js'\nimport { ValidationSeverity } from '$lib/types.js'\nimport { createValueSelection, getFocusPath, pathStartsWith } from './selection.js'\nimport { containsNumber } from '../utils/numberUtils.js'\nimport type { Dictionary } from 'lodash'\nimport { stringifyJSONPath } from '$lib/utils/pathUtils.js'\nimport { forEachSample } from '$lib/utils/arrayUtils.js'\nimport { isObject } from '$lib/utils/typeUtils.js'\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype NestedObject = Record<string, NestedObject>\n\nconst endOfPath = Symbol('path')\n\nexport function getColumns(\n  array: Array<unknown>,\n  flatten: boolean,\n  maxSampleCount = Infinity\n): JSONPath[] {\n  const merged: NestedObject = {}\n\n  if (Array.isArray(array)) {\n    // We read samples spread through the whole array, from begin to end.\n    // When the array is sorted, and a specific field is present only at the last\n    // couple of items of the array or in the middle, we want to pick that up too.\n    forEachSample(array, maxSampleCount, (item) => {\n      if (isObject(item)) {\n        _recurseObject(item, merged, flatten)\n      } else {\n        merged[endOfPath] = true\n      }\n    })\n  }\n\n  const paths: JSONPath[] = []\n  if (endOfPath in merged) {\n    paths.push([])\n  }\n  _collectPaths(merged, [], paths, flatten)\n\n  return paths\n}\n\n// internal function for getColumns\n// mutates the argument merged\nfunction _recurseObject(object: NestedObject, merged: NestedObject, flatten: boolean): void {\n  for (const key in object) {\n    const value = object[key]\n    const valueMerged = merged[key] || (merged[key] = {})\n\n    if (isObject(value) && flatten) {\n      _recurseObject(value, valueMerged, flatten)\n    } else {\n      if (valueMerged[endOfPath] === undefined) {\n        valueMerged[endOfPath] = true\n      }\n    }\n  }\n}\n\n// internal function for getColumns\n// mutates the argument paths\nfunction _collectPaths(\n  object: NestedObject,\n  parentPath: JSONPath,\n  paths: JSONPath[],\n  flatten: boolean\n): void {\n  for (const key in object) {\n    const path = parentPath.concat(key)\n    const value = object[key]\n\n    if (value && value[endOfPath] === true) {\n      paths.push(path)\n    }\n\n    if (isJSONObject(value) && flatten) {\n      _collectPaths(value, path, paths, flatten)\n    }\n  }\n}\n\nexport function maintainColumnOrder(\n  newColumns: JSONPath[],\n  previousColumns: JSONPath[]\n): JSONPath[] {\n  const orderedColumns = new Set(previousColumns.map(compileJSONPointer))\n  const newColumnsSet = new Set(newColumns.map(compileJSONPointer))\n\n  // delete the columns that are gone now\n  for (const column of orderedColumns) {\n    if (!newColumnsSet.has(column)) {\n      orderedColumns.delete(column)\n    }\n  }\n\n  // append the new columns to the end\n  for (const column of newColumnsSet) {\n    if (!orderedColumns.has(column)) {\n      orderedColumns.add(column)\n    }\n  }\n\n  return [...orderedColumns].map(parseJSONPointer)\n}\n\nexport function getShallowKeys(value: unknown): JSONPath[] {\n  return isJSONObject(value) ? Object.keys(value).map((key) => [key]) : [[]]\n}\n\nexport function getRecursiveKeys(value: unknown): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  function recurse(value: unknown, path: JSONPath) {\n    if (isJSONObject(value)) {\n      Object.keys(value).forEach((key) => {\n        recurse(value[key], path.concat(key))\n      })\n    } else {\n      // array or primitive value like string or number\n      paths.push(path)\n    }\n  }\n\n  recurse(value, [])\n\n  return paths\n}\n\nexport interface VisibleSection {\n  startIndex: number\n  endIndex: number\n  startHeight: number\n  visibleHeight: number\n  endHeight: number\n  averageItemHeight: number\n  visibleItems: Array<unknown>\n}\n\n// TODO: write unit tests\nexport function calculateVisibleSection(\n  scrollTop: number,\n  viewPortHeight: number,\n  json: unknown | undefined,\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number,\n  searchBoxOffset: number,\n  margin = 80\n): VisibleSection {\n  const itemCount = isJSONArray(json) ? json.length : 0\n  const averageItemHeight = calculateAverageItemHeight(itemHeights, defaultItemHeight)\n  const viewPortTop = scrollTop - margin\n  const viewPortBottom = viewPortHeight + 2 * margin\n\n  const getItemHeight = (index: number) => itemHeights[index] || defaultItemHeight\n\n  let startIndex = 0\n  let startHeight = searchBoxOffset\n  while (startHeight < viewPortTop && startIndex < itemCount) {\n    startHeight += getItemHeight(startIndex)\n    startIndex++\n  }\n  if (startIndex > 0) {\n    // go one item back, else there is white space at the top for up to 1 missing item\n    startIndex--\n    startHeight -= getItemHeight(startIndex)\n  }\n\n  let endIndex = startIndex\n  let visibleHeight = 0\n  while (visibleHeight < viewPortBottom && endIndex < itemCount) {\n    visibleHeight += getItemHeight(endIndex)\n    endIndex++\n  }\n\n  let endHeight = 0\n  for (let i = endIndex; i < itemCount; i++) {\n    endHeight += getItemHeight(i)\n  }\n\n  const visibleItems = isJSONArray(json) ? json.slice(startIndex, endIndex) : []\n\n  return {\n    startIndex,\n    endIndex,\n    startHeight,\n    endHeight,\n    averageItemHeight,\n    visibleHeight,\n    visibleItems\n  }\n}\n\n// TODO: cleanup if we will not use it in the end\n// TODO: write unit tests\nexport function calculateVisibleSectionApprox(\n  scrollTop: number,\n  viewPortHeight: number,\n  json: unknown | undefined,\n  defaultItemHeight: number\n): VisibleSection {\n  const itemCount = isJSONArray(json) ? json.length : 0\n  const averageItemHeight = defaultItemHeight\n\n  const viewPortTop = scrollTop\n  const startIndex = Math.floor(viewPortTop / defaultItemHeight)\n  const startHeight = startIndex * defaultItemHeight\n  const endIndex = Math.ceil((viewPortTop + viewPortHeight) / defaultItemHeight)\n  const visibleHeight = (endIndex - startIndex) * defaultItemHeight\n  const endHeight = (itemCount - endIndex) * defaultItemHeight\n\n  const visibleItems = isJSONArray(json) ? json.slice(startIndex, endIndex) : []\n\n  return {\n    startIndex,\n    endIndex,\n    startHeight,\n    endHeight,\n    averageItemHeight,\n    visibleHeight,\n    visibleItems\n  }\n}\n\n// TODO: write unit tests\nexport function calculateAbsolutePosition(\n  path: JSONPath,\n  columns: JSONPath[],\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number\n): number {\n  const { rowIndex } = toTableCellPosition(path, columns)\n\n  let top = 0\n  for (let currentIndex = 0; currentIndex < rowIndex; currentIndex++) {\n    top += itemHeights[currentIndex] || defaultItemHeight\n  }\n\n  // TODO: also calculate left\n  return top\n}\n\nfunction calculateAverageItemHeight(\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number\n): number {\n  const values = Object.values(itemHeights) // warning: itemHeights is mutated and not updated itself, we can't watch it!\n  if (isEmpty(values)) {\n    return defaultItemHeight\n  }\n\n  const add = (a: number, b: number) => a + b\n  const total = values.reduce(add)\n  return total / values.length\n}\n\nexport function selectPreviousRow(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (rowIndex > 0) {\n    const previousPosition = { rowIndex: rowIndex - 1, columnIndex }\n    const previousPath = fromTableCellPosition(previousPosition, columns)\n    return createValueSelection(previousPath)\n  }\n\n  return selection\n}\n\nexport function selectNextRow(\n  json: unknown,\n  columns: JSONPath[],\n  selection: JSONSelection\n): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (rowIndex < (json as Array<unknown>).length - 1) {\n    const nextPosition = { rowIndex: rowIndex + 1, columnIndex }\n    const nextPath = fromTableCellPosition(nextPosition, columns)\n    return createValueSelection(nextPath)\n  }\n\n  return selection\n}\n\nexport function selectPreviousColumn(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (columnIndex > 0) {\n    const previousPosition = { rowIndex, columnIndex: columnIndex - 1 }\n    const previousPath = fromTableCellPosition(previousPosition, columns)\n    return createValueSelection(previousPath)\n  }\n\n  return selection\n}\n\nexport function selectNextColumn(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (columnIndex < columns.length - 1) {\n    const nextPosition = { rowIndex, columnIndex: columnIndex + 1 }\n    const nextPath = fromTableCellPosition(nextPosition, columns)\n    return createValueSelection(nextPath)\n  }\n\n  return selection\n}\n\nexport function toTableCellPosition(path: JSONPath, columns: JSONPath[]): TableCellIndex {\n  const [index, ...column] = path\n\n  const rowIndex = parseInt(index, 10)\n\n  return {\n    rowIndex: !isNaN(rowIndex) ? rowIndex : -1,\n    columnIndex: columns.findIndex((c) => pathStartsWith(column, c))\n  }\n}\n\nexport function fromTableCellPosition(position: TableCellIndex, columns: JSONPath[]): JSONPath {\n  const { rowIndex, columnIndex } = position\n\n  return [String(rowIndex), ...columns[columnIndex]]\n}\n\nexport function stringifyTableCellPosition(position: TableCellIndex): string {\n  const { rowIndex, columnIndex } = position\n\n  return `${rowIndex}:${columnIndex}`\n}\n\ninterface GroupedValidationErrorsByRow {\n  row: ValidationError[]\n  columns: Dictionary<ValidationError[]>\n}\n\nexport interface GroupedValidationErrors {\n  root: ValidationError[]\n  rows: Dictionary<GroupedValidationErrorsByRow>\n}\n\n/**\n * Group validation errors for use in the Table view: per column, and a group for the row as a whole\n */\nexport function groupValidationErrors(\n  validationErrors: ValidationError[],\n  columns: JSONPath[]\n): GroupedValidationErrors {\n  const [arrayErrors, rootErrors] = partition(validationErrors, (validationError) =>\n    containsNumber(validationError.path[0])\n  )\n\n  const errorsByRow: Dictionary<ValidationError[]> = groupBy(arrayErrors, findRowIndex)\n\n  const groupedErrorsByRow = mapValues(errorsByRow, (errors) => {\n    const groupByRow: GroupedValidationErrorsByRow = {\n      row: [],\n      columns: {}\n    }\n\n    errors.forEach((error) => {\n      const columnIndex = findColumnIndex(error, columns)\n\n      if (columnIndex !== -1) {\n        if (groupByRow.columns[columnIndex] === undefined) {\n          groupByRow.columns[columnIndex] = []\n        }\n        groupByRow.columns[columnIndex].push(error)\n      } else {\n        groupByRow.row.push(error)\n      }\n    })\n\n    return groupByRow\n  })\n\n  return {\n    root: rootErrors,\n    rows: groupedErrorsByRow\n  }\n}\n\nexport function mergeValidationErrors(\n  path: JSONPath,\n  validationErrors: ValidationError[] | undefined\n): ValidationError | undefined {\n  if (!validationErrors || validationErrors.length === 0) {\n    return undefined\n  }\n\n  if (validationErrors.length === 1) {\n    return validationErrors[0]\n  }\n\n  return {\n    path,\n    message:\n      'Multiple validation issues: ' +\n      validationErrors\n        .map((error) => {\n          return stringifyJSONPath(error.path) + ' ' + error.message\n        })\n        .join(', '),\n    severity: ValidationSeverity.warning\n  }\n}\n\nfunction findRowIndex(error: ValidationError): number {\n  return parseInt(error.path[0], 10)\n}\n\nfunction findColumnIndex(error: ValidationError, columns: JSONPath[]): number {\n  const position = toTableCellPosition(error.path, columns)\n\n  if (position.columnIndex !== -1) {\n    return position.columnIndex\n  }\n\n  return -1\n}\n\n/**\n * Clear the sorted column from the documentState when it is affected by the operations\n */\nexport function clearSortedColumnWhenAffectedByOperations(\n  sortedColumn: SortedColumn | undefined,\n  operations: JSONPatchOperation[],\n  columms: JSONPath[]\n): SortedColumn | undefined {\n  const mustBeCleared = operations.some((operation) =>\n    operationAffectsSortedColumn(sortedColumn, operation, columms)\n  )\n\n  return mustBeCleared ? undefined : sortedColumn\n}\n\nexport function operationAffectsSortedColumn(\n  sortedColumn: SortedColumn | undefined,\n  operation: JSONPatchOperation,\n  columns: JSONPath[]\n): boolean {\n  if (!sortedColumn) {\n    return false\n  }\n\n  // an operation of replacing a value in a different column does not affect the currently sorted order\n  if (operation.op === 'replace') {\n    const path = parseJSONPointer(operation.path)\n    const { rowIndex, columnIndex } = toTableCellPosition(path, columns)\n    const selectedColumnIndex = columns.findIndex((column) => isEqual(column, sortedColumn.path))\n\n    if (rowIndex !== -1 && columnIndex !== -1 && columnIndex !== selectedColumnIndex) {\n      return false\n    }\n  }\n\n  // TODO: there are more cases where we can known an operation does not affect the sorted order, improve this\n  //  For example adding a nested value in a different column, or removing a full row.\n\n  return true\n}\n\n/**\n * Find nested arrays inside a JSON object\n */\nexport function findNestedArrays(json: unknown, maxLevel = 2): JSONPath[] {\n  const props: JSONPath[] = []\n\n  function recurse(value: unknown, path: JSONPath) {\n    if (isJSONObject(value) && path.length < maxLevel) {\n      Object.keys(value).forEach((key) => {\n        recurse(value[key], path.concat(key))\n      })\n    }\n\n    if (isJSONArray(value)) {\n      props.push(path)\n    }\n  }\n\n  recurse(json, [])\n\n  return props\n}\n","import {\n  createEditKeySelection,\n  createEditValueSelection,\n  createInsideSelection,\n  createMultiSelection,\n  createValueSelection,\n  getFocusPath,\n  hasSelectionContents,\n  isKeySelection,\n  isValueSelection,\n  selectionToPartialJson\n} from '$lib/logic/selection.js'\nimport copyToClipboard from '$lib/utils/copyToClipboard.js'\nimport {\n  append,\n  createNewValue,\n  createRemoveOperations,\n  duplicate,\n  insert,\n  insertBefore,\n  removeAll\n} from '$lib/logic/operations.js'\nimport type {\n  AfterPatchCallback,\n  InsertType,\n  JSONParser,\n  JSONSelection,\n  OnChange,\n  OnChangeText,\n  OnJSONSelect,\n  OnPatch\n} from '$lib/types'\nimport { createDebug } from '$lib/utils/debug.js'\nimport {\n  getIn,\n  isJSONObject,\n  isJSONPatchAdd,\n  isJSONPatchReplace,\n  type JSONPath,\n  parsePath\n} from 'immutable-json-patch'\nimport { isObject, isObjectOrArray } from '$lib/utils/typeUtils.js'\nimport { expandAll, expandNone, expandPath, expandSmart } from '$lib/logic/documentState.js'\nimport { initial, isEmpty, last } from 'lodash-es'\nimport { fromTableCellPosition, toTableCellPosition } from '$lib/logic/table.js'\n\nconst debug = createDebug('jsoneditor:actions')\n\nexport interface OnCutAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  indentation: string | number | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n}\n\n// TODO: write unit tests\nexport async function onCut({\n  json,\n  selection,\n  indentation,\n  readOnly,\n  parser,\n  onPatch\n}: OnCutAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const clipboard = selectionToPartialJson(json, selection, indentation, parser)\n  if (clipboard === undefined) {\n    return\n  }\n\n  debug('cut', { selection, clipboard, indentation })\n\n  await copyToClipboard(clipboard)\n\n  const { operations, newSelection } = createRemoveOperations(json, selection)\n\n  onPatch(operations, (_, patchedState) => ({\n    state: patchedState,\n    selection: newSelection\n  }))\n}\n\nexport interface OnCopyAction {\n  json: unknown\n  selection: JSONSelection | undefined\n  indentation: string | number | undefined\n  parser: JSONParser\n}\n\n// TODO: write unit tests\nexport async function onCopy({ json, selection, indentation, parser }: OnCopyAction) {\n  const clipboard = selectionToPartialJson(json, selection, indentation, parser)\n  if (clipboard === undefined) {\n    return\n  }\n\n  debug('copy', { clipboard, indentation })\n\n  await copyToClipboard(clipboard)\n}\n\ntype RepairModalCallback = (text: string, onApply: (repairedText: string) => void) => void\n\ninterface OnPasteAction {\n  clipboardText: string\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onChangeText: OnChangeText\n  openRepairModal: RepairModalCallback\n}\n\n// TODO: write unit tests\nexport function onPaste({\n  clipboardText,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onChangeText,\n  openRepairModal\n}: OnPasteAction) {\n  if (readOnly) {\n    return\n  }\n\n  function doPaste(pastedText: string) {\n    if (json !== undefined) {\n      const ensureSelection = selection || createValueSelection([])\n\n      const operations = insert(json, ensureSelection, pastedText, parser)\n\n      debug('paste', { pastedText, operations, ensureSelection })\n\n      onPatch(operations, (patchedJson, patchedState) => {\n        let updatedState = patchedState\n\n        // expand newly inserted object/array\n        operations\n          .filter(\n            (operation) =>\n              (isJSONPatchAdd(operation) || isJSONPatchReplace(operation)) &&\n              isObjectOrArray(operation.value)\n          )\n          .forEach((operation) => {\n            const path = parsePath(json, operation.path)\n            updatedState = expandSmart(patchedJson, updatedState, path)\n          })\n\n        return {\n          state: updatedState\n        }\n      })\n    } else {\n      // no json: empty document, or the contents is invalid text\n      debug('paste text', { pastedText })\n\n      onChangeText(clipboardText, (patchedJson, patchedState) => {\n        if (patchedJson) {\n          const path: JSONPath = []\n          return {\n            state: expandSmart(patchedJson, patchedState, path)\n          }\n        }\n\n        return undefined\n      })\n    }\n  }\n\n  try {\n    doPaste(clipboardText)\n  } catch {\n    openRepairModal(clipboardText, (repairedText) => {\n      debug('repaired pasted text: ', repairedText)\n      doPaste(repairedText)\n    })\n  }\n}\n\nexport interface OnRemoveAction {\n  json: unknown | undefined\n  text: string | undefined\n  selection: JSONSelection | undefined\n  keepSelection: boolean\n  readOnly: boolean\n  onChange: OnChange\n  onPatch: OnPatch\n}\n\n// TODO: write unit tests\nexport function onRemove({\n  json,\n  text,\n  selection,\n  keepSelection,\n  readOnly,\n  onChange,\n  onPatch\n}: OnRemoveAction) {\n  if (readOnly || !selection) {\n    return\n  }\n\n  // in case of a selected key or value, we change the selection to the whole\n  // entry to remove this, we do not want to clear a key or value only.\n  const removeSelection =\n    json !== undefined && (isKeySelection(selection) || isValueSelection(selection))\n      ? createMultiSelection(selection.path, selection.path)\n      : selection\n\n  if (isEmpty(getFocusPath(selection))) {\n    // root selected -> clear complete document\n    debug('remove root', { selection })\n\n    if (onChange) {\n      onChange(\n        { text: '', json: undefined },\n        json !== undefined ? { text: undefined, json } : { text: text || '', json },\n        {\n          contentErrors: undefined,\n          patchResult: undefined\n        }\n      )\n    }\n  } else {\n    // remove selection\n    if (json !== undefined) {\n      const { operations, newSelection } = createRemoveOperations(json, removeSelection)\n\n      debug('remove', { operations, selection, newSelection })\n\n      onPatch(operations, (_, patchedState) => ({\n        state: patchedState,\n        selection: keepSelection ? selection : newSelection\n      }))\n    }\n  }\n}\n\nexport interface OnDuplicateRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onDuplicateRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnDuplicateRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('duplicate row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const operations = duplicate(json, [rowPath])\n\n  onPatch(operations, (_, patchedState) => {\n    const newRowIndex = rowIndex < (json as Array<unknown>).length ? rowIndex + 1 : rowIndex\n    const newPath = fromTableCellPosition({ rowIndex: newRowIndex, columnIndex }, columns)\n    const newSelection = createValueSelection(newPath)\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnInsertBeforeRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onInsertBeforeRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnInsertBeforeRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('insert before row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const newValue = isJSONObject((json as Array<unknown>)[0]) ? {} : ''\n  const values = [{ key: '', value: newValue }]\n  const operations = insertBefore(json, rowPath, values)\n\n  onPatch(operations)\n}\n\nexport interface OnInsertAfterRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onInsertAfterRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnInsertAfterRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('insert after row', { rowIndex })\n\n  const nextRowIndex = rowIndex + 1\n  const nextRowPath = [String(nextRowIndex)]\n  const newValue = isJSONObject((json as Array<unknown>)[0]) ? {} : ''\n  const values = [{ key: '', value: newValue }]\n\n  const operations =\n    nextRowIndex < (json as Array<unknown>).length\n      ? insertBefore(json, nextRowPath, values)\n      : append(json, [], values)\n\n  onPatch(operations, (_, patchedState) => {\n    const nextPath = fromTableCellPosition({ rowIndex: nextRowIndex, columnIndex }, columns)\n    const newSelection = createValueSelection(nextPath)\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnRemoveRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onRemoveRow({ json, selection, columns, readOnly, onPatch }: OnRemoveRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('remove row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const operations = removeAll([rowPath])\n\n  onPatch(operations, (patchedJson, patchedState) => {\n    const newRowIndex =\n      rowIndex < (patchedJson as Array<unknown>).length\n        ? rowIndex\n        : rowIndex > 0\n          ? rowIndex - 1\n          : undefined\n\n    const newSelection =\n      newRowIndex !== undefined\n        ? createValueSelection(\n            fromTableCellPosition({ rowIndex: newRowIndex, columnIndex }, columns)\n          )\n        : undefined\n\n    debug('remove row new selection', { rowIndex, newRowIndex, newSelection })\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnInsert {\n  insertType: InsertType\n  selectInside: boolean\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  initialValue: string | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n}\n\n// TODO: write unit tests\nexport function onInsert({\n  insertType,\n  selectInside,\n  initialValue,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson\n}: OnInsert): void {\n  if (readOnly) {\n    return\n  }\n\n  const newValue = createNewValue(json, selection, insertType)\n\n  if (json !== undefined) {\n    const data = parser.stringify(newValue) as string\n    const operations = insert(json, selection, data, parser)\n    debug('onInsert', { insertType, operations, newValue, data })\n\n    const operation = last(\n      operations.filter((operation) => operation.op === 'add' || operation.op === 'replace')\n    )\n\n    onPatch(operations, (patchedJson, patchedState, patchedSelection) => {\n      // TODO: extract determining the newSelection in a separate function\n      if (operation) {\n        const path = parsePath(patchedJson, operation.path)\n\n        if (isObjectOrArray(newValue)) {\n          return {\n            state: expandPath(patchedJson, patchedState, path, expandAll),\n            selection: selectInside ? createInsideSelection(path) : patchedSelection\n          }\n        }\n\n        if (newValue === '') {\n          // open the newly inserted value in edit mode\n          const parent = !isEmpty(path) ? getIn(patchedJson, initial(path)) : undefined\n\n          return {\n            state: expandPath(patchedJson, patchedState, path, expandNone),\n            selection: isObject(parent)\n              ? createEditKeySelection(path, initialValue)\n              : createEditValueSelection(path, initialValue)\n          }\n        }\n      }\n\n      return undefined\n    })\n\n    debug('after patch')\n  } else {\n    // document is empty or invalid (in that case it has text but no json)\n    debug('onInsert', { insertType, newValue })\n\n    const path: JSONPath = []\n    onReplaceJson(newValue, (patchedJson, patchedState) => ({\n      state: expandSmart(patchedJson, patchedState, path),\n      selection: isObjectOrArray(newValue)\n        ? createInsideSelection(path)\n        : createEditValueSelection(path)\n    }))\n  }\n}\n\nexport interface OnInsertCharacter {\n  char: string\n  selectInside: boolean\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n  onSelect: OnJSONSelect\n}\n\n// TODO: write unit tests\nexport async function onInsertCharacter({\n  char,\n  selectInside,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson,\n  onSelect\n}: OnInsertCharacter) {\n  // a regular key like a, A, _, etc. is entered.\n  // Replace selected contents with a new value having this first character as text\n  if (readOnly) {\n    return\n  }\n\n  if (isKeySelection(selection)) {\n    onSelect({ ...selection, edit: true, initialValue: char })\n    return\n  }\n\n  if (char === '{') {\n    onInsert({\n      insertType: 'object',\n      selectInside,\n      initialValue: undefined, // not relevant\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch,\n      onReplaceJson\n    })\n  } else if (char === '[') {\n    onInsert({\n      insertType: 'array',\n      selectInside,\n      initialValue: undefined, // not relevant\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch,\n      onReplaceJson\n    })\n  } else {\n    if (isValueSelection(selection) && json !== undefined) {\n      if (!isObjectOrArray(getIn(json, selection.path))) {\n        onSelect({ ...selection, edit: true, initialValue: char })\n      } else {\n        // TODO: replace the object/array with editing a text in edit mode?\n        //  (Ideally this this should not create an entry in history though,\n        //  which isn't really possible right now since we have to apply\n        //  a patch to change the object/array into a value)\n      }\n    } else {\n      debug('onInsertValueWithCharacter', { char })\n      await onInsertValueWithCharacter({\n        char,\n        json,\n        selection,\n        readOnly,\n        parser,\n        onPatch,\n        onReplaceJson\n      })\n    }\n  }\n}\n\ninterface OnInsertValueWithCharacter {\n  char: string\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n}\n\nasync function onInsertValueWithCharacter({\n  char,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson\n}: OnInsertValueWithCharacter) {\n  if (readOnly) {\n    return\n  }\n\n  // first insert a new value\n  onInsert({\n    insertType: 'value',\n    selectInside: false, // not relevant, we insert a value, not an object or array\n    initialValue: char,\n    json,\n    selection,\n    readOnly,\n    parser,\n    onPatch,\n    onReplaceJson\n  })\n}\n","<script lang=\"ts\">\n  import type { JSONParser } from '$lib/types'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { getText } from '$lib/utils/jsonUtils.js'\n  import { MAX_CHARACTERS_TEXT_PREVIEW } from '$lib/constants.js'\n\n  export let text: string | undefined\n  export let json: unknown | undefined\n  export let indentation: number | string\n  export let parser: JSONParser\n\n  $: content = json !== undefined ? { json } : { text: text || '' }\n  $: truncated = truncate(getText(content, indentation, parser), MAX_CHARACTERS_TEXT_PREVIEW)\n</script>\n\n<div class=\"jse-json-preview\">\n  {truncated}\n</div>\n\n<style src=\"./JSONPreview.scss\"></style>\n","<script lang=\"ts\">\n  import type { MenuButton } from '$lib/types'\n  import Icon from 'svelte-awesome'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let item: MenuButton\n  export let className: string | undefined = undefined\n  export let onRequestClose: () => void\n</script>\n\n<button\n  type=\"button\"\n  class={classnames('jse-context-menu-button', className, item.className)}\n  on:click={(event) => {\n    onRequestClose()\n    item.onClick(event)\n  }}\n  title={item.title}\n  disabled={item.disabled || false}\n>\n  {#if item.icon}\n    <Icon data={item.icon} />\n  {/if}\n  {#if item.text}\n    {item.text}\n  {/if}\n</button>\n\n<style src=\"./ContextMenuButton.scss\"></style>\n","<script lang=\"ts\">\n  import type { MenuDropDownButton } from '$lib/types'\n  import DropdownButton from '../DropdownButton.svelte'\n  import Icon from 'svelte-awesome'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let item: MenuDropDownButton\n  export let className: string | undefined = undefined\n  export let onRequestClose: () => void\n\n  $: items = item.items.map((item) => ({\n    ...item,\n    onClick: (event: MouseEvent) => {\n      onRequestClose()\n      item.onClick(event)\n    }\n  }))\n</script>\n\n<DropdownButton width={item.width} {items}>\n  <button\n    class={classnames('jse-context-menu-button', className, item.main.className)}\n    type=\"button\"\n    slot=\"defaultItem\"\n    title={item.main.title}\n    on:click={(event) => {\n      onRequestClose()\n      item.main.onClick(event)\n    }}\n    disabled={item.main.disabled || false}\n  >\n    {#if item.main.icon}\n      <Icon data={item.main.icon} />\n    {/if}\n    {item.main.text}\n  </button>\n</DropdownButton>\n\n<style src=\"./ContextMenuDropDownButton.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faCaretDown } from '@fortawesome/free-solid-svg-icons'\n  import { onDestroy, onMount } from 'svelte'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import type { MenuButton } from '$lib/types.js'\n\n  export let items: MenuButton[] = []\n  export let title: string | undefined = undefined\n  export let width = '120px'\n\n  let visible = false\n\n  $: allItemsDisabled = items.every((item) => item.disabled === true)\n\n  function toggleShow() {\n    const wasVisible = visible\n\n    // trigger *after* the handleClick which changes visibility to false\n    setTimeout(() => (visible = !wasVisible))\n  }\n\n  function handleClick() {\n    visible = false\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    if (combo === 'Escape') {\n      event.preventDefault()\n      visible = false\n    }\n  }\n\n  onMount(() => {\n    document.addEventListener('click', handleClick)\n    document.addEventListener('keydown', handleKeyDown)\n  })\n\n  onDestroy(() => {\n    document.removeEventListener('click', handleClick)\n    document.removeEventListener('keydown', handleKeyDown)\n  })\n</script>\n\n<!-- svelte-ignore a11y-click-events-have-key-events -->\n<div role=\"button\" tabindex=\"0\" class=\"jse-dropdown-button\" {title} on:click={handleClick}>\n  <slot name=\"defaultItem\" />\n\n  <button\n    type=\"button\"\n    class=\"jse-open-dropdown\"\n    data-type=\"jse-open-dropdown\"\n    class:jse-visible={visible}\n    on:click={toggleShow}\n    disabled={allItemsDisabled}\n  >\n    <Icon data={faCaretDown} />\n  </button>\n\n  <div class=\"jse-dropdown-items\" class:jse-visible={visible} style=\"width: {width};\">\n    <ul>\n      {#each items as item}\n        <li>\n          <button\n            type=\"button\"\n            on:click={(event) => item.onClick(event)}\n            title={item.title}\n            disabled={item.disabled}\n            class={item.className}\n          >\n            {#if item.icon}\n              <Icon data={item.icon} />\n            {/if}\n            {item.text}\n          </button>\n        </li>\n      {/each}\n    </ul>\n  </div>\n</div>\n\n<style src=\"./DropdownButton.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onMount } from 'svelte'\n  import Icon from 'svelte-awesome'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { faLightbulb } from '@fortawesome/free-regular-svg-icons'\n  import { findNearestElement } from '$lib/utils/domUtils.js'\n  import type { ContextMenuItem, MenuItem } from '$lib/types.js'\n  import {\n    isContextMenuColumn,\n    isContextMenuRow,\n    isMenuButton,\n    isMenuDropDownButton,\n    isMenuLabel,\n    isMenuSeparator\n  } from '$lib/typeguards.js'\n  import ContextMenuButton from './ContextMenuButton.svelte'\n  import ContextMenuDropDownButton from './ContextMenuDropDownButton.svelte'\n\n  export let items: ContextMenuItem[]\n  export let onRequestClose: () => void\n  export let tip: string | undefined\n\n  let refContextMenu: HTMLDivElement\n\n  onMount(() => {\n    const firstEnabledButton = Array.from(refContextMenu.querySelectorAll('button')).find(\n      (button) => !button.disabled\n    )\n\n    if (firstEnabledButton) {\n      firstEnabledButton.focus()\n    }\n  })\n\n  const directionByCombo: Record<string, 'Up' | 'Down' | 'Left' | 'Right'> = {\n    ArrowUp: 'Up',\n    ArrowDown: 'Down',\n    ArrowLeft: 'Left',\n    ArrowRight: 'Right'\n  }\n\n  function handleKeyDown(event: KeyboardEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    const combo = keyComboFromEvent(event)\n    const direction: 'Up' | 'Down' | 'Left' | 'Right' | undefined = directionByCombo[combo]\n\n    if (direction && event.target) {\n      event.preventDefault()\n\n      const buttons: HTMLButtonElement[] = Array.from(\n        refContextMenu.querySelectorAll('button:not([disabled])')\n      )\n      const nearest = findNearestElement<HTMLButtonElement>({\n        allElements: buttons,\n        currentElement: event.target as unknown as HTMLButtonElement,\n        direction,\n        hasPrio: (element: HTMLButtonElement) => {\n          return element.getAttribute('data-type') !== 'jse-open-dropdown'\n        }\n      })\n      if (nearest) {\n        nearest.focus()\n      }\n    }\n  }\n\n  function unknownMenuItem(item: MenuItem): string {\n    console.error('Unknown type of context menu item', item)\n    return '???'\n  }\n</script>\n\n<div\n  role=\"menu\"\n  tabindex=\"-1\"\n  class=\"jse-contextmenu\"\n  bind:this={refContextMenu}\n  on:keydown={handleKeyDown}\n>\n  {#each items as item}\n    {#if isMenuButton(item)}\n      <ContextMenuButton {item} {onRequestClose} />\n    {:else if isMenuDropDownButton(item)}\n      <ContextMenuDropDownButton {item} {onRequestClose} />\n    {:else if isContextMenuRow(item)}\n      <div class=\"jse-row\">\n        {#each item.items as rowItem}\n          {#if isMenuButton(rowItem)}\n            <ContextMenuButton item={rowItem} {onRequestClose} />\n          {:else if isMenuDropDownButton(rowItem)}\n            <ContextMenuDropDownButton item={rowItem} {onRequestClose} />\n          {:else if isContextMenuColumn(rowItem)}\n            <div class=\"jse-column\">\n              {#each rowItem.items as columnItem}\n                {#if isMenuButton(columnItem)}\n                  <ContextMenuButton className=\"left\" item={columnItem} {onRequestClose} />\n                {:else if isMenuDropDownButton(columnItem)}\n                  <ContextMenuDropDownButton className=\"left\" item={columnItem} {onRequestClose} />\n                {:else if isMenuSeparator(columnItem)}\n                  <div class=\"jse-separator\"></div>\n                {:else if isMenuLabel(columnItem)}\n                  <div class=\"jse-label\">\n                    {columnItem.text}\n                  </div>\n                {:else}\n                  {unknownMenuItem(columnItem)}\n                {/if}\n              {/each}\n            </div>\n          {:else if isMenuSeparator(rowItem)}\n            <div class=\"jse-separator\"></div>\n          {:else}\n            {unknownMenuItem(rowItem)}\n          {/if}\n        {/each}\n      </div>\n    {:else if isMenuSeparator(item)}\n      <div class=\"jse-separator\"></div>\n    {:else}\n      {unknownMenuItem(item)}\n    {/if}\n  {/each}\n\n  {#if tip}\n    <div class=\"jse-row\">\n      <div class=\"jse-tip\">\n        <div class=\"jse-tip-icon\">\n          <Icon data={faLightbulb} />\n        </div>\n        <div class=\"jse-tip-text\">{tip}</div>\n      </div>\n    </div>\n  {/if}\n</div>\n\n<style src=\"./ContextMenu.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { getValueClass } from '$lib/plugins/value/components/utils/getValueClass.js'\n  import { type JSONParser, type JSONSelection, Mode, type OnPatch } from '$lib/types.js'\n  import { isValueSelection } from '$lib/logic/selection.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let mode: Mode\n  export let parser: JSONParser\n  export let readOnly: boolean\n  export let selection: JSONSelection | undefined\n  export let onPatch: OnPatch\n\n  export let options: Array<{ value: unknown; text: string }>\n\n  let refSelect: HTMLSelectElement | undefined\n\n  let bindValue: unknown = value\n  $: bindValue = value\n\n  function applyFocus(selection: JSONSelection | undefined) {\n    if (selection) {\n      if (refSelect) {\n        refSelect.focus()\n      }\n    }\n  }\n\n  $: applyFocus(selection)\n\n  function handleSelect(event: Event) {\n    event.stopPropagation()\n\n    if (readOnly) {\n      return\n    }\n\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: bindValue\n      }\n    ])\n  }\n\n  function handleMouseDown(event: MouseEvent) {\n    // stop propagation to prevent selecting the whole line\n    event.stopPropagation()\n  }\n</script>\n\n<select\n  class={`jse-enum-value ${getValueClass(bindValue, mode, parser)}`}\n  class:jse-selected={isValueSelection(selection)}\n  bind:value={bindValue}\n  bind:this={refSelect}\n  on:change={handleSelect}\n  on:mousedown={handleMouseDown}\n>\n  {#each options as option}\n    <option value={option.value}>{option.text}</option>\n  {/each}\n</select>\n\n<style src=\"./EnumValue.scss\"></style>\n","import type { JSONPath } from 'immutable-json-patch'\nimport type { JSONSchema, JSONSchemaDefinitions, JSONSchemaEnum } from '$lib/types'\n\n/**\n * Find enum options for given path in a JSONSchema\n */\nexport function getJSONSchemaOptions(\n  schema: JSONSchema,\n  schemaDefinitions: JSONSchemaDefinitions | undefined,\n  path: JSONPath\n): JSONSchemaEnum | undefined {\n  const schemaForPath = findSchema(schema, schemaDefinitions || {}, path)\n\n  return schemaForPath ? findEnum(schemaForPath) : undefined\n}\n\n/**\n * find an enum definition in a JSON schema, as property `enum` or inside\n * one of the schemas composites (`oneOf`, `anyOf`, `allOf`)\n *\n * Source: https://github.com/josdejong/jsoneditor/blob/develop/src/js/Node.js\n */\nexport function findEnum(schema: JSONSchema): JSONSchemaEnum | undefined {\n  if (Array.isArray(schema['enum'])) {\n    return schema['enum']\n  }\n\n  const composite = schema['oneOf'] || schema['anyOf'] || schema['allOf']\n  if (Array.isArray(composite)) {\n    const match = composite.filter((entry) => entry.enum)\n    if (match.length > 0) {\n      return match[0].enum\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Return the part of a JSON schema matching given path.\n *\n * Source: https://github.com/josdejong/jsoneditor/blob/develop/src/js/Node.js\n */\nexport function findSchema(\n  topLevelSchema: JSONSchema,\n  schemaDefinitions: JSONSchemaDefinitions,\n  path: JSONPath,\n  currentSchema = topLevelSchema\n): JSONSchema | undefined {\n  const nextPath = path.slice(1, path.length)\n  const nextKey = path[0]\n\n  let possibleSchemas = [currentSchema]\n  for (const subSchemas of [currentSchema.oneOf, currentSchema.anyOf, currentSchema.allOf]) {\n    if (Array.isArray(subSchemas)) {\n      possibleSchemas = possibleSchemas.concat(subSchemas)\n    }\n  }\n\n  for (const schema of possibleSchemas) {\n    currentSchema = schema\n\n    if ('$ref' in currentSchema && typeof currentSchema.$ref === 'string') {\n      const ref = currentSchema.$ref\n      if (ref in schemaDefinitions) {\n        currentSchema = schemaDefinitions[ref]\n      } else if (ref.startsWith('#/')) {\n        const refPath = ref.substring(2).split('/')\n        currentSchema = topLevelSchema\n        for (const segment of refPath) {\n          if (segment in currentSchema) {\n            currentSchema = currentSchema[segment] as JSONSchema\n          } else {\n            throw Error(`Unable to resolve reference ${ref}`)\n          }\n        }\n      } else if (ref.match(/#\\//g)?.length === 1) {\n        const [schemaUrl, relativePath] = ref.split('#/')\n        if (schemaUrl in schemaDefinitions) {\n          const referencedSchema = schemaDefinitions[schemaUrl]\n          const reference = { $ref: '#/'.concat(relativePath) }\n          const auxNextPath = []\n          auxNextPath.push(nextKey)\n          if (nextPath.length > 0) {\n            auxNextPath.push(...nextPath)\n          }\n          return findSchema(referencedSchema, schemaDefinitions, auxNextPath, reference)\n        } else {\n          throw Error(`Unable to resolve reference ${ref}`)\n        }\n      } else {\n        throw Error(`Unable to resolve reference ${ref}`)\n      }\n    }\n\n    // We have no more path segments to resolve, return the currently found schema\n    // We do this here, after resolving references, in case of the leaf schema beeing a reference\n    if (nextKey === undefined) {\n      return currentSchema\n    }\n\n    if (\n      typeof currentSchema.properties === 'object' &&\n      currentSchema.properties &&\n      nextKey in currentSchema.properties\n    ) {\n      currentSchema = (currentSchema.properties as Record<string, JSONSchema>)[nextKey]\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n\n    if (typeof currentSchema.patternProperties === 'object' && currentSchema.patternProperties) {\n      for (const prop in currentSchema.patternProperties) {\n        if (nextKey.match(prop)) {\n          currentSchema = (currentSchema.patternProperties as Record<string, JSONSchema>)[prop]\n          return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n        }\n      }\n    }\n\n    if (typeof currentSchema.additionalProperties === 'object') {\n      currentSchema = currentSchema.additionalProperties as JSONSchema\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n\n    if (typeof currentSchema.items === 'object' && currentSchema.items) {\n      currentSchema = currentSchema.items as JSONSchema\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n  }\n\n  return undefined\n}\n","import EnumValue from './components/EnumValue.svelte'\nimport { getJSONSchemaOptions } from '$lib/utils/jsonSchemaUtils.js'\nimport type {\n  JSONSchema,\n  JSONSchemaDefinitions,\n  RenderValueComponentDescription,\n  RenderValueProps\n} from '$lib/types'\n\n/**\n * Search the JSON schema for enums defined at given props.path. If found,\n * return an EnumValue renderer. If not found, return null. In that case you\n * have to fallback on the default valueRender function\n */\nexport function renderJSONSchemaEnum(\n  props: RenderValueProps,\n  schema: JSONSchema,\n  schemaDefinitions?: JSONSchemaDefinitions\n): RenderValueComponentDescription[] | undefined {\n  const enumValues = getJSONSchemaOptions(schema, schemaDefinitions, props.path)\n\n  if (enumValues) {\n    const options = enumValues.map((enumValue) => ({\n      value: enumValue,\n      text: enumValue\n    }))\n\n    // make sure the current value is also added as one of the options,\n    // else it would look as if the first option is the current value\n    const optionsWithValue = enumValues.includes(props.value)\n      ? options\n      : [{ value: props.value, text: props.value }].concat(options)\n\n    return [\n      {\n        component: EnumValue,\n        props: {\n          ...props,\n          options: optionsWithValue\n        }\n      }\n    ]\n  }\n\n  return undefined\n}\n","import type Ajv from 'ajv'\nimport type { Options, Schema, ErrorObject, ValidateFunction, AsyncSchema } from 'ajv'\nimport AjvDist from 'ajv'\nimport { parsePath } from 'immutable-json-patch'\nimport type { JSONSchema, JSONSchemaDefinitions, ValidationError, Validator } from '$lib/types'\nimport { ValidationSeverity } from '$lib/types.js'\n\nexport interface AjvValidatorOptions {\n  /**\n   * The JSON schema to validate (required).\n   */\n  schema: JSONSchema\n\n  /**\n   * An object containing JSON Schema definitions which can be referenced using $ref.\n   */\n  schemaDefinitions?: JSONSchemaDefinitions\n\n  /**\n   * Optional extra options for Ajv.\n   */\n  ajvOptions?: Options\n\n  /**\n   * An optional callback function allowing to apply additional configuration on the provided Ajv instance, or return\n   * your own Ajv instance and ignore the provided one.\n   */\n  onCreateAjv?: (ajv: Ajv) => Ajv | void\n\n  /**\n   * The severity of the validation error.\n   *\n   * @default ValidationSeverity.warning\n   */\n  errorSeverity?: ValidationSeverity\n}\n\n/**\n * Create a JSON Schema validator powered by Ajv.\n */\nexport function createAjvValidator(options: AjvValidatorOptions): Validator {\n  const ajv = createAjvInstance(options)\n\n  const validateAjv = ajv.compile(options.schema as Schema)\n\n  return createValidateFunction(validateAjv, options)\n}\n\n/**\n * Create a JSON Schema validator powered by Ajv.\n *\n * Same as `createAjvValidator`, but allows for remote schema resolution through `ajvOptions`'s `loadSchema(uri)`\n * function.\n *\n * Note that `ajvOptions.loadSchema` *must* be set, or Ajv throws an error on initialization!\n *\n * ### Example\n *\n *     const validate = await createAjvValidatorAsync({\n *       schema: {\n *         $ref: '/schema.json'\n *       },\n *       ajvOptions: {\n *         loadSchema(uri) {\n *           return fetch(uri).then((res) => res.json())\n *         }\n *       }\n *     })\n */\nexport async function createAjvValidatorAsync(options: AjvValidatorOptions): Promise<Validator> {\n  const ajv = createAjvInstance(options)\n\n  const validateAjv = await ajv.compileAsync(options.schema as AsyncSchema)\n\n  return createValidateFunction(validateAjv, options)\n}\n\nfunction createAjvInstance(options: AjvValidatorOptions): Ajv {\n  const { schemaDefinitions, ajvOptions } = options\n\n  let ajv = new AjvDist({\n    allErrors: true,\n    verbose: true,\n    $data: true,\n    ...ajvOptions\n  })\n\n  if (schemaDefinitions) {\n    Object.keys(schemaDefinitions).forEach((ref) => {\n      ajv.addSchema(schemaDefinitions[ref] as Schema, ref)\n    })\n  }\n\n  ajv = options.onCreateAjv?.(ajv) ?? ajv\n\n  // validate whether ajv is configured correctly (this is needed to enhance error messages)\n  if (ajv.opts.verbose === false) {\n    throw new Error('Ajv must be configured with the option verbose=true')\n  }\n\n  return ajv\n}\n\nfunction createValidateFunction(\n  ajvValidator: ValidateFunction<unknown>,\n  options: AjvValidatorOptions\n): Validator {\n  if (ajvValidator.errors) {\n    throw ajvValidator.errors[0]\n  }\n\n  return function validate(json: unknown): ValidationError[] {\n    ajvValidator(json)\n    const ajvErrors = ajvValidator.errors ?? []\n\n    return ajvErrors.map(improveAjvError).map((error) => normalizeAjvError(json, error, options))\n  }\n}\n\nfunction normalizeAjvError(\n  json: unknown,\n  ajvError: ErrorObject,\n  options: AjvValidatorOptions\n): ValidationError {\n  return {\n    path: parsePath(json, ajvError.instancePath),\n    message: ajvError.message ?? 'Unknown error',\n    severity: options.errorSeverity ?? ValidationSeverity.warning\n  }\n}\n\n/**\n * Improve the error message of a JSON schema error,\n * for example list the available values of an enum.\n */\nfunction improveAjvError(ajvError: ErrorObject): ErrorObject {\n  let message: string | undefined = undefined\n\n  if (ajvError.keyword === 'enum' && Array.isArray(ajvError.schema)) {\n    let enums = ajvError.schema\n    if (enums) {\n      enums = enums.map((value) => JSON.stringify(value))\n\n      if (enums.length > 5) {\n        const more = ['(' + (enums.length - 5) + ' more...)']\n        enums = enums.slice(0, 5)\n        enums.push(more)\n      }\n      message = 'should be equal to one of: ' + enums.join(', ')\n    }\n  }\n\n  if (ajvError.keyword === 'additionalProperties') {\n    message = 'should NOT have additional property: ' + ajvError.params.additionalProperty\n  }\n\n  return message ? { ...ajvError, message } : ajvError\n}\n","import jmespath from 'jmespath'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { getIn } from 'immutable-json-patch'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { JSONParser, QueryLanguage, QueryLanguageOptions } from '$lib/types'\nimport { isEqualParser } from '$lib/utils/jsonUtils.js'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://jmespath.org\" target=\"_blank\" rel=\"noopener noreferrer\">JMESPath</a> query \n  to filter, sort, or transform the JSON data.\n To learn JMESPath, go to <a href=\"https://jmespath.org/tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">the interactive tutorial</a>.\n</p>\n`\n\nexport const jmespathQueryLanguage: QueryLanguage = {\n  id: 'jmespath',\n  name: 'JMESPath',\n  description: description,\n  createQuery,\n  executeQuery\n}\n\n/**\n * Build a JMESPath query based on query options coming from the wizard\n * @param json   The JSON document for which to build the query.\n *                      Used for context information like determining\n *                      the type of values (string or number)\n * @param queryOptions\n * @return Returns a query (as string)\n */\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { sort, filter, projection } = queryOptions\n  let query = ''\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    const examplePath = ['0'].concat(filter.path)\n    const exampleValue = getIn(json, examplePath)\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof exampleValue === 'string' && filterValue !== null && filterValue !== undefined\n        ? `\"${filter.value}\"`\n        : filterValue\n\n    query +=\n      '[? ' +\n      stringifyPathForJmespath(filter.path) +\n      ' ' +\n      filter.relation +\n      ' ' +\n      '`' +\n      filterValueStr +\n      '`' +\n      ']'\n  } else {\n    query += Array.isArray(json) ? '[*]' : '@'\n  }\n\n  if (sort && sort.path && sort.direction) {\n    if (sort.direction === 'desc') {\n      query += ' | reverse(sort_by(@, &' + stringifyPathForJmespath(sort.path) + '))'\n    } else {\n      query += ' | sort_by(@, &' + stringifyPathForJmespath(sort.path) + ')'\n    }\n  }\n\n  if (projection && projection.paths) {\n    if (query[query.length - 1] !== ']') {\n      query += ' | [*]'\n    }\n\n    if (projection.paths.length === 1) {\n      const path = projection.paths[0]\n\n      query +=\n        path.length === 0\n          ? '' // edge case, selecting projection of the item root\n          : '.' + stringifyPathForJmespath(path)\n    } else if (projection.paths.length > 1) {\n      query +=\n        '.{' +\n        projection.paths\n          .map((path) => {\n            const name = path[path.length - 1]\n            return stringifyProp(name) + ': ' + stringifyPathForJmespath(path)\n          })\n          .join(', ') +\n        '}'\n    } else {\n      // values.length === 0\n      // ignore\n    }\n  }\n\n  return query\n}\n\n/**\n * Execute a JMESPath query, returns the transformed JSON\n */\nfunction executeQuery(json: unknown, query: string, parser: JSONParser): unknown {\n  // JMESPath cannot handle non-native JSON data types like LosslessNumber\n\n  function stringifyAndParse(json: unknown) {\n    const text = parser.stringify(json)\n    return text !== undefined ? JSON.parse(text) : undefined\n  }\n\n  const preprocessedJson = isEqualParser(parser, JSON) ? json : stringifyAndParse(json)\n\n  return jmespath.search(preprocessedJson, query)\n}\n\n// TODO: unit test stringifyPathForJmespath\n// TODO: Isn't there a helper function exposed by the JMESPath library?\nexport function stringifyPathForJmespath(path: JSONPath): string {\n  if (path.length === 0) {\n    return '@'\n  }\n\n  const str = path\n    .map((prop) => {\n      if (typeof prop === 'number') {\n        return '[' + prop + ']'\n      } else {\n        return '.' + stringifyProp(String(prop))\n      }\n    })\n    .join('')\n\n  return str[0] === '.'\n    ? str.slice(1) // remove first dot\n    : str\n}\n\nfunction stringifyProp(prop: string): string {\n  return prop.match(/^[A-Za-z\\d_$]+$/) ? prop : JSON.stringify(prop)\n}\n","import { JSONPath as JSONPathPlus } from 'jsonpath-plus'\nimport { parseString } from '$lib/utils/stringUtils'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://github.com/JSONPath-Plus/JSONPath\" target=\"_blank\" \n  rel=\"noopener noreferrer\"><code>JSONPath</code></a> expression to filter, sort, or transform the data.\n</p>`\n\nexport const jsonpathQueryLanguage: QueryLanguage = {\n  id: 'jsonpath',\n  name: 'JSONPath',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(_json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  let expression = '$'\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    const filterValue = parseString(filter.value)\n    const filterValueStr = JSON.stringify(filterValue)\n\n    expression += `[?(@${pathToString(filter.path)} ${filter.relation} ${filterValueStr})]`\n  }\n\n  if (sort && sort.path && sort.direction) {\n    throw new Error('Sorting is not supported by JSONPath. Please clear the sorting fields')\n  }\n\n  if (projection && projection.paths) {\n    if (projection.paths.length > 1) {\n      throw new Error(\n        'Picking multiple fields is not supported by JSONPath. Please select only one field'\n      )\n    }\n\n    if (!expression.endsWith(']')) {\n      expression += '[*]'\n    }\n    expression += `${pathToString(projection.paths[0])}`.replace(/^\\.\\.\\./, '..')\n  }\n\n  return expression\n}\n\nfunction executeQuery(json: unknown, path: string): unknown {\n  const output = JSONPathPlus({ json: json as JSON, path })\n  return output !== undefined ? output : null\n}\n\nfunction pathToString(path: JSONPath): JSONPath | string {\n  const lettersOnlyRegex = /^[A-z]+$/\n\n  return path\n    .map((prop) => {\n      return lettersOnlyRegex.test(prop) ? `.${prop}` : JSON.stringify([prop])\n    })\n    .join('')\n}\n","import * as _ from 'lodash-es'\nimport { last } from 'lodash-es'\nimport { createLodashPropertySelector, createPropertySelector } from '$lib/utils/pathUtils.js'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport { isInteger } from '$lib/utils/typeUtils.js'\n\nconst description = `\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n  You can use <a href=\"https://lodash.com\" target=\"_blank\" rel=\"noopener noreferrer\">Lodash</a>\n  functions like <code>_.map</code>, <code>_.filter</code>,\n  <code>_.orderBy</code>, <code>_.sortBy</code>, <code>_.groupBy</code>,\n  <code>_.pick</code>, <code>_.uniq</code>, <code>_.get</code>, etcetera.\n</p>\n`\n\nexport const lodashQueryLanguage: QueryLanguage = {\n  id: 'lodash',\n  name: 'Lodash',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryParts = ['  return _.chain(data)\\n']\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    // Note that the comparisons embrace type coercion,\n    // so a filter value like '5' (text) will match numbers like 5 too.\n    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`\n\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof filterValue === 'string'\n        ? `'${filter.value}'`\n        : isInteger(filter.value) && !Number.isSafeInteger(filterValue)\n          ? `${filter.value}n` // bigint\n          : filter.value\n\n    queryParts.push(`    .filter(${actualValueGetter} ${filter.relation} ${filterValueStr})\\n`)\n  }\n\n  if (sort && sort.path && sort.direction) {\n    queryParts.push(\n      `    .orderBy([${createLodashPropertySelector(sort.path)}], ['${sort.direction}'])\\n`\n    )\n  }\n\n  if (projection && projection.paths) {\n    // It is possible to make a util function \"pickFlat\"\n    // and use that when building the query to make it more readable.\n    if (projection.paths.length > 1) {\n      // Note that we do not use _.pick() here because this function doesn't flatten the results\n      const paths = projection.paths.map((path) => {\n        const name = last(path) || 'item' // 'item' in case of having selected the item root\n        return `      ${JSON.stringify(name)}: item${createPropertySelector(path)}`\n      })\n      queryParts.push(`    .map(item => ({\\n${paths.join(',\\n')}\\n    }))\\n`)\n    } else {\n      const path = projection.paths[0]\n      queryParts.push(`    .map(item => item${createPropertySelector(path)})\\n`)\n    }\n  }\n\n  queryParts.push('    .value()\\n')\n\n  return `function query (data) {\\n${queryParts.join('')}}`\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  validate(query)\n\n  // TODO: only import the most relevant subset of lodash instead of the full library?\n  const queryFn = new Function(\n    '_',\n    '\"use strict\";\\n' +\n      '\\n' +\n      query +\n      '\\n' +\n      '\\n' +\n      'if (typeof query !== \"function\") {\\n' +\n      '  throw new Error(\"Cannot execute query: expecting a function named \\'query\\' but is undefined\")\\n' +\n      '}\\n' +\n      '\\n' +\n      'return query;\\n'\n  )(_)\n\n  const output = queryFn(json)\n  return output !== undefined ? output : null\n}\n\nfunction validate(query: string) {\n  // It is very common to forget to end a lodash chain with .value()\n  // This lets the JSON Editor crash though.\n  // Therefore, we do a simple validation (not a guarantee)\n  const chainCount = query.match(/_\\.chain\\(/g)?.length\n  const valueCount = query.match(/\\.value\\(\\)/g)?.length\n\n  if (chainCount !== valueCount) {\n    throw new Error('Cannot execute query: Lodash _.chain(...) must end with .value()')\n  }\n}\n","import { createPropertySelector } from '$lib/utils/pathUtils.js'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport { isInteger } from '$lib/utils/typeUtils.js'\n\nconst description = `\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n</p>\n`\n\nexport const javascriptQueryLanguage: QueryLanguage = {\n  id: 'javascript',\n  name: 'JavaScript',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryParts = ['  return data\\n']\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    // Note that the comparisons embrace type coercion,\n    // so a filter value like '5' (text) will match numbers like 5 too.\n    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`\n\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof filterValue === 'string'\n        ? `'${filter.value}'`\n        : isInteger(filter.value) && !Number.isSafeInteger(filterValue)\n          ? `${filter.value}n` // bigint\n          : filter.value\n\n    queryParts.push(`    .filter(${actualValueGetter} ${filter.relation} ${filterValueStr})\\n`)\n  }\n\n  if (sort && sort.path && sort.direction) {\n    if (sort.direction === 'desc') {\n      queryParts.push(\n        `    .slice()\\n` +\n          `    .sort((a, b) => {\\n` +\n          `      // sort descending\\n` +\n          `      const valueA = a${createPropertySelector(sort.path)}\\n` +\n          `      const valueB = b${createPropertySelector(sort.path)}\\n` +\n          `      return valueA > valueB ? -1 : valueA < valueB ? 1 : 0\\n` +\n          `    })\\n`\n      )\n    } else {\n      // sort direction 'asc'\n      queryParts.push(\n        `    .slice()\\n` +\n          `    .sort((a, b) => {\\n` +\n          `      // sort ascending\\n` +\n          `      const valueA = a${createPropertySelector(sort.path)}\\n` +\n          `      const valueB = b${createPropertySelector(sort.path)}\\n` +\n          `      return valueA > valueB ? 1 : valueA < valueB ? -1 : 0\\n` +\n          `    })\\n`\n      )\n    }\n  }\n\n  if (projection && projection.paths) {\n    // It is possible to make a util function \"pickFlat\"\n    // and use that when building the query to make it more readable.\n    if (projection.paths.length > 1) {\n      const paths = projection.paths.map((path) => {\n        const name = path[path.length - 1] || 'item' // 'item' in case of having selected the item root\n        const item = `item${createPropertySelector(path)}`\n        return `      ${JSON.stringify(name)}: ${item}`\n      })\n\n      queryParts.push(`    .map(item => ({\\n${paths.join(',\\n')}})\\n    )\\n`)\n    } else {\n      const item = `item${createPropertySelector(projection.paths[0])}`\n\n      queryParts.push(`    .map(item => ${item})\\n`)\n    }\n  }\n\n  return `function query (data) {\\n${queryParts.join('')}}`\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  // TODO: only import the most relevant subset of lodash instead of the full library?\n  const queryFn = new Function(\n    '\"use strict\";\\n' +\n      '\\n' +\n      query +\n      '\\n' +\n      '\\n' +\n      'if (typeof query !== \"function\") {\\n' +\n      '  throw new Error(\"Cannot execute query: expecting a function named \\'query\\' but is undefined\")\\n' +\n      '}\\n' +\n      '\\n' +\n      'return query;\\n'\n  )()\n\n  const output = queryFn(json)\n  return output !== undefined ? output : null\n}\n","// source: https://github.com/sveltejs/svelte/issues/7583\n\nlet observer: ResizeObserver\nlet callbacks: WeakMap<Element, (element: Element) => void>\n\n/**\n * Example usage:\n *\n *   <script lang=\"ts\">\n *      let clientWidth = 0\n *   </script>\n *\n *   <div use:resizeObserver={element => clientWidth = element.clientWidth}>\n *      My width is: {clientWidth}\n *   </div>\n */\nexport function resizeObserver(element: Element, onResize: (element: Element) => void) {\n  if (!observer) {\n    callbacks = new WeakMap()\n    observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const onResize = callbacks.get(entry.target)\n        if (onResize) {\n          onResize(entry.target)\n        }\n      }\n    })\n  }\n\n  callbacks.set(element, onResize)\n  observer.observe(element)\n\n  return {\n    destroy: () => {\n      callbacks.delete(element)\n      observer.unobserve(element)\n    }\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { createAutoScrollHandler } from '../../controls/createAutoScrollHandler.js'\n  import { faCheck, faCode, faWrench } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import {\n    compileJSONPointer,\n    existsIn,\n    getIn,\n    immutableJSONPatch,\n    type JSONPatchDocument,\n    type JSONPath\n  } from 'immutable-json-patch'\n  import { jsonrepair } from 'jsonrepair'\n  import { initial, isEmpty, isEqual, noop, uniqueId } from 'lodash-es'\n  import { flushSync, getContext, onDestroy, onMount } from 'svelte'\n  import { createJump } from '$lib/assets/jump.js/src/jump.js'\n  import {\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH,\n    SCROLL_DURATION,\n    SEARCH_BOX_HEIGHT\n  } from '$lib/constants.js'\n  import {\n    collapsePath,\n    createDocumentState,\n    documentStatePatch,\n    expandAll,\n    expandMinimal,\n    expandNone,\n    expandPath,\n    expandSection,\n    expandSelf,\n    expandSmart,\n    expandSmartIfCollapsed,\n    getEnforceString,\n    setInDocumentState,\n    syncDocumentState\n  } from '$lib/logic/documentState.js'\n  import { duplicate, extract, revertJSONPatchWithMoveOperations } from '$lib/logic/operations.js'\n  import {\n    canConvert,\n    createAfterSelection,\n    createEditKeySelection,\n    createEditValueSelection,\n    createInsideSelection,\n    createSelectionFromOperations,\n    createValueSelection,\n    findRootPath,\n    getAnchorPath,\n    getEndPath,\n    getFocusPath,\n    getInitialSelection,\n    getSelectionDown,\n    getSelectionLeft,\n    getSelectionNextInside,\n    getSelectionPaths,\n    getSelectionRight,\n    getSelectionUp,\n    hasSelectionContents,\n    isAfterSelection,\n    isEditingSelection,\n    isInsideSelection,\n    isJSONSelection,\n    isKeySelection,\n    isMultiSelection,\n    isMultiSelectionWithOneItem,\n    isSelectionInsidePath,\n    isValueSelection,\n    removeEditModeFromSelection,\n    selectAll\n  } from '$lib/logic/selection.js'\n  import { toRecursiveValidationErrors, validateJSON } from '$lib/logic/validation.js'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    encodeDataPath,\n    findParentWithNodeName,\n    getWindow,\n    isChildOf,\n    isChildOfNodeName\n  } from '$lib/utils/domUtils.js'\n  import {\n    convertValue,\n    isJSONContent,\n    isTextContent,\n    normalizeJsonParseError,\n    parseAndRepair,\n    parsePartialJson,\n    repairPartialJson\n  } from '$lib/utils/jsonUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { isObjectOrArray, isUrl, stringConvert } from '$lib/utils/typeUtils.js'\n  import { createFocusTracker } from '../../controls/createFocusTracker.js'\n  import Message from '../../controls/Message.svelte'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import CopyPasteModal from '../../modals/CopyPasteModal.svelte'\n  import JSONRepairModal from '../../modals/JSONRepairModal.svelte'\n  import JSONNode from './JSONNode.svelte'\n  import TreeMenu from './menu/TreeMenu.svelte'\n  import Welcome from './Welcome.svelte'\n  import NavigationBar from '../../controls/navigationBar/NavigationBar.svelte'\n  import SearchBox from '../../controls/SearchBox.svelte'\n  import type {\n    AbsolutePopupContext,\n    AbsolutePopupOptions,\n    AfterPatchCallback,\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    ConvertType,\n    DocumentState,\n    History,\n    HistoryItem,\n    InsertType,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    JSONRepairModalProps,\n    JSONSelection,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRedo,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    OnUndo,\n    ParseError,\n    PastedJson,\n    ScrollToOptions,\n    SearchResultDetails,\n    SearchResults,\n    Section,\n    TransformModalOptions,\n    TreeModeContext,\n    ValidationError,\n    ValidationErrors,\n    Validator,\n    ValueNormalization\n  } from '$lib/types'\n  import { Mode, ValidationSeverity } from '$lib/types.js'\n  import memoizeOne from 'memoize-one'\n  import { measure } from '$lib/utils/timeUtils.js'\n  import {\n    onCopy,\n    onCut,\n    onInsert,\n    onInsertCharacter,\n    onPaste,\n    onRemove\n  } from '$lib/logic/actions.js'\n  import JSONPreview from '../../controls/JSONPreview.svelte'\n  import ContextMenu from '../../controls/contextmenu/ContextMenu.svelte'\n  import createTreeContextMenuItems from './contextmenu/createTreeContextMenuItems'\n  import { toRecursiveSearchResults as toRecursiveSearchResults } from 'svelte-jsoneditor/logic/search.js'\n  import { isTreeHistoryItem } from 'svelte-jsoneditor'\n\n  const debug = createDebug('jsoneditor:TreeMode')\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  let refContents: HTMLDivElement | undefined\n  let refHiddenInput: HTMLInputElement\n  let refJsonEditor: HTMLDivElement\n  let hasFocus = false\n  const jump = createJump()\n\n  export let readOnly: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let history: History<HistoryItem>\n  export let truncateTextSize: number\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n  export let indentation: number | string\n  export let onError: OnError\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onUndo: OnUndo\n  export let onRedo: OnRedo\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onClassName: OnClassName | undefined\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n  let copyPasteModalOpen = false\n  let jsonRepairModalProps: JSONRepairModalProps | undefined = undefined\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(refJsonEditor),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(refJsonEditor),\n    onFocus: () => {\n      hasFocus = true\n      if (onFocus) {\n        onFocus()\n      }\n    },\n    onBlur: () => {\n      hasFocus = false\n      if (onBlur) {\n        onBlur()\n      }\n    }\n  })\n\n  let json: unknown | undefined\n  let text: string | undefined\n  let parseError: ParseError | undefined = undefined\n\n  let documentStateInitialized = false\n  let documentState: DocumentState | undefined = createDocumentState({ json })\n  let selection: JSONSelection | undefined = isJSONSelection(externalSelection)\n    ? externalSelection\n    : undefined\n\n  onMount(() => {\n    if (selection) {\n      const path = getFocusPath(selection)\n      documentState = expandPath(json, documentState, path, expandNone)\n      setTimeout(() => scrollIntoView(path))\n    }\n  })\n\n  function handleSelect(updatedSelection: JSONSelection | undefined) {\n    selection = updatedSelection\n  }\n\n  function emitOnSelect(updatedSelection: JSONSelection | undefined) {\n    if (!isEqual(updatedSelection, externalSelection)) {\n      debug('onSelect', updatedSelection)\n      onSelect(updatedSelection)\n    }\n  }\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: emitOnSelect(selection)\n\n  let normalization: ValueNormalization\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters,\n    escapeUnicodeCharacters\n  })\n\n  let pastedJson: PastedJson | undefined\n\n  let searchResultDetails: SearchResultDetails | undefined\n  let searchResults: SearchResults | undefined\n  let showSearch = false\n  let showReplace = false\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applySearchBoxSpacing(showSearch)\n\n  function applySearchBoxSpacing(showSearch: boolean) {\n    if (!refContents) {\n      return\n    }\n\n    if (showSearch && refContents.scrollTop === 0) {\n      refContents.style.overflowAnchor = 'none'\n      refContents.scrollTop += SEARCH_BOX_HEIGHT\n      setTimeout(() => {\n        if (refContents) {\n          refContents.style.overflowAnchor = ''\n        }\n      })\n    }\n  }\n\n  function handleSearch(result: SearchResultDetails | undefined) {\n    searchResultDetails = result\n    searchResults = searchResultDetails\n      ? toRecursiveSearchResults(json, searchResultDetails.items)\n      : undefined\n  }\n\n  async function handleFocusSearch(path: JSONPath, resultIndex: number) {\n    documentState = expandPath(json, documentState, path, expandNone)\n\n    const element = findSearchResult(resultIndex)\n\n    await scrollTo(path, { element })\n  }\n\n  function handleCloseSearch() {\n    showSearch = false\n    showReplace = false\n    focus()\n  }\n\n  function handleSelectValidationError(error: ValidationError) {\n    debug('select validation error', error)\n\n    selection = createValueSelection(error.path)\n    scrollTo(error.path)\n  }\n\n  export function expand(path: JSONPath, callback: OnExpand = expandSelf) {\n    debug('expand')\n\n    documentState = expandPath(json, documentState, path, callback)\n  }\n\n  export function collapse(path: JSONPath, recursive: boolean) {\n    documentState = collapsePath(json, documentState, path, recursive)\n\n    if (selection) {\n      // check whether the selection is still visible and not collapsed\n      if (isSelectionInsidePath(selection, path)) {\n        // remove selection when not visible anymore\n        selection = undefined\n      }\n    }\n  }\n\n  // two-way binding of externalContent and internal json and text (\n  // when receiving an updated prop, we have to update state for example\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyExternalContent(externalContent)\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyExternalSelection(externalSelection)\n\n  let textIsRepaired = false\n\n  let validationErrorList: ValidationError[] = []\n  let validationErrors: ValidationErrors | undefined\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: updateValidationErrors(json, validator, parser, validationParser)\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidate = memoizeOne(validateJSON)\n\n  function updateValidationErrors(\n    json: unknown,\n    validator: Validator | undefined,\n    parser: JSONParser,\n    validationParser: JSONParser\n  ) {\n    measure(\n      () => {\n        let newValidationErrorList: ValidationError[]\n        try {\n          newValidationErrorList = memoizedValidate(json, validator, parser, validationParser)\n        } catch (err) {\n          newValidationErrorList = [\n            {\n              path: [],\n              message: 'Failed to validate: ' + (err as Error).message,\n              severity: ValidationSeverity.warning\n            }\n          ]\n        }\n\n        if (!isEqual(newValidationErrorList, validationErrorList)) {\n          debug('validationErrors changed:', newValidationErrorList)\n          validationErrorList = newValidationErrorList\n          validationErrors = toRecursiveValidationErrors(json, validationErrorList)\n        }\n      },\n      (duration) => debug(`validationErrors updated in ${duration} ms`)\n    )\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate')\n\n    if (parseError) {\n      return {\n        parseError,\n        isRepairable: false // not applicable, if repairable, we will not have a parseError\n      }\n    }\n\n    // make sure the validation results are up-to-date\n    // normally, they are only updated on the next tick after the json is changed\n    updateValidationErrors(json, validator, parser, validationParser)\n    return !isEmpty(validationErrorList) ? { validationErrors: validationErrorList } : undefined\n  }\n\n  export function getJson() {\n    return json\n  }\n\n  function getDocumentState(): DocumentState | undefined {\n    return documentState\n  }\n\n  function getSelection(): JSONSelection | undefined {\n    return selection\n  }\n\n  function applyExternalContent(updatedContent: Content) {\n    debug('applyExternalContent', { updatedContent })\n\n    if (isJSONContent(updatedContent)) {\n      applyExternalJson(updatedContent.json)\n    } else if (isTextContent(updatedContent)) {\n      applyExternalText(updatedContent.text)\n    }\n  }\n\n  function applyExternalJson(updatedJson: unknown | undefined) {\n    if (updatedJson === undefined) {\n      return\n    }\n\n    // TODO: this is inefficient. Make an optional flag promising that the updates are immutable so we don't have to do a deep equality check? First do some profiling!\n    const isChanged = !isEqual(json, updatedJson)\n\n    debug('update external json', { isChanged, currentlyText: json === undefined })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    json = updatedJson\n    documentState = syncDocumentState(updatedJson, documentState)\n    expandWhenNotInitialized(json)\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalText(updatedText: string | undefined) {\n    if (updatedText === undefined || isJSONContent(externalContent)) {\n      return\n    }\n\n    const isChanged = updatedText !== text\n\n    debug('update external text', { isChanged })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = syncDocumentState(json, documentState)\n      expandWhenNotInitialized(json)\n      text = updatedText\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = syncDocumentState(json, documentState)\n        expandWhenNotInitialized(json)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n        clearSelectionWhenNotExisting(json)\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = undefined\n        text = externalContent['text']\n        textIsRepaired = false\n        parseError =\n          text !== undefined && text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (isEqual(selection, externalSelection)) {\n      return\n    }\n\n    debug('applyExternalSelection', { selection, externalSelection })\n\n    if (isJSONSelection(externalSelection)) {\n      selection = externalSelection\n    }\n  }\n\n  function expandWhenNotInitialized(json: unknown) {\n    if (!documentStateInitialized) {\n      documentStateInitialized = true\n      documentState = expandSmart(json, documentState, [])\n    }\n  }\n\n  function clearSelectionWhenNotExisting(json: unknown) {\n    if (!selection) {\n      return\n    }\n\n    if (existsIn(json, getAnchorPath(selection)) && existsIn(json, getFocusPath(selection))) {\n      return\n    }\n\n    debug('clearing selection: path does not exist anymore', selection)\n    selection = getInitialSelection(json, documentState)\n  }\n\n  interface PreviousState {\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    textIsRepaired: boolean\n  }\n\n  function addHistoryItem(previous: PreviousState) {\n    if (previous.json === undefined && previous.text === undefined) {\n      // initialization -> do not create a history item\n      return\n    }\n\n    const canPatch = json !== undefined && previous.json !== undefined\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: previous.json }] : undefined,\n        json: previous.json,\n        text: previous.text,\n        documentState: previous.documentState,\n        textIsRepaired: previous.textIsRepaired,\n        selection: removeEditModeFromSelection(previous.selection),\n        sortedColumn: undefined\n      },\n      redo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: json }] : undefined,\n        json,\n        text,\n        documentState,\n        textIsRepaired,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn: undefined\n      }\n    })\n  }\n\n  function createDefaultSelection() {\n    debug('createDefaultSelection')\n\n    selection = createValueSelection([])\n  }\n\n  export function patch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('patch', operations, afterPatch)\n\n    if (json === undefined) {\n      throw new Error('Cannot apply patch: no JSON')\n    }\n\n    const previousJson = json\n    const previousState = {\n      json: undefined, // not needed: we use patch to reconstruct the json\n      text,\n      documentState,\n      selection: removeEditModeFromSelection(selection),\n      textIsRepaired,\n      sortedColumn: undefined\n    }\n\n    // execute the patch operations\n    const undo: JSONPatchDocument = revertJSONPatchWithMoveOperations(\n      json,\n      operations\n    ) as JSONPatchDocument\n    const patched = documentStatePatch(json, documentState, operations)\n\n    // update the selection based on the operations\n    const updatedSelection = createSelectionFromOperations(json, operations) ?? selection\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(patched.json, patched.documentState, updatedSelection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : patched.json\n    documentState = callback?.state !== undefined ? callback.state : patched.documentState\n    selection = callback?.selection !== undefined ? callback.selection : updatedSelection\n    text = undefined\n    textIsRepaired = false\n    pastedJson = undefined\n    parseError = undefined\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: undo,\n        ...previousState\n      },\n      redo: {\n        patch: operations,\n        json: undefined, // not needed, we use patch to reconstruct\n        text,\n        documentState,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn: undefined,\n        textIsRepaired\n      }\n    })\n\n    return {\n      json,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handleEditKey() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    selection = createEditKeySelection(getFocusPath(selection))\n  }\n\n  function handleEditValue() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const value = getIn(json, path)\n    if (isObjectOrArray(value)) {\n      openJSONEditorModal(path, value)\n    } else {\n      selection = createEditValueSelection(path)\n    }\n  }\n\n  function handleToggleEnforceString() {\n    if (readOnly || !isValueSelection(selection)) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const pointer = compileJSONPointer(path)\n    const value = getIn(json, path)\n    const enforceString = !getEnforceString(json, documentState, path)\n    const updatedValue = enforceString ? String(value) : stringConvert(String(value), parser)\n\n    debug('handleToggleEnforceString', { enforceString, value, updatedValue })\n\n    handlePatch(\n      [\n        {\n          op: 'replace',\n          path: pointer,\n          value: updatedValue\n        }\n      ],\n      (_, patchedState) => {\n        return {\n          state: setInDocumentState(json, patchedState, path, { type: 'value', enforceString })\n        }\n      }\n    )\n  }\n\n  export function acceptAutoRepair(): Content {\n    if (textIsRepaired && json !== undefined) {\n      handleReplaceJson(json)\n    }\n\n    return json !== undefined ? { json } : { text: text || '' }\n  }\n\n  async function handleCut(indent = true) {\n    await onCut({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      readOnly,\n      parser,\n      onPatch: handlePatch\n    })\n  }\n\n  async function handleCopy(indent = true) {\n    if (json === undefined) {\n      return\n    }\n\n    await onCopy({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      parser\n    })\n  }\n\n  function handlePaste(event: ClipboardEvent) {\n    event.preventDefault()\n\n    const clipboardText = event.clipboardData?.getData('text/plain')\n\n    _paste(clipboardText)\n  }\n\n  async function handlePasteFromMenu() {\n    try {\n      const clipboardText = await navigator.clipboard.readText()\n\n      _paste(clipboardText)\n    } catch (err) {\n      console.error(err)\n\n      copyPasteModalOpen = true\n    }\n  }\n\n  function _paste(clipboardText: string | undefined) {\n    if (clipboardText === undefined) {\n      return\n    }\n\n    onPaste({\n      clipboardText,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onChangeText: handleChangeText,\n      openRepairModal\n    })\n  }\n\n  function openRepairModal(text: string, onApply: (repairedText: string) => void) {\n    jsonRepairModalProps = {\n      text,\n      onParse: (text) => parsePartialJson(text, (t) => parseAndRepair(t, parser)),\n      onRepair: repairPartialJson,\n      onApply,\n      onClose: focus\n    }\n  }\n\n  function handleRemove() {\n    onRemove({\n      json,\n      text,\n      selection,\n      keepSelection: false,\n      readOnly,\n      onChange,\n      onPatch: handlePatch\n    })\n  }\n\n  function handleDuplicate() {\n    if (\n      readOnly ||\n      json === undefined ||\n      !selection ||\n      !hasSelectionContents ||\n      isEmpty(getFocusPath(selection)) // root selected, cannot duplicate\n    ) {\n      return\n    }\n\n    debug('duplicate', { selection })\n\n    const operations = duplicate(json, getSelectionPaths(json, selection))\n\n    handlePatch(operations)\n  }\n\n  function handleExtract() {\n    if (\n      readOnly ||\n      !selection ||\n      (!isMultiSelection(selection) && !isValueSelection(selection)) ||\n      isEmpty(getFocusPath(selection)) // root selected, cannot extract\n    ) {\n      return\n    }\n\n    debug('extract', { selection })\n\n    const operations = extract(json, selection)\n\n    handlePatch(operations, (patchedJson, patchedState) => {\n      if (isObjectOrArray(patchedJson)) {\n        // expand extracted object/array\n        const path: JSONPath = []\n        return {\n          state: expandSmartIfCollapsed(patchedJson, patchedState, path)\n        }\n      }\n\n      return undefined\n    })\n  }\n\n  function handleInsert(insertType: InsertType): void {\n    onInsert({\n      insertType,\n      selectInside: true,\n      initialValue: undefined,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson\n    })\n  }\n\n  function handleInsertFromContextMenu(type: InsertType) {\n    if (isKeySelection(selection)) {\n      // in this case, we do not want to rename the key, but replace the property\n      selection = createValueSelection(selection.path)\n    }\n\n    if (!selection) {\n      selection = getInitialSelection(json, documentState)\n    }\n\n    handleInsert(type)\n  }\n\n  function handleConvert(type: ConvertType) {\n    if (readOnly || !selection) {\n      return\n    }\n\n    if (!canConvert(selection)) {\n      onError(new Error(`Cannot convert current selection to ${type}`))\n      return\n    }\n\n    try {\n      const path = getAnchorPath(selection)\n      const currentValue: unknown = getIn(json, path)\n      const convertedValue = convertValue(\n        currentValue,\n        type as 'value' | 'object' | 'array',\n        parser\n      )\n      if (convertedValue === currentValue) {\n        // no change, do nothing\n        return\n      }\n\n      const operations: JSONPatchDocument = [\n        { op: 'replace', path: compileJSONPointer(path), value: convertedValue }\n      ]\n\n      debug('handleConvert', { selection, path, type, operations })\n\n      handlePatch(operations, (patchedJson, patchedState) => {\n        // expand converted object/array\n        return {\n          state: selection\n            ? expandSmart(patchedJson, patchedState, getFocusPath(selection))\n            : documentState\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleInsertBefore() {\n    if (!selection) {\n      return\n    }\n\n    const selectionBefore = getSelectionUp(json, documentState, selection, false)\n    const parentPath = initial(getFocusPath(selection))\n\n    if (\n      selectionBefore &&\n      !isEmpty(getFocusPath(selectionBefore)) &&\n      isEqual(parentPath, initial(getFocusPath(selectionBefore)))\n    ) {\n      selection = createAfterSelection(getFocusPath(selectionBefore))\n    } else {\n      selection = createInsideSelection(parentPath)\n    }\n\n    debug('insert before', { selection, selectionBefore, parentPath })\n\n    flushSync()\n    handleContextMenu()\n  }\n\n  function handleInsertAfter() {\n    if (!selection) {\n      return\n    }\n\n    const path = getEndPath(json, selection)\n\n    debug('insert after', path)\n\n    selection = createAfterSelection(path)\n\n    flushSync()\n    handleContextMenu()\n  }\n\n  async function handleInsertCharacter(char: string) {\n    await onInsertCharacter({\n      char,\n      selectInside: true,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson,\n      onSelect: handleSelect\n    })\n  }\n\n  function handleUndo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canUndo) {\n      return\n    }\n\n    const item = history.undo()\n    if (!isTreeHistoryItem(item)) {\n      onUndo(item)\n\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.undo.patch ? immutableJSONPatch(json, item.undo.patch) : item.undo.json\n    documentState = item.undo.documentState\n    selection = item.undo.selection\n    text = item.undo.text\n    textIsRepaired = item.undo.textIsRepaired\n    parseError = undefined\n\n    debug('undo', { item, json, documentState, selection })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.undo.patch,\n            undo: item.redo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), { scrollToWhenVisible: false })\n    }\n  }\n\n  function handleRedo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canRedo) {\n      return\n    }\n\n    const item = history.redo()\n    if (!isTreeHistoryItem(item)) {\n      onRedo(item)\n\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.redo.patch ? immutableJSONPatch(json, item.redo.patch) : item.redo.json\n    documentState = item.redo.documentState\n    selection = item.redo.selection\n    text = item.redo.text\n    textIsRepaired = item.redo.textIsRepaired\n    parseError = undefined\n\n    debug('redo', { item, json, documentState, selection })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.redo.patch,\n            undo: item.undo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), { scrollToWhenVisible: false })\n    }\n  }\n\n  function openSortModal(rootPath: JSONPath) {\n    if (readOnly || json === undefined) {\n      return\n    }\n\n    modalOpen = true\n\n    onSortModal({\n      id: sortModalId,\n      json,\n      rootPath,\n      onSort: async ({ operations }) => {\n        debug('onSort', rootPath, operations)\n\n        handlePatch(operations, (patchedJson, patchedState) => ({\n          // expand the newly replaced array if needed, and select it\n          state: expandSmartIfCollapsed(patchedJson, patchedState, rootPath),\n          selection: createValueSelection(rootPath)\n        }))\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  function handleSortSelection() {\n    if (!selection) {\n      return\n    }\n\n    const rootPath = findRootPath(json, selection)\n    openSortModal(rootPath)\n  }\n\n  function handleSortAll() {\n    const rootPath: JSONPath = []\n    openSortModal(rootPath)\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal(options: TransformModalOptions) {\n    if (json === undefined) {\n      return\n    }\n\n    const { id, onTransform, onClose } = options\n    const rootPath = options.rootPath || []\n\n    modalOpen = true\n\n    onTransformModal({\n      id: id || transformModalId,\n      json,\n      rootPath,\n      onTransform: (operations) => {\n        if (onTransform) {\n          onTransform({\n            operations,\n            json,\n            transformedJson: immutableJSONPatch(json, operations)\n          })\n        } else {\n          debug('onTransform', rootPath, operations)\n\n          handlePatch(operations, (patchedJson, patchedState) => ({\n            // expand the newly replaced array if needed and select it\n            state: expandSmartIfCollapsed(patchedJson, patchedState, rootPath),\n            selection: createValueSelection(rootPath)\n          }))\n        }\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n        if (onClose) {\n          onClose()\n        }\n      }\n    })\n  }\n\n  function handleTransformSelection() {\n    if (!selection) {\n      return\n    }\n\n    const rootPath = findRootPath(json, selection)\n    openTransformModal({\n      rootPath\n    })\n  }\n\n  function handleTransformAll() {\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function openJSONEditorModal(path: JSONPath, value: unknown) {\n    debug('openJSONEditorModal', { path, value })\n\n    modalOpen = true\n\n    // open a popup where you can edit the nested object/array\n    onJSONEditorModal({\n      content: {\n        json: value\n      },\n      path,\n      onPatch: context.onPatch,\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  /**\n   * Scroll the window vertically to the node with given path.\n   * Expand the path when needed.\n   */\n  export async function scrollTo(\n    path: JSONPath,\n    { scrollToWhenVisible = true, element }: ScrollToOptions = {}\n  ): Promise<void> {\n    documentState = expandPath(json, documentState, path, expandNone)\n\n    const elem = element ?? findElement(path)\n\n    debug('scrollTo', { path, elem, refContents })\n\n    if (!elem || !refContents) {\n      return Promise.resolve()\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect()\n    if (!scrollToWhenVisible) {\n      if (elemRect.bottom > viewPortRect.top && elemRect.top < viewPortRect.bottom) {\n        // element is fully or partially visible, don't scroll to it\n        return Promise.resolve()\n      }\n    }\n\n    const offset = -(viewPortRect.height / 4)\n\n    return new Promise<void>((resolve) => {\n      jump(elem, {\n        container: refContents,\n        offset,\n        duration: SCROLL_DURATION,\n        callback: () => resolve()\n      })\n    })\n  }\n\n  /**\n   * Find the DOM element of a given path.\n   * Note that the path can only be found when the node is expanded.\n   */\n  export function findElement(path: JSONPath): Element | undefined {\n    flushSync() // flush any changes, else the element we want to scroll to may not yet exist\n\n    return refContents?.querySelector(`div[data-path=\"${encodeDataPath(path)}\"]`) ?? undefined\n  }\n\n  /**\n   * Find the DOM element of a given search result.\n   * Note that the path can only be found when the node is expanded.\n   */\n  export function findSearchResult(resultIndex: number): Element | undefined {\n    flushSync() // flush any changes, else the element we want to scroll to may not yet exist\n\n    return (\n      refContents?.querySelector(`span[data-search-result-index=\"${resultIndex}\"]`) ?? undefined\n    )\n  }\n\n  /**\n   * If given path is outside the visible viewport, scroll up/down.\n   * When the path is already in view, nothing is done\n   */\n  function scrollIntoView(path: JSONPath) {\n    const elem = findElement(path)\n\n    if (!elem || !refContents) {\n      return\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect()\n    const margin = 20\n    const elemHeight = isObjectOrArray(getIn(json, path))\n      ? margin // do not use real height when array or object\n      : elemRect.height\n\n    if (elemRect.top < viewPortRect.top + margin) {\n      // scroll down\n      jump(elem, {\n        container: refContents,\n        offset: -margin,\n        duration: 0\n      })\n    } else if (elemRect.top + elemHeight > viewPortRect.bottom - margin) {\n      // scroll up\n      jump(elem, {\n        container: refContents,\n        offset: -(viewPortRect.height - elemHeight - margin),\n        duration: 0\n      })\n    }\n  }\n\n  function emitOnChange(previousContent: Content, patchResult: JSONPatchResult | undefined) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (previousContent.json === undefined && previousContent?.text === undefined) {\n      // initialization -> do not fire an onChange event\n      return\n    }\n\n    // make sure we cannot send an invalid contents like having both\n    // json and text defined, or having none defined\n    if (text !== undefined) {\n      const content = { text, json: undefined }\n      onChange?.(content, previousContent, {\n        contentErrors: validate(),\n        patchResult\n      })\n    } else if (json !== undefined) {\n      const content = { text: undefined, json }\n      onChange?.(content, previousContent, {\n        contentErrors: validate(),\n        patchResult\n      })\n    }\n  }\n\n  function handlePatch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('handlePatch', operations, afterPatch)\n\n    const previousContent = { json, text }\n    const patchResult = patch(operations, afterPatch)\n\n    emitOnChange(previousContent, patchResult)\n\n    return patchResult\n  }\n\n  function handleReplaceJson(updatedJson: unknown, afterPatch?: AfterPatchCallback) {\n    const previousContent = { json, text }\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    const updatedState = expandPath(\n      json,\n      syncDocumentState(updatedJson, documentState),\n      [],\n      expandMinimal\n    )\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(updatedJson, updatedState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : updatedJson\n    documentState = callback?.state !== undefined ? callback.state : updatedState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // we could work out a patchResult, or use patch(), but only when the previous and new\n    // contents are both json and not text. We go for simplicity and consistency here and\n    // do _not_ return a patchResult ever.\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  function handleChangeText(updatedText: string, afterPatch?: AfterPatchCallback) {\n    debug('handleChangeText')\n\n    const previousContent = { json, text }\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = expandPath(json, syncDocumentState(json, documentState), [], expandMinimal)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = expandPath(json, syncDocumentState(json, documentState), [], expandMinimal)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = createDocumentState({ json, expand: expandMinimal })\n        text = updatedText\n        textIsRepaired = false\n        parseError =\n          text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    if (typeof afterPatch === 'function') {\n      const callback = afterPatch(json, documentState, selection)\n\n      json = callback?.json !== undefined ? callback.json : json\n      documentState = callback?.state !== undefined ? callback.state : documentState\n      selection = callback?.selection !== undefined ? callback.selection : selection\n    }\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // no JSON patch actions available in text mode\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  /**\n   * Toggle expanded state of a node\n   * @param path The path to be expanded\n   * @param expanded  True if currently expanded, false when currently collapsed\n   * @param [recursive=false]  Only applicable when expanding\n   */\n  function handleExpand(path: JSONPath, expanded: boolean, recursive = false): void {\n    debug('handleExpand', { path, expanded, recursive })\n\n    if (expanded) {\n      expand(path, recursive ? expandAll : expandSelf)\n    } else {\n      collapse(path, recursive)\n    }\n\n    // set focus to the hidden input, so we can capture quick keys like Ctrl+X, Ctrl+C, Ctrl+V\n    focus()\n  }\n\n  function handleExpandAll() {\n    handleExpand([], true, true)\n  }\n\n  function handleCollapseAll() {\n    handleExpand([], false, true)\n  }\n\n  function openFind(findAndReplace: boolean): void {\n    debug('openFind', { findAndReplace })\n\n    showSearch = false\n    showReplace = false\n\n    flushSync()\n\n    // trick to make sure the focus goes to the search box\n    showSearch = true\n    showReplace = findAndReplace\n  }\n\n  function handleExpandSection(path: JSONPath, section: Section) {\n    debug('handleExpandSection', path, section)\n\n    documentState = expandSection(json, documentState, path, section)\n  }\n\n  function handlePasteJson(newPastedJson: PastedJson) {\n    debug('pasted json as text', newPastedJson)\n\n    pastedJson = newPastedJson\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    const keepAnchorPath = event.shiftKey\n    debug('keydown', { combo, key: event.key })\n\n    if (combo === 'Ctrl+X') {\n      // cut formatted\n      event.preventDefault()\n      handleCut(true)\n    }\n    if (combo === 'Ctrl+Shift+X') {\n      // cut compact\n      event.preventDefault()\n      handleCut(false)\n    }\n    if (combo === 'Ctrl+C') {\n      // copy formatted\n      event.preventDefault()\n      handleCopy(true)\n    }\n    if (combo === 'Ctrl+Shift+C') {\n      // copy compact\n      event.preventDefault()\n      handleCopy(false)\n    }\n    // Note: Ctrl+V (paste) is handled by the on:paste event\n\n    if (combo === 'Ctrl+D') {\n      event.preventDefault()\n      handleDuplicate()\n    }\n    if (combo === 'Delete' || combo === 'Backspace') {\n      event.preventDefault()\n      handleRemove()\n    }\n    if (combo === 'Insert') {\n      event.preventDefault()\n      handleInsert('structure')\n    }\n    if (combo === 'Ctrl+A') {\n      event.preventDefault()\n      selection = selectAll()\n    }\n\n    if (combo === 'Ctrl+Q') {\n      handleContextMenu(event)\n    }\n\n    if (combo === 'ArrowUp' || combo === 'Shift+ArrowUp') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionUp(json, documentState, selection, keepAnchorPath) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowDown' || combo === 'Shift+ArrowDown') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionDown(json, documentState, selection, keepAnchorPath) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowLeft' || combo === 'Shift+ArrowLeft') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionLeft(json, documentState, selection, keepAnchorPath, !readOnly) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowRight' || combo === 'Shift+ArrowRight') {\n      event.preventDefault()\n\n      const newSelection =\n        selection && json !== undefined\n          ? getSelectionRight(json, documentState, selection, keepAnchorPath, !readOnly) ||\n            selection\n          : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n\n    if (combo === 'Enter' && selection) {\n      // when the selection consists of a single Array item, change selection to editing its value\n      if (isMultiSelectionWithOneItem(selection)) {\n        const path = selection.focusPath\n        const parent = getIn(json, initial(path))\n        if (Array.isArray(parent)) {\n          // change into selection of the value\n          event.preventDefault()\n          selection = createValueSelection(path)\n        }\n      }\n\n      if (isKeySelection(selection)) {\n        // go to key edit mode\n        event.preventDefault()\n        selection = { ...selection, edit: true }\n      }\n\n      if (isValueSelection(selection)) {\n        event.preventDefault()\n\n        const value = getIn(json, selection.path)\n        if (isObjectOrArray(value)) {\n          // expand object/array\n          handleExpand(selection.path, true)\n        } else {\n          // go to value edit mode\n          selection = { ...selection, edit: true }\n        }\n      }\n    }\n\n    const normalizedCombo = combo.replace(/^Shift\\+/, '') // replace 'Shift+A' with 'A'\n    if (normalizedCombo.length === 1 && selection) {\n      // a regular key like a, A, _, etc is entered.\n      // Replace selected contents with a new value having this first character as text\n      event.preventDefault()\n      handleInsertCharacter(event.key)\n      return\n    }\n\n    if (combo === 'Enter' && (isAfterSelection(selection) || isInsideSelection(selection))) {\n      // Enter on an insert area -> open the area in edit mode\n      event.preventDefault()\n      handleInsertCharacter('')\n      return\n    }\n\n    if (combo === 'Ctrl+Enter' && isValueSelection(selection)) {\n      const value = getIn(json, selection.path)\n\n      if (isUrl(value)) {\n        // open url in new page\n        window.open(String(value), '_blank')\n      }\n    }\n\n    if (combo === 'Escape' && selection) {\n      event.preventDefault()\n      selection = undefined\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      openFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      openFind(true)\n    }\n\n    if (combo === 'Ctrl+Z') {\n      event.preventDefault()\n      handleUndo()\n    }\n\n    if (combo === 'Ctrl+Shift+Z') {\n      event.preventDefault()\n      handleRedo()\n    }\n  }\n\n  function handleMouseDown(event: Event) {\n    debug('handleMouseDown', event)\n\n    const target = event.target as HTMLElement\n\n    if (!isChildOfNodeName(target, 'BUTTON') && !target.isContentEditable) {\n      // for example when clicking on the empty area in the main menu\n      focus()\n\n      if (!selection && json === undefined && (text === '' || text === undefined)) {\n        createDefaultSelection()\n      }\n    }\n  }\n\n  function openContextMenu({\n    anchor,\n    left,\n    top,\n    width,\n    height,\n    offsetTop,\n    offsetLeft,\n    showTip\n  }: AbsolutePopupOptions) {\n    const defaultItems: ContextMenuItem[] = createTreeContextMenuItems({\n      json,\n      documentState,\n      selection,\n      readOnly,\n\n      onEditKey: handleEditKey,\n      onEditValue: handleEditValue,\n      onToggleEnforceString: handleToggleEnforceString,\n\n      onCut: handleCut,\n      onCopy: handleCopy,\n      onPaste: handlePasteFromMenu,\n\n      onRemove: handleRemove,\n      onDuplicate: handleDuplicate,\n      onExtract: handleExtract,\n\n      onInsertBefore: handleInsertBefore,\n      onInsert: handleInsertFromContextMenu,\n      onInsertAfter: handleInsertAfter,\n      onConvert: handleConvert,\n\n      onSort: handleSortSelection,\n      onTransform: handleTransformSelection\n    })\n\n    const items = onRenderContextMenu(defaultItems) ?? defaultItems\n\n    if (items === false) {\n      return\n    }\n\n    const props = {\n      tip: showTip\n        ? 'Tip: you can open this context menu via right-click or with Ctrl+Q'\n        : undefined,\n      items,\n      onRequestClose: () => closeAbsolutePopup(popupId)\n    }\n\n    const options = {\n      left,\n      top,\n      offsetTop,\n      offsetLeft,\n      width,\n      height,\n      anchor,\n      closeOnOuterClick: true,\n      onClose: () => {\n        modalOpen = false\n        focus()\n      }\n    }\n\n    modalOpen = true\n\n    const popupId = openAbsolutePopup(ContextMenu, props, options)\n  }\n\n  function handleContextMenu(event?: Event) {\n    if (isEditingSelection(selection)) {\n      return\n    }\n\n    if (event) {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n\n    if (event && event.type === 'contextmenu' && event.target !== refHiddenInput) {\n      // right mouse click to open context menu\n      openContextMenu({\n        left: (event as MouseEvent).clientX,\n        top: (event as MouseEvent).clientY,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        showTip: false\n      })\n    } else {\n      // type === 'keydown' (from the quick key Ctrl+Q)\n      // or target is hidden input -> context menu button on keyboard\n      const anchor = refContents?.querySelector('.jse-context-menu-pointer.jse-selected')\n      if (anchor) {\n        openContextMenu({\n          anchor,\n          offsetTop: 2,\n          width: CONTEXT_MENU_WIDTH,\n          height: CONTEXT_MENU_HEIGHT,\n          showTip: false\n        })\n      } else {\n        // fallback on just displaying the TreeContextMenu top left\n        const rect = refContents?.getBoundingClientRect()\n        if (rect) {\n          openContextMenu({\n            top: rect.top + 2,\n            left: rect.left + 2,\n            width: CONTEXT_MENU_WIDTH,\n            height: CONTEXT_MENU_HEIGHT,\n            showTip: false\n          })\n        }\n      }\n    }\n  }\n\n  function handleContextMenuFromTreeMenu(event: MouseEvent) {\n    openContextMenu({\n      anchor: findParentWithNodeName(event.target as HTMLElement, 'BUTTON'),\n      offsetTop: 0,\n      width: CONTEXT_MENU_WIDTH,\n      height: CONTEXT_MENU_HEIGHT,\n      showTip: true\n    })\n  }\n\n  async function handleParsePastedJson() {\n    debug('apply pasted json', pastedJson)\n    if (!pastedJson) {\n      return\n    }\n\n    const { onPasteAsJson } = pastedJson\n    pastedJson = undefined\n\n    onPasteAsJson()\n\n    // TODO: get rid of the setTimeout here\n    setTimeout(focus)\n  }\n\n  function handleClearPastedJson() {\n    debug('clear pasted json')\n    pastedJson = undefined\n    focus()\n  }\n\n  function handleRequestRepair() {\n    onChangeMode(Mode.text)\n  }\n\n  function handleNavigationBarSelect(newSelection: JSONSelection) {\n    selection = newSelection\n\n    focus()\n    scrollTo(getFocusPath(newSelection))\n  }\n\n  export function focus() {\n    debug('focus')\n    // with just .focus(), sometimes the input doesn't react on onpaste events\n    // in Chrome when having a large document open and then doing cut/paste.\n    // Calling both .focus() and .select() did solve this issue.\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n      refHiddenInput.select()\n    }\n  }\n\n  function handleWindowMouseDown(event: MouseEvent & { currentTarget: EventTarget & Window }) {\n    const outsideEditor = !isChildOf(\n      event.target as Element,\n      (element) => element === refJsonEditor\n    )\n    if (outsideEditor) {\n      if (isEditingSelection(selection)) {\n        debug('click outside the editor, exit edit mode')\n        selection = removeEditModeFromSelection(selection)\n\n        if (hasFocus && refHiddenInput) {\n          refHiddenInput.focus()\n          refHiddenInput.blur()\n        }\n\n        debug('blur (outside editor)')\n        if (refHiddenInput) {\n          refHiddenInput.blur()\n        }\n      }\n    }\n  }\n\n  function findNextInside(path: JSONPath): JSONSelection | undefined {\n    return getSelectionNextInside(json, documentState, path)\n  }\n\n  $: autoScrollHandler = refContents ? createAutoScrollHandler(refContents) : undefined\n\n  function handleDrag(event: MouseEvent) {\n    if (autoScrollHandler) {\n      autoScrollHandler.onDrag(event)\n    }\n  }\n\n  function handleDragEnd() {\n    if (autoScrollHandler) {\n      autoScrollHandler.onDragEnd()\n    }\n  }\n\n  // Note that we want the context to change as little as possible since it forces all nodes to re-render,\n  // it should only change when a config option like readOnly or onClassName is changed\n  let context: TreeModeContext\n  $: context = {\n    mode: Mode.tree,\n    readOnly,\n    truncateTextSize,\n    parser,\n    normalization,\n    getJson,\n    getDocumentState,\n    getSelection,\n    findElement,\n    findNextInside,\n    focus,\n    onPatch: handlePatch,\n    onInsert: handleInsert,\n    onExpand: handleExpand,\n    onSelect: handleSelect,\n    onFind: openFind,\n    onExpandSection: handleExpandSection,\n    onPasteJson: handlePasteJson,\n    onRenderValue,\n    onContextMenu: openContextMenu,\n    onClassName: onClassName || (() => undefined),\n    onDrag: handleDrag,\n    onDragEnd: handleDragEnd\n  }\n\n  $: debug('context changed', context)\n</script>\n\n<svelte:window on:mousedown={handleWindowMouseDown} />\n\n<div\n  role=\"tree\"\n  tabindex=\"-1\"\n  class=\"jse-tree-mode\"\n  class:no-main-menu={!mainMenuBar}\n  on:keydown={handleKeyDown}\n  on:mousedown={handleMouseDown}\n  on:contextmenu={handleContextMenu}\n  bind:this={refJsonEditor}\n>\n  {#if mainMenuBar}\n    <TreeMenu\n      {json}\n      {selection}\n      {readOnly}\n      {history}\n      bind:showSearch\n      onExpandAll={handleExpandAll}\n      onCollapseAll={handleCollapseAll}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      onSort={handleSortAll}\n      onTransform={handleTransformAll}\n      onContextMenu={handleContextMenuFromTreeMenu}\n      onCopy={handleCopy}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if navigationBar}\n    <NavigationBar {json} {selection} onSelect={handleNavigationBarSelect} {onError} {pathParser} />\n  {/if}\n\n  {#if !isSSR}\n    <label class=\"jse-hidden-input-label\">\n      <input\n        type=\"text\"\n        readonly={true}\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n        on:paste={handlePaste}\n      />\n    </label>\n    {#if json === undefined}\n      {#if text === '' || text === undefined}\n        <Welcome\n          {readOnly}\n          onCreateObject={() => {\n            focus()\n            handleInsertCharacter('{')\n          }}\n          onCreateArray={() => {\n            focus()\n            handleInsertCharacter('[')\n          }}\n          onClick={() => {\n            // FIXME: this is a workaround for the editor not putting the focus on refHiddenInput\n            //  when clicking in the welcome screen so you cannot paste a document from clipboard.\n            focus()\n          }}\n        />\n      {:else}\n        <Message\n          type=\"error\"\n          message=\"The loaded JSON document is invalid and could not be repaired automatically.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCode,\n                  text: 'Repair manually',\n                  title: 'Open the document in \"code\" mode and repair it manually',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n        />\n        <JSONPreview {text} {json} {indentation} {parser} />\n      {/if}\n    {:else}\n      <div class=\"jse-search-box-container\">\n        <SearchBox\n          {json}\n          {documentState}\n          {parser}\n          {showSearch}\n          {showReplace}\n          {readOnly}\n          columns={undefined}\n          onSearch={handleSearch}\n          onFocus={handleFocusSearch}\n          onPatch={handlePatch}\n          onClose={handleCloseSearch}\n        />\n      </div>\n      <div class=\"jse-contents\" data-jsoneditor-scrollable-contents={true} bind:this={refContents}>\n        {#if showSearch}\n          <div class=\"jse-search-box-background\"></div>\n        {/if}\n        <JSONNode\n          value={json}\n          pointer={''}\n          state={documentState}\n          {validationErrors}\n          {searchResults}\n          {selection}\n          {context}\n          onDragSelectionStart={noop}\n        />\n      </div>\n\n      {#if pastedJson}\n        <Message\n          type=\"info\"\n          message={`You pasted a JSON ${\n            Array.isArray(pastedJson.contents) ? 'array' : 'object'\n          } as text`}\n          actions={[\n            {\n              icon: faWrench,\n              text: 'Paste as JSON instead',\n              title: 'Replace the value with the pasted JSON',\n              // We use mousedown here instead of click: this message pops up\n              // whilst the user is editing a value. When clicking this button,\n              // the actual value is applied and the event is not propagated\n              // and an onClick on this button never happens.\n              onMouseDown: handleParsePastedJson\n            },\n            {\n              text: 'Leave as is',\n              title: 'Keep the JSON embedded in the value',\n              onClick: handleClearPastedJson\n            }\n          ]}\n        />\n      {/if}\n\n      {#if textIsRepaired}\n        <Message\n          type=\"success\"\n          message=\"The loaded JSON document was invalid but is successfully repaired.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCheck,\n                  text: 'Ok',\n                  title: 'Accept the repaired document',\n                  onClick: acceptAutoRepair\n                },\n                {\n                  icon: faCode,\n                  text: 'Repair manually instead',\n                  title: 'Leave the document unchanged and repair it manually instead',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview\n        validationErrors={validationErrorList}\n        selectError={handleSelectValidationError}\n      />\n    {/if}\n  {:else}\n    <div class=\"jse-contents\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n{#if copyPasteModalOpen}\n  <CopyPasteModal onClose={() => (copyPasteModalOpen = false)} />\n{/if}\n\n{#if jsonRepairModalProps}\n  <JSONRepairModal\n    {...jsonRepairModalProps}\n    onClose={() => {\n      jsonRepairModalProps?.onClose()\n      jsonRepairModalProps = undefined\n    }}\n  />\n{/if}\n\n<style src=\"./TreeMode.scss\"></style>\n","import {\n  faArrowRightArrowLeft,\n  faCaretSquareDown,\n  faCaretSquareUp,\n  faCheckSquare,\n  faClone,\n  faCopy,\n  faCropAlt,\n  faCut,\n  faFilter,\n  faPaste,\n  faPen,\n  faPlus,\n  faSortAmountDownAlt,\n  faSquare,\n  faTrashCan\n} from '@fortawesome/free-solid-svg-icons'\nimport {\n  canConvert,\n  getFocusPath,\n  isAfterSelection,\n  isInsideSelection,\n  isKeySelection,\n  isMultiSelection,\n  isValueSelection,\n  singleItemSelected\n} from '$lib/logic/selection'\nimport type {\n  ConvertType,\n  DocumentState,\n  InsertType,\n  JSONSelection,\n  ContextMenuItem\n} from '$lib/types'\nimport { initial, isEmpty } from 'lodash-es'\nimport { getIn } from 'immutable-json-patch'\nimport { isObject, isObjectOrArray } from '$lib/utils/typeUtils'\nimport { getEnforceString } from '$lib/logic/documentState'\n\nexport default function ({\n  json,\n  documentState,\n  selection,\n  readOnly,\n  onEditKey,\n  onEditValue,\n  onToggleEnforceString,\n  onCut,\n  onCopy,\n  onPaste,\n  onRemove,\n  onDuplicate,\n  onExtract,\n  onInsertBefore,\n  onInsert,\n  onConvert,\n  onInsertAfter,\n  onSort,\n  onTransform\n}: {\n  json: unknown\n  documentState: DocumentState | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  onEditKey: () => void\n  onEditValue: () => void\n  onToggleEnforceString: () => void\n  onCut: (indent: boolean) => void\n  onCopy: (indent: boolean) => void\n  onPaste: () => void\n  onRemove: () => void\n  onDuplicate: () => void\n  onExtract: () => void\n  onInsertBefore: () => void\n  onInsert: (type: InsertType) => void\n  onConvert: (type: ConvertType) => void\n  onInsertAfter: () => void\n  onSort: () => void\n  onTransform: () => void\n}): ContextMenuItem[] {\n  const hasJson = json !== undefined\n  const hasSelection = !!selection\n  const rootSelected = selection ? isEmpty(getFocusPath(selection)) : false\n  const focusValue = selection ? getIn(json, getFocusPath(selection)) : undefined\n  const editValueText = Array.isArray(focusValue)\n    ? 'Edit array'\n    : isObject(focusValue)\n      ? 'Edit object'\n      : 'Edit value'\n\n  const hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  const parent =\n    selection && !rootSelected ? getIn(json, initial(getFocusPath(selection))) : undefined\n\n  const canEditKey =\n    !readOnly && hasJson && singleItemSelected(selection) && !rootSelected && !Array.isArray(parent)\n\n  const canEditValue =\n    !readOnly && hasJson && selection !== undefined && singleItemSelected(selection)\n  const canEnforceString = canEditValue && !isObjectOrArray(focusValue)\n\n  const canCut = !readOnly && hasSelectionContents\n  const canCopy = hasSelectionContents\n  const canPaste = !readOnly && hasSelection\n  const canDuplicate = !readOnly && hasJson && hasSelectionContents && !rootSelected // must not be root\n  const canExtract =\n    !readOnly &&\n    hasJson &&\n    selection !== undefined &&\n    (isMultiSelection(selection) || isValueSelection(selection)) &&\n    !rootSelected // must not be root\n\n  const convertMode = hasSelectionContents\n  const insertOrConvertText = convertMode ? 'Convert to:' : 'Insert:'\n\n  const canInsertOrConvertStructure =\n    !readOnly &&\n    ((isInsideSelection(selection) && Array.isArray(focusValue)) ||\n      (isAfterSelection(selection) && Array.isArray(parent)))\n  const canInsertOrConvertObject =\n    !readOnly && (convertMode ? canConvert(selection) && !isObject(focusValue) : hasSelection)\n  const canInsertOrConvertArray =\n    !readOnly && (convertMode ? canConvert(selection) && !Array.isArray(focusValue) : hasSelection)\n  const canInsertOrConvertValue =\n    !readOnly && (convertMode ? canConvert(selection) && isObjectOrArray(focusValue) : hasSelection)\n\n  const enforceString =\n    selection !== undefined ? getEnforceString(json, documentState, getFocusPath(selection)) : false\n\n  function handleInsertOrConvert(type: InsertType) {\n    if (hasSelectionContents) {\n      if (type !== 'structure') {\n        onConvert(type)\n      }\n    } else {\n      onInsert(type)\n    }\n  }\n\n  return [\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'button',\n          onClick: () => onEditKey(),\n          icon: faPen,\n          text: 'Edit key',\n          title: 'Edit the key (Double-click on the key)',\n          disabled: !canEditKey\n        },\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onEditValue(),\n            icon: faPen,\n            text: editValueText,\n            title: 'Edit the value (Double-click on the value)',\n            disabled: !canEditValue\n          },\n          width: '11em',\n          items: [\n            {\n              type: 'button',\n              icon: faPen,\n              text: editValueText,\n              title: 'Edit the value (Double-click on the value)',\n              onClick: () => onEditValue(),\n              disabled: !canEditValue\n            },\n            {\n              type: 'button',\n              icon: enforceString ? faCheckSquare : faSquare,\n              text: 'Enforce string',\n              title: 'Enforce keeping the value as string when it contains a numeric value',\n              onClick: () => onToggleEnforceString(),\n              disabled: !canEnforceString\n            }\n          ]\n        }\n      ]\n    },\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onCut(true),\n            icon: faCut,\n            text: 'Cut',\n            title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n            disabled: !canCut\n          },\n          width: '10em',\n          items: [\n            {\n              type: 'button',\n              icon: faCut,\n              text: 'Cut formatted',\n              title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n              onClick: () => onCut(true),\n              disabled: !canCut\n            },\n            {\n              type: 'button',\n              icon: faCut,\n              text: 'Cut compacted',\n              title: 'Cut selected contents, without indentation (Ctrl+Shift+X)',\n              onClick: () => onCut(false),\n              disabled: !canCut\n            }\n          ]\n        },\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onCopy(true),\n            icon: faCopy,\n            text: 'Copy',\n            title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n            disabled: !canCopy\n          },\n          width: '12em',\n          items: [\n            {\n              type: 'button',\n              icon: faCopy,\n              text: 'Copy formatted',\n              title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n              onClick: () => onCopy(true),\n              disabled: !canCopy\n            },\n            {\n              type: 'button',\n              icon: faCopy,\n              text: 'Copy compacted',\n              title: 'Copy selected contents, without indentation (Ctrl+Shift+C)',\n              onClick: () => onCopy(false),\n              disabled: !canCopy\n            }\n          ]\n        },\n        {\n          type: 'button',\n          onClick: () => onPaste(),\n          icon: faPaste,\n          text: 'Paste',\n          title: 'Paste clipboard contents (Ctrl+V)',\n          disabled: !canPaste\n        }\n      ]\n    },\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'column',\n          items: [\n            {\n              type: 'button',\n              onClick: () => onDuplicate(),\n              icon: faClone,\n              text: 'Duplicate',\n              title: 'Duplicate selected contents (Ctrl+D)',\n              disabled: !canDuplicate\n            },\n            {\n              type: 'button',\n              onClick: () => onExtract(),\n              icon: faCropAlt,\n              text: 'Extract',\n              title: 'Extract selected contents',\n              disabled: !canExtract\n            },\n            {\n              type: 'button',\n              onClick: () => onSort(),\n              icon: faSortAmountDownAlt,\n              text: 'Sort',\n              title: 'Sort array or object contents',\n              disabled: readOnly || !hasSelectionContents\n            },\n            {\n              type: 'button',\n              onClick: () => onTransform(),\n              icon: faFilter,\n              text: 'Transform',\n              title: 'Transform array or object contents (filter, sort, project)',\n              disabled: readOnly || !hasSelectionContents\n            },\n            {\n              type: 'button',\n              onClick: () => onRemove(),\n              icon: faTrashCan,\n              text: 'Remove',\n              title: 'Remove selected contents (Delete)',\n              disabled: readOnly || !hasSelectionContents\n            }\n          ]\n        },\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: insertOrConvertText },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('structure'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Structure',\n              title: insertOrConvertText + ' structure like the first item in the array',\n              disabled: !canInsertOrConvertStructure\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('object'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Object',\n              title: insertOrConvertText + ' object',\n              disabled: !canInsertOrConvertObject\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('array'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Array',\n              title: insertOrConvertText + ' array',\n              disabled: !canInsertOrConvertArray\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('value'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Value',\n              title: insertOrConvertText + ' value',\n              disabled: !canInsertOrConvertValue\n            }\n          ]\n        }\n      ]\n    },\n    {\n      type: 'separator'\n    },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'button',\n          onClick: () => onInsertBefore(),\n          icon: faCaretSquareUp,\n          text: 'Insert before',\n          title: 'Select area before current entry to insert or paste contents',\n          disabled: readOnly || !hasSelectionContents || rootSelected\n        },\n        {\n          type: 'button',\n          onClick: () => onInsertAfter(),\n          icon: faCaretSquareDown,\n          text: 'Insert after',\n          title: 'Select area after current entry to insert or paste contents',\n          disabled: readOnly || !hasSelectionContents || rootSelected\n        }\n      ]\n    }\n  ]\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faCopy,\n    faEllipsisV,\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { CONTEXT_MENU_EXPLANATION } from '$lib/constants.js'\n  import { faJSONEditorCollapse, faJSONEditorExpand } from '$lib/img/customFontawesomeIcons.js'\n  import { isObjectOrArray } from '$lib/utils/typeUtils.js'\n  import Menu from '../../../controls/Menu.svelte'\n  import type {\n    HistoryItem,\n    History,\n    JSONSelection,\n    MenuItem,\n    OnRenderMenuInternal\n  } from '$lib/types'\n  import { isKeySelection, isMultiSelection, isValueSelection } from '$lib/logic/selection.js'\n\n  export let json: unknown\n  export let selection: JSONSelection | undefined\n\n  export let readOnly: boolean\n  export let showSearch = false\n  export let history: History<HistoryItem>\n\n  export let onExpandAll: () => void\n  export let onCollapseAll: () => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onContextMenu: (event: MouseEvent) => void\n  export let onCopy: () => void\n  export let onRenderMenu: OnRenderMenuInternal\n\n  function handleToggleSearch() {\n    showSearch = !showSearch\n  }\n\n  $: hasJson = json !== undefined\n  $: hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  let expandMenuItem: MenuItem\n  $: expandMenuItem = {\n    type: 'button',\n    icon: faJSONEditorExpand,\n    title: 'Expand all',\n    className: 'jse-expand-all',\n    onClick: onExpandAll,\n    disabled: !isObjectOrArray(json)\n  }\n\n  let collapseMenuItem: MenuItem\n  $: collapseMenuItem = {\n    type: 'button',\n    icon: faJSONEditorCollapse,\n    title: 'Collapse all',\n    className: 'jse-collapse-all',\n    onClick: onCollapseAll,\n    disabled: !isObjectOrArray(json)\n  }\n\n  let searchMenuItem: MenuItem\n  $: searchMenuItem = {\n    type: 'button',\n    icon: faSearch,\n    title: 'Search (Ctrl+F)',\n    className: 'jse-search',\n    onClick: handleToggleSearch,\n    disabled: json === undefined\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        expandMenuItem,\n        collapseMenuItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || json === undefined\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || json === undefined\n        },\n        searchMenuItem,\n        {\n          type: 'button',\n          icon: faEllipsisV,\n          title: CONTEXT_MENU_EXPLANATION,\n          className: 'jse-contextmenu',\n          onClick: onContextMenu\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !history.canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !history.canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        expandMenuItem,\n        collapseMenuItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faCopy,\n          title: 'Copy (Ctrl+C)',\n          className: 'jse-copy',\n          onClick: onCopy,\n          disabled: !hasSelectionContents\n        },\n        {\n          type: 'separator'\n        },\n        searchMenuItem,\n        {\n          type: 'space'\n        }\n      ]\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","/**\n * Create a readonly proxy around an object or array.\n *\n * Will throw an error when trying to mutate the object or array\n *\n * Inspired by: https://github.com/kourge/readonly-proxy/\n */\nexport function readonlyProxy(target: unknown): unknown {\n  if (!isObject(target)) {\n    return target\n  }\n\n  return new Proxy(target, {\n    get(target, property, receiver) {\n      const value = Reflect.get(target, property, receiver)\n\n      return readonlyProxy(value)\n    },\n\n    set() {\n      return false\n    },\n\n    deleteProperty() {\n      return false\n    }\n  })\n}\n\nfunction isObject(value: unknown): value is object {\n  return typeof value === 'object' && value !== null\n}\n","import { createDebug } from '../utils/debug.js'\nimport type { HistoryInstance, History } from 'svelte-jsoneditor'\n\nconst MAX_HISTORY_ITEMS = 1000\n\nconst debug = createDebug('jsoneditor:History')\n\nexport interface HistoryOptions<T> {\n  maxItems?: number\n  onChange?: (state: History<T>) => void\n}\n\nexport function createHistoryInstance<T>(options: HistoryOptions<T> = {}): HistoryInstance<T> {\n  const maxItems = options.maxItems || MAX_HISTORY_ITEMS\n\n  /**\n   * items in history are sorted from newest first to oldest last\n   */\n  let reverseItems: T[] = []\n\n  let index = 0\n\n  function canUndo(): boolean {\n    return index < reverseItems.length\n  }\n\n  function canRedo(): boolean {\n    return index > 0\n  }\n\n  function get(): History<T> {\n    return {\n      canUndo: canUndo(),\n      canRedo: canRedo(),\n      items: () => reverseItems.slice().reverse(),\n      add,\n      undo,\n      redo,\n      clear\n    }\n  }\n\n  function handleChange() {\n    if (options.onChange) {\n      options.onChange(get())\n    }\n  }\n\n  function add(item: T) {\n    debug('add', item)\n\n    reverseItems = [item].concat(reverseItems.slice(index)).slice(0, maxItems)\n\n    index = 0\n\n    handleChange()\n  }\n\n  function clear() {\n    debug('clear')\n\n    reverseItems = []\n    index = 0\n\n    handleChange()\n  }\n\n  function undo(): T | undefined {\n    if (canUndo()) {\n      const item = reverseItems[index]\n      index += 1\n\n      debug('undo', item)\n\n      handleChange()\n\n      return item\n    }\n\n    return undefined\n  }\n\n  function redo(): T | undefined {\n    if (canRedo()) {\n      index -= 1\n\n      debug('redo', reverseItems[index])\n\n      handleChange()\n\n      return reverseItems[index]\n    }\n\n    return undefined\n  }\n\n  return {\n    get\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { uniqueId } from '$lib/utils/uniqueId.js'\n  import { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\n  import { debounce, isEmpty, noop } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import { DEBOUNCE_DELAY } from '$lib/constants.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, getIn } from 'immutable-json-patch'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { transformModalStates, transformModalStateShared } from './transformModalStates.js'\n  import TransformWizard from './TransformWizard.svelte'\n  import TransformModalHeader from './TransformModalHeader.svelte'\n  import AbsolutePopup from './popup/AbsolutePopup.svelte'\n  import { createDebug } from '$lib/utils/debug.js'\n  import TreeMode from '../modes/treemode/TreeMode.svelte'\n  import type {\n    Content,\n    HistoryItem,\n    History,\n    JSONParser,\n    JSONPathParser,\n    OnChangeQueryLanguage,\n    OnClassName,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    QueryLanguage,\n    QueryLanguageOptions\n  } from '$lib/types.js'\n  import { onEscape } from '$lib/actions/onEscape.js'\n  import { readonlyProxy } from '$lib/utils/readonlyProxy.js'\n  import Modal from './Modal.svelte'\n  import { onMount } from 'svelte'\n  import { createHistoryInstance } from '$lib/logic/history'\n\n  const debug = createDebug('jsoneditor:TransformModal')\n\n  export let id = 'transform-modal-' + uniqueId()\n  export let json: unknown\n  export let rootPath: JSONPath = []\n\n  export let indentation: number | string\n  export let truncateTextSize: number\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onClassName: OnClassName\n\n  export let onTransform: (operations: JSONPatchDocument) => void\n  export let onClose: () => void\n\n  let refQueryInput: HTMLTextAreaElement\n\n  const historyInstance = createHistoryInstance<HistoryItem>({\n    onChange: (updatedHistory) => (history = updatedHistory)\n  })\n\n  let history: History<HistoryItem> = historyInstance.get()\n\n  let selectedJson: unknown | undefined\n  $: selectedJson = readonlyProxy(getIn(json, rootPath))\n  let selectedContent: Content\n  $: selectedContent = selectedJson ? { json: selectedJson } : { text: '' }\n\n  let fullscreen = false\n\n  const stateId = `${id}:${compileJSONPointer(rootPath)}`\n  const state = transformModalStates[stateId] ?? {}\n\n  // showWizard is not stored inside a stateId\n  let showWizard = transformModalStateShared.showWizard !== false\n  let showOriginal = transformModalStateShared.showOriginal !== false\n\n  let queryOptions = state.queryOptions ?? {}\n  let query = queryLanguageId === state.queryLanguageId && state.query ? state.query : ''\n  let isManual = state.isManual ?? false\n  let queryError: string | undefined = undefined\n\n  let previewError: string | undefined = undefined\n  let previewContent: Content = { text: '' }\n\n  if (!isManual) {\n    updateQueryByWizard(queryOptions)\n  }\n\n  onMount(() => {\n    refQueryInput?.focus()\n  })\n\n  function getSelectedQueryLanguage(queryLanguageId: string): QueryLanguage {\n    return queryLanguages.find((item) => item.id === queryLanguageId) ?? queryLanguages[0]\n  }\n\n  function updateQueryByWizard(newQueryOptions: QueryLanguageOptions) {\n    try {\n      queryOptions = newQueryOptions\n\n      query = getSelectedQueryLanguage(queryLanguageId).createQuery(selectedJson, newQueryOptions)\n      queryError = undefined\n      isManual = false\n\n      debug('updateQueryByWizard', { queryOptions, query, isManual })\n    } catch (err) {\n      queryError = String(err)\n    }\n  }\n\n  function handleChangeQuery(event: Event) {\n    query = (event.target as HTMLTextAreaElement).value\n    isManual = true\n    debug('handleChangeQuery', { query, isManual })\n  }\n\n  function previewTransform(previewJson: unknown | undefined, query: string) {\n    if (previewJson === undefined) {\n      previewContent = { text: '' }\n      previewError = 'Error: No JSON'\n      return\n    }\n\n    if (query.trim() === '') {\n      previewContent = { json: previewJson }\n      return\n    }\n\n    try {\n      debug('previewTransform', {\n        query\n      })\n\n      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(\n        previewJson,\n        query,\n        parser\n      )\n\n      previewContent = { json: jsonTransformed }\n      previewError = undefined\n    } catch (err) {\n      previewContent = { text: '' }\n      previewError = String(err)\n    }\n  }\n\n  const previewTransformDebounced = debounce(previewTransform, DEBOUNCE_DELAY)\n\n  $: {\n    previewTransformDebounced(selectedJson, query)\n  }\n\n  $: {\n    // remember the selected values for the next time we open the SortModal\n    // just in memory, not persisted\n    transformModalStates[stateId] = {\n      queryOptions,\n      query,\n      queryLanguageId,\n      isManual\n    }\n\n    debug('store state in memory', stateId, transformModalStates[stateId])\n  }\n\n  function handleTransform() {\n    if (selectedJson === undefined) {\n      previewContent = { text: '' }\n      previewError = 'Error: No JSON'\n      return\n    }\n\n    try {\n      debug('handleTransform', { query })\n      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(\n        selectedJson,\n        query,\n        parser\n      )\n\n      onTransform([\n        {\n          op: 'replace',\n          path: compileJSONPointer(rootPath),\n          value: jsonTransformed\n        }\n      ])\n\n      onClose()\n    } catch (err) {\n      // this should never occur since we can only press the Transform\n      // button when creating a preview was successful\n      console.error(err)\n      previewContent = { text: '' }\n      previewError = String(err)\n    }\n  }\n\n  function toggleShowWizard() {\n    showWizard = !showWizard\n\n    // not stored inside a stateId\n    transformModalStateShared.showWizard = showWizard\n  }\n\n  function toggleShowOriginal() {\n    showOriginal = !showOriginal\n\n    // not stored inside a stateId\n    transformModalStateShared.showOriginal = showOriginal\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    debug('handleChangeQueryLanguage', newQueryLanguageId)\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n\n    updateQueryByWizard(queryOptions)\n  }\n\n  function handleEscape() {\n    if (fullscreen) {\n      fullscreen = !fullscreen\n    } else {\n      onClose()\n    }\n  }\n</script>\n\n<Modal {onClose} className=\"jse-transform-modal\" {fullscreen}>\n  <div class=\"jse-transform-modal-inner\" use:onEscape={handleEscape}>\n    <AbsolutePopup>\n      <TransformModalHeader\n        {queryLanguages}\n        {queryLanguageId}\n        onChangeQueryLanguage={handleChangeQueryLanguage}\n        {onClose}\n        bind:fullscreen\n      />\n      <div class=\"jse-modal-contents\">\n        <div class=\"jse-main-contents\">\n          <div class=\"jse-query-contents\">\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Language</div>\n            </div>\n            <div class=\"jse-description\">\n              <!-- eslint-disable-next-line svelte/no-at-html-tags -->\n              {@html getSelectedQueryLanguage(queryLanguageId).description}\n            </div>\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Path</div>\n            </div>\n            <input\n              class=\"jse-path\"\n              type=\"text\"\n              readonly\n              title=\"Selected path\"\n              value={!isEmpty(rootPath) ? stringifyJSONPath(rootPath) : '(document root)'}\n            />\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">\n                <button type=\"button\" on:click={toggleShowWizard}>\n                  <Icon data={showWizard ? faCaretDown : faCaretRight} />\n                  Wizard\n                </button>\n              </div>\n            </div>\n            {#if showWizard}\n              {#if Array.isArray(selectedJson)}\n                <TransformWizard\n                  {queryOptions}\n                  json={selectedJson}\n                  onChange={updateQueryByWizard}\n                />\n                {#if queryError}\n                  <div class=\"query-error\">\n                    {queryError}\n                  </div>\n                {/if}\n              {:else}\n                (Only available for arrays, not for objects)\n              {/if}\n            {/if}\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Query</div>\n            </div>\n            <textarea\n              bind:this={refQueryInput}\n              class=\"jse-query\"\n              spellcheck=\"false\"\n              on:input={handleChangeQuery}>{query}</textarea\n            >\n          </div>\n          <div class=\"jse-data-contents\" class:jse-hide-original-data={!showOriginal}>\n            <div class=\"jse-original-data\" class:jse-hide={!showOriginal}>\n              <div class=\"jse-label\">\n                <div class=\"jse-label-inner\">\n                  <button type=\"button\" on:click={toggleShowOriginal}>\n                    <Icon data={showOriginal ? faCaretDown : faCaretRight} />\n                    Original\n                  </button>\n                </div>\n              </div>\n              {#if showOriginal}\n                <TreeMode\n                  externalContent={selectedContent}\n                  externalSelection={undefined}\n                  {history}\n                  readOnly={true}\n                  {truncateTextSize}\n                  mainMenuBar={false}\n                  navigationBar={false}\n                  {indentation}\n                  {escapeControlCharacters}\n                  {escapeUnicodeCharacters}\n                  {parser}\n                  {parseMemoizeOne}\n                  {onRenderValue}\n                  {onRenderMenu}\n                  {onRenderContextMenu}\n                  onError={console.error}\n                  onChange={noop}\n                  onChangeMode={noop}\n                  onSelect={noop}\n                  onUndo={noop}\n                  onRedo={noop}\n                  onFocus={noop}\n                  onBlur={noop}\n                  onSortModal={noop}\n                  onTransformModal={noop}\n                  onJSONEditorModal={noop}\n                  {onClassName}\n                  validator={undefined}\n                  {validationParser}\n                  {pathParser}\n                />\n              {/if}\n            </div>\n            <div class=\"jse-preview-data\">\n              <div class=\"jse-label\">\n                <div class=\"jse-label-inner\">Preview</div>\n              </div>\n              {#if !previewError}\n                <TreeMode\n                  externalContent={previewContent}\n                  externalSelection={undefined}\n                  {history}\n                  readOnly={true}\n                  {truncateTextSize}\n                  mainMenuBar={false}\n                  navigationBar={false}\n                  {indentation}\n                  {escapeControlCharacters}\n                  {escapeUnicodeCharacters}\n                  {parser}\n                  {parseMemoizeOne}\n                  {onRenderValue}\n                  {onRenderMenu}\n                  {onRenderContextMenu}\n                  onError={console.error}\n                  onChange={noop}\n                  onChangeMode={noop}\n                  onSelect={noop}\n                  onUndo={noop}\n                  onRedo={noop}\n                  onFocus={noop}\n                  onBlur={noop}\n                  onSortModal={noop}\n                  onTransformModal={noop}\n                  onJSONEditorModal={noop}\n                  {onClassName}\n                  validator={undefined}\n                  {validationParser}\n                  {pathParser}\n                />\n              {:else}\n                <div class=\"jse-preview jse-error\">\n                  {previewError}\n                </div>\n              {/if}\n            </div>\n          </div>\n        </div>\n\n        <div class=\"jse-actions\">\n          <button\n            type=\"button\"\n            class=\"jse-primary\"\n            on:click={handleTransform}\n            use:focus\n            disabled={!!previewError}\n          >\n            Transform\n          </button>\n        </div>\n      </div>\n    </AbsolutePopup>\n  </div>\n</Modal>\n\n<style src=\"./TransformModal.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getContext } from 'svelte'\n  import Icon from 'svelte-awesome'\n  import { faCog } from '@fortawesome/free-solid-svg-icons'\n  import SelectQueryLanguage from '../controls/selectQueryLanguage/SelectQueryLanguage.svelte'\n  import type { AbsolutePopupContext, OnChangeQueryLanguage, QueryLanguage } from '$lib/types.js'\n  import Header from './Header.svelte'\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let fullscreen: boolean\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n  export let onClose: () => void\n\n  let refConfigButton: HTMLButtonElement | undefined\n  let popupId: number | undefined\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  function openConfig() {\n    const props = {\n      queryLanguages,\n      queryLanguageId,\n      onChangeQueryLanguage: (queryLanguageId: string) => {\n        closeAbsolutePopup(popupId)\n        onChangeQueryLanguage(queryLanguageId)\n      }\n    }\n\n    popupId = openAbsolutePopup(SelectQueryLanguage, props, {\n      offsetTop: -2,\n      offsetLeft: 0,\n      anchor: refConfigButton,\n      closeOnOuterClick: true\n    })\n  }\n</script>\n\n<Header title=\"Transform\" fullScreenButton={true} bind:fullscreen {onClose}>\n  <button\n    slot=\"actions\"\n    type=\"button\"\n    bind:this={refConfigButton}\n    class=\"jse-config\"\n    class:hide={queryLanguages.length <= 1}\n    on:click={openConfig}\n    title=\"Select a query language\"\n  >\n    <Icon data={faCog} />\n  </button>\n</Header>\n\n<style src=\"./TransformModalHeader.scss\"></style>\n","export function noop() {\n  return undefined\n}\n","import { HighlightStyle, syntaxHighlighting } from '@codemirror/language'\nimport { tags } from '@lezer/highlight'\n\nconst highlightStyle = HighlightStyle.define([\n  { tag: tags.propertyName, color: 'var(--internal-key-color)' }, // keys\n  { tag: tags.number, color: 'var(--internal-value-color-number)' },\n  { tag: tags.bool, color: 'var(--internal-value-color-boolean)' },\n  { tag: tags.string, color: 'var(--internal-value-color-string)' },\n  { tag: tags.keyword, color: 'var(--internal-value-color-null)' } // null\n])\n\nexport const highlighter = syntaxHighlighting(highlightStyle)\n\n// TODO: remove workaround when not needed anymore\n// Workaround for the error \"CodeMirror plugin crashed: TypeError: tags3 is undefined\"\n// thrown when using the json() language from '@codemirror/lang-json'\n//\n// Note that a plain CodeSandbox with parcel and code mirror v6.0.0,\n// so it is maybe related to Vite\n//\n// See https://discuss.codemirror.net/t/highlighting-that-seems-ignored-in-cm6/4320/15\nconst originalStyle = highlightStyle.style\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n// noinspection JSConstantReassignment\nhighlightStyle.style = (tags) => originalStyle(tags || [])\n","import { getIndentUnit } from \"@codemirror/language\";\nimport { RangeSetBuilder } from \"@codemirror/state\";\nimport { Decoration, ViewPlugin, } from \"@codemirror/view\";\nclass WrappedLineIndent {\n    constructor(view) {\n        this.view = view;\n        this.indentUnit = getIndentUnit(view.state);\n        this.initialPaddingLeft = null;\n        this.isChrome = window === null || window === void 0 ? void 0 : window.navigator.userAgent.includes(\"Chrome\");\n        this.generate(view.state);\n    }\n    update(update) {\n        const indentUnit = getIndentUnit(update.state);\n        if (indentUnit !== this.indentUnit ||\n            update.docChanged ||\n            update.viewportChanged) {\n            this.indentUnit = indentUnit;\n            this.generate(update.state);\n        }\n    }\n    generate(state) {\n        const builder = new RangeSetBuilder();\n        if (this.initialPaddingLeft) {\n            this.addStyleToBuilder(builder, state, this.initialPaddingLeft);\n        }\n        else {\n            this.view.requestMeasure({\n                read: (view) => {\n                    const lineElement = view.contentDOM.querySelector(\".cm-line\");\n                    if (lineElement) {\n                        this.initialPaddingLeft = window\n                            .getComputedStyle(lineElement)\n                            .getPropertyValue(\"padding-left\");\n                        this.addStyleToBuilder(builder, view.state, this.initialPaddingLeft);\n                    }\n                    this.decorations = builder.finish();\n                },\n            });\n        }\n        this.decorations = builder.finish();\n    }\n    addStyleToBuilder(builder, state, initialPaddingLeft) {\n        const visibleLines = this.getVisibleLines(state);\n        for (const line of visibleLines) {\n            const { numColumns, containsTab } = this.numColumns(line.text, state.tabSize);\n            const paddingValue = `calc(${numColumns + this.indentUnit}ch + ${initialPaddingLeft})`;\n            const textIndentValue = this.isChrome\n                ? `calc(-${numColumns + this.indentUnit}ch - ${containsTab ? 1 : 0}px)`\n                : `-${numColumns + this.indentUnit}ch`;\n            builder.add(line.from, line.from, Decoration.line({\n                attributes: {\n                    style: `padding-left: ${paddingValue}; text-indent: ${textIndentValue};`,\n                },\n            }));\n        }\n    }\n    // Get all lines that are currently visible in the viewport.\n    getVisibleLines(state) {\n        const lines = new Set();\n        let lastLine = null;\n        for (const { from, to } of this.view.visibleRanges) {\n            let pos = from;\n            while (pos <= to) {\n                const line = state.doc.lineAt(pos);\n                if (lastLine !== line) {\n                    lines.add(line);\n                    lastLine = line;\n                }\n                pos = line.to + 1;\n            }\n        }\n        return lines;\n    }\n    numColumns(str, tabSize) {\n        let cols = 0;\n        let containsTab = false;\n        loop: for (let i = 0; i < str.length; i++) {\n            switch (str[i]) {\n                case \" \": {\n                    cols += 1;\n                    continue loop;\n                }\n                case \"\\t\": {\n                    cols += tabSize - (cols % tabSize);\n                    containsTab = true;\n                    continue loop;\n                }\n                case \"\\r\": {\n                    continue loop;\n                }\n                default: {\n                    break loop;\n                }\n            }\n        }\n        return { numColumns: cols, containsTab };\n    }\n}\nexport const wrappedLineIndent = [\n    ViewPlugin.fromClass(WrappedLineIndent, {\n        decorations: (v) => v.decorations,\n    }),\n];\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faExclamationTriangle,\n    faEye,\n    faTimes,\n    faWrench\n  } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { immutableJSONPatch, revertJSONPatch } from 'immutable-json-patch'\n  import { jsonrepair } from 'jsonrepair'\n  import { debounce, isEqual, uniqueId } from 'lodash-es'\n  import { flushSync, onDestroy, onMount } from 'svelte'\n  import {\n    JSON_STATUS_INVALID,\n    JSON_STATUS_REPAIRABLE,\n    JSON_STATUS_VALID,\n    MAX_CHARACTERS_TEXT_PREVIEW,\n    MAX_DOCUMENT_SIZE_TEXT_MODE,\n    TEXT_MODE_ONCHANGE_DELAY\n  } from '$lib/constants.js'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    getWindow\n  } from '$lib/utils/domUtils.js'\n  import { formatSize } from '$lib/utils/fileUtils.js'\n  import { findTextLocation, getText, needsFormatting } from '$lib/utils/jsonUtils.js'\n  import { createFocusTracker } from '../../controls/createFocusTracker.js'\n  import Message from '../../controls/Message.svelte'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import TextMenu from './menu/TextMenu.svelte'\n  import {\n    Annotation,\n    ChangeSet,\n    Compartment,\n    EditorSelection,\n    EditorState,\n    type Extension\n  } from '@codemirror/state'\n  import {\n    crosshairCursor,\n    drawSelection,\n    dropCursor,\n    EditorView,\n    highlightActiveLine,\n    highlightActiveLineGutter,\n    highlightSpecialChars,\n    keymap,\n    lineNumbers,\n    rectangularSelection,\n    type ViewUpdate\n  } from '@codemirror/view'\n  import { defaultKeymap, indentWithTab } from '@codemirror/commands'\n  import type { Diagnostic } from '@codemirror/lint'\n  import { linter, lintGutter, lintKeymap } from '@codemirror/lint'\n  import { json as jsonLang } from '@codemirror/lang-json'\n  import {\n    bracketMatching,\n    defaultHighlightStyle,\n    foldGutter,\n    foldKeymap,\n    indentOnInput,\n    indentUnit,\n    syntaxHighlighting\n  } from '@codemirror/language'\n  import {\n    closeSearchPanel,\n    highlightSelectionMatches,\n    openSearchPanel,\n    search,\n    searchKeymap\n  } from '@codemirror/search'\n  import {\n    autocompletion,\n    closeBrackets,\n    closeBracketsKeymap,\n    completionKeymap\n  } from '@codemirror/autocomplete'\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import jsonSourceMap from 'json-source-map'\n  import StatusBar from './StatusBar.svelte'\n  import { highlighter } from './codemirror/codemirror-theme.js'\n  import type {\n    Content,\n    ContentErrors,\n    History,\n    HistoryItem,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnError,\n    OnFocus,\n    OnRedo,\n    OnRenderMenuInternal,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    OnUndo,\n    ParseError,\n    RichValidationError,\n    TextHistoryItem,\n    TextSelection,\n    TransformModalOptions,\n    ValidationError,\n    Validator\n  } from '$lib/types.js'\n  import { Mode, SelectionType, ValidationSeverity } from '$lib/types.js'\n  import {\n    isContentParseError,\n    isContentValidationErrors,\n    isTextHistoryItem\n  } from '$lib/typeguards.js'\n  import memoizeOne from 'memoize-one'\n  import { validateText } from '$lib/logic/validation.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { faJSONEditorFormat } from '$lib/img/customFontawesomeIcons.js'\n  import { indentationMarkers } from '@replit/codemirror-indentation-markers'\n  import { isTextSelection } from '$lib/logic/selection.js'\n  import { wrappedLineIndent } from 'codemirror-wrapped-line-indent/dist/index.js' // ensure loading ESM, otherwise the vitest test fail\n\n  export let readOnly: boolean\n  export let mainMenuBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let history: History<HistoryItem>\n  export let indentation: number | string\n  export let tabSize: number\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onUndo: OnUndo\n  export let onRedo: OnRedo\n  export let onError: OnError\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n\n  const debug = createDebug('jsoneditor:TextMode')\n\n  const formatCompactKeyBinding = {\n    key: 'Mod-i',\n    run: handleFormat,\n    shift: handleCompact,\n    preventDefault: true\n  }\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  let codeMirrorRef: HTMLDivElement\n  let domTextMode: HTMLDivElement\n  let codeMirrorView: EditorView\n  let editorState: EditorState\n\n  let acceptTooLarge = false\n  let askToFormatApplied = askToFormat\n\n  let validationErrors: ValidationError[] = []\n  const linterCompartment = new Compartment()\n  const readOnlyCompartment = new Compartment()\n  const indentCompartment = new Compartment()\n  const tabSizeCompartment = new Compartment()\n  const themeCompartment = new Compartment()\n\n  let content: Content = externalContent\n  let text = getText(content, indentation, parser) // text is just a cached version of content.text or parsed content.json\n\n  let historyAnnotation = Annotation.define()\n\n  let historyUpdatesQueue: ViewUpdate[] | null = null\n\n  function addHistoryItem(): boolean {\n    if (!historyUpdatesQueue || historyUpdatesQueue.length === 0) {\n      return false\n    }\n\n    // merge changes and create the inverse changes\n    const startState = historyUpdatesQueue[0].startState\n    const endState = historyUpdatesQueue[historyUpdatesQueue.length - 1].state\n    const mergedChanges = historyUpdatesQueue\n      .map((update) => update.changes)\n      .reduce((mergedChanges, change) => mergedChanges.compose(change))\n    const inverseChanges = mergedChanges.invert(startState.doc)\n\n    // create a history item with undo/redo actions\n    const item: TextHistoryItem = {\n      type: 'text',\n      undo: {\n        changes: inverseChanges.toJSON(),\n        selection: toTextSelection(startState.selection)\n      },\n      redo: {\n        changes: mergedChanges.toJSON(),\n        selection: toTextSelection(endState.selection)\n      }\n    }\n\n    debug('add history item', item)\n\n    history.add(item)\n\n    historyUpdatesQueue = null\n    return true\n  }\n\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters: false,\n    escapeUnicodeCharacters\n  })\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: setCodeMirrorContent(externalContent, false, false)\n  $: applyExternalSelection(externalSelection)\n  $: updateLinter(validator)\n  $: updateIndentation(indentation)\n  $: updateTabSize(tabSize)\n  $: updateReadOnly(readOnly)\n\n  // force updating the text when escapeUnicodeCharacters changes\n  let previousEscapeUnicodeCharacters = escapeUnicodeCharacters\n  $: {\n    if (previousEscapeUnicodeCharacters !== escapeUnicodeCharacters) {\n      previousEscapeUnicodeCharacters = escapeUnicodeCharacters\n      forceUpdateText()\n    }\n  }\n\n  onMount(async () => {\n    if (isSSR) {\n      return\n    }\n\n    try {\n      codeMirrorView = createCodeMirrorView({\n        target: codeMirrorRef,\n        initialText: !disableTextEditor(text, acceptTooLarge)\n          ? normalization.escapeValue(text)\n          : '',\n        readOnly,\n        indentation\n      })\n    } catch (err) {\n      // TODO: report error to the user\n      console.error(err)\n    }\n  })\n\n  onDestroy(() => {\n    flush()\n\n    if (codeMirrorView) {\n      debug('Destroy CodeMirror editor')\n      codeMirrorView.destroy()\n    }\n  })\n\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  export function focus() {\n    if (codeMirrorView) {\n      debug('focus')\n      codeMirrorView.focus()\n    }\n  }\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(domTextMode),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(domTextMode),\n    onFocus,\n    onBlur: () => {\n      flush()\n      onBlur()\n    }\n  })\n\n  export function patch(operations: JSONPatchDocument): JSONPatchResult {\n    return handlePatch(operations, false)\n  }\n\n  export function handlePatch(operations: JSONPatchDocument, emitChange: boolean): JSONPatchResult {\n    debug('handlePatch', operations, emitChange)\n\n    const previousJson = parser.parse(text)\n    const updatedJson = immutableJSONPatch(previousJson, operations)\n    const undo = revertJSONPatch(previousJson, operations)\n    const updatedContent = {\n      text: parser.stringify(updatedJson, null, indentation) as string\n    }\n\n    setCodeMirrorContent(updatedContent, emitChange, false)\n\n    return {\n      json: updatedJson,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handleFormat(): boolean {\n    debug('format')\n\n    if (readOnly) {\n      return false\n    }\n\n    try {\n      const updatedJson = parser.parse(text)\n      const updatedContent = {\n        text: parser.stringify(updatedJson, null, indentation) as string\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      askToFormatApplied = askToFormat // reset to the original value\n\n      return true\n    } catch (err) {\n      onError(err as Error)\n    }\n\n    return false\n  }\n\n  function handleCompact(): boolean {\n    debug('compact')\n\n    if (readOnly) {\n      return false\n    }\n\n    try {\n      const updatedJson = parser.parse(text)\n      const updatedContent = {\n        text: parser.stringify(updatedJson) as string\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      askToFormatApplied = false\n\n      return true\n    } catch (err) {\n      onError(err as Error)\n    }\n\n    return false\n  }\n\n  function handleRepair() {\n    debug('repair')\n\n    if (readOnly) {\n      return\n    }\n\n    try {\n      const updatedContent = {\n        text: jsonrepair(text)\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      jsonStatus = JSON_STATUS_VALID\n      jsonParseError = undefined\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleSort() {\n    if (readOnly) {\n      return\n    }\n\n    try {\n      const json = parser.parse(text)\n\n      modalOpen = true\n\n      onSortModal({\n        id: sortModalId,\n        json,\n        rootPath: [],\n        onSort: async ({ operations }) => {\n          debug('onSort', operations)\n          handlePatch(operations, true)\n        },\n        onClose: () => {\n          modalOpen = false\n          focus()\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal({\n    id,\n    rootPath,\n    onTransform,\n    onClose\n  }: TransformModalOptions) {\n    try {\n      const json = parser.parse(text)\n\n      modalOpen = true\n\n      onTransformModal({\n        id: id || transformModalId,\n        json,\n        rootPath: rootPath || [],\n        onTransform: (operations) => {\n          if (onTransform) {\n            onTransform({\n              operations,\n              json,\n              transformedJson: immutableJSONPatch(json, operations)\n            })\n          } else {\n            debug('onTransform', operations)\n            handlePatch(operations, true)\n          }\n        },\n        onClose: () => {\n          modalOpen = false\n          focus()\n          if (onClose) {\n            onClose()\n          }\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleTransform() {\n    if (readOnly) {\n      return\n    }\n\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function handleToggleSearch() {\n    if (codeMirrorView) {\n      // TODO: figure out the proper way to detect whether the search panel is open\n      if (codeMirrorRef && codeMirrorRef.querySelector('.cm-search')) {\n        closeSearchPanel(codeMirrorView)\n      } else {\n        openSearchPanel(codeMirrorView)\n      }\n    }\n  }\n\n  function handleUndo(): boolean {\n    if (readOnly) {\n      return false\n    }\n\n    // first flush any pending changes\n    flush()\n\n    const item = history.undo()\n    debug('undo', item)\n    if (!isTextHistoryItem(item)) {\n      onUndo(item)\n\n      return false\n    }\n\n    codeMirrorView.dispatch({\n      annotations: historyAnnotation.of('undo'),\n      changes: ChangeSet.fromJSON(item.undo.changes),\n      selection: EditorSelection.fromJSON(item.undo.selection),\n      scrollIntoView: true\n    })\n\n    return true\n  }\n\n  function handleRedo(): boolean {\n    if (readOnly) {\n      return false\n    }\n\n    // first flush any pending changes\n    flush()\n\n    const item = history.redo()\n    debug('redo', item)\n    if (!isTextHistoryItem(item)) {\n      onRedo(item)\n\n      return false\n    }\n\n    codeMirrorView.dispatch({\n      annotations: historyAnnotation.of('redo'),\n      changes: ChangeSet.fromJSON(item.redo.changes),\n      selection: EditorSelection.fromJSON(item.redo.selection),\n      scrollIntoView: true\n    })\n\n    return true\n  }\n\n  function handleAcceptTooLarge() {\n    acceptTooLarge = true\n    setCodeMirrorContent(externalContent, true, true)\n  }\n\n  function handleSwitchToTreeMode() {\n    onChangeMode(Mode.tree)\n  }\n\n  function cancelLoadTooLarge() {\n    // copy the latest contents of the text editor again into text\n    onChangeCodeMirrorValue()\n  }\n\n  function handleSelectValidationError(validationError: ValidationError) {\n    debug('select validation error', validationError)\n\n    const { from, to } = toRichValidationError(validationError)\n    if (from === undefined || to === undefined) {\n      return\n    }\n\n    // we take \"to\" as head, not as anchor, because the scrollIntoView will\n    // move to the head, and when a large whole object is selected as a whole,\n    // we want to scroll to the start of the object and not the end\n    setSelection(from, to)\n\n    focus()\n  }\n\n  function handleSelectParseError(parseError: ParseError) {\n    debug('select parse error', parseError)\n\n    const richParseError = toRichParseError(parseError, false)\n    const from = richParseError.from != null ? richParseError.from : 0\n    const to = richParseError.to != null ? richParseError.to : 0\n\n    // we take \"to\" as head, not as anchor, because the scrollIntoView will\n    // move to the head, and when a large whole object is selected as a whole,\n    // we want to scroll to the start of the object and not the end\n    setSelection(from, to)\n\n    focus()\n  }\n\n  function setSelection(anchor: number, head: number) {\n    debug('setSelection', { anchor, head })\n\n    if (codeMirrorView) {\n      codeMirrorView.dispatch(\n        codeMirrorView.state.update({\n          selection: { anchor, head },\n          scrollIntoView: true\n        })\n      )\n    }\n  }\n\n  function handleDoubleClick(_event: MouseEvent, view: EditorView) {\n    // When the user double-clicked right from a bracket [ or {,\n    // select the contents of the array or object\n    if (view.state.selection.ranges.length === 1) {\n      const range = view.state.selection.ranges[0]\n      const selectedText = text.slice(range.from, range.to)\n      if (selectedText === '{' || selectedText === '[') {\n        const jsmap = jsonSourceMap.parse(text)\n        const path = Object.keys(jsmap.pointers).find((path) => {\n          const pointer = jsmap.pointers[path]\n          return pointer.value?.pos === range.from\n        })\n        const pointer = jsmap.pointers[path]\n\n        if (path && pointer && pointer.value && pointer.valueEnd) {\n          debug('pointer found, selecting inner contents of path:', path, pointer)\n          const anchor = pointer.value.pos + 1\n          const head = pointer.valueEnd.pos - 1\n          setSelection(anchor, head)\n        }\n      }\n    }\n  }\n\n  function createLinter() {\n    return linter(linterCallback, { delay: TEXT_MODE_ONCHANGE_DELAY })\n  }\n\n  function createCodeMirrorView({\n    target,\n    initialText,\n    readOnly,\n    indentation\n  }: {\n    target: HTMLDivElement\n    initialText: string\n    readOnly: boolean\n    indentation: number | string\n  }): EditorView {\n    debug('Create CodeMirror editor', { readOnly, indentation })\n\n    const selection = isValidSelection(externalSelection, initialText)\n      ? fromTextSelection(externalSelection)\n      : undefined\n\n    const state = EditorState.create({\n      doc: initialText,\n      selection,\n      extensions: [\n        keymap.of([indentWithTab, formatCompactKeyBinding]),\n        linterCompartment.of(createLinter()),\n        lintGutter(),\n        lineNumbers(),\n        highlightActiveLineGutter(),\n        highlightSpecialChars(),\n        foldGutter(),\n        drawSelection(),\n        dropCursor(),\n        EditorState.allowMultipleSelections.of(true),\n        indentOnInput(),\n        syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n        bracketMatching(),\n        closeBrackets(),\n        autocompletion(),\n        rectangularSelection(),\n        crosshairCursor(),\n        highlightActiveLine(),\n        highlightSelectionMatches(),\n        keymap.of([\n          ...closeBracketsKeymap,\n          ...defaultKeymap,\n          ...searchKeymap,\n          { key: 'Mod-z', run: handleUndo, preventDefault: true },\n          { key: 'Mod-y', mac: 'Mod-Shift-z', run: handleRedo, preventDefault: true },\n          { key: 'Ctrl-Shift-z', run: handleRedo, preventDefault: true },\n          ...foldKeymap,\n          ...completionKeymap,\n          ...lintKeymap\n        ]),\n        highlighter,\n        indentationMarkers({ hideFirstIndent: true }),\n        EditorView.domEventHandlers({\n          dblclick: handleDoubleClick\n        }),\n        EditorView.updateListener.of((update) => {\n          editorState = update.state\n\n          if (update.docChanged) {\n            const isCustomHistoryEvent = update.transactions.some(\n              (transaction) => !!transaction.annotation(historyAnnotation)\n            )\n\n            if (!isCustomHistoryEvent) {\n              historyUpdatesQueue = [...(historyUpdatesQueue ?? []), update]\n            }\n\n            onChangeCodeMirrorValueDebounced()\n          }\n\n          if (update.selectionSet) {\n            // note that emitOnSelect is invoked in onChangeCodeMirrorValue too,\n            // right after firing onChange. Hence, the else if here, we do not want to fire it twice.\n            emitOnSelect()\n          }\n        }),\n        jsonLang(),\n        search({\n          top: true\n        }),\n        EditorView.lineWrapping,\n        readOnlyCompartment.of(EditorState.readOnly.of(readOnly)),\n        tabSizeCompartment.of(EditorState.tabSize.of(tabSize)),\n        indentCompartment.of(createIndent(indentation)),\n        themeCompartment.of(EditorView.theme({}, { dark: hasDarkTheme() }))\n      ]\n    })\n\n    codeMirrorView = new EditorView({\n      state,\n      parent: target\n    })\n\n    if (selection) {\n      // important to do via dispatch, since that is executed on the next tick.\n      // Otherwise, the editor is not scrolled down enough when the statusbar is rendered on the next tick\n      codeMirrorView.dispatch(\n        codeMirrorView.state.update({\n          selection: selection.main,\n          scrollIntoView: true // FIXME: scrollIntoView also affects scroll of the main page, possibly causing the main page to scroll when jsoneditor has an initial selection\n        })\n      )\n    }\n\n    return codeMirrorView\n  }\n\n  function getCodeMirrorValue() {\n    return codeMirrorView ? normalization.unescapeValue(codeMirrorView.state.doc.toString()) : ''\n  }\n\n  function hasDarkTheme() {\n    return codeMirrorRef\n      ? getComputedStyle(codeMirrorRef).getPropertyValue('--jse-theme').includes('dark')\n      : false\n  }\n\n  function isValidSelection(selection: JSONEditorSelection | undefined, text: string): boolean {\n    if (!isTextSelection(selection)) {\n      return false\n    }\n\n    return selection.ranges.every((range) => range.anchor < text.length && range.head < text.length)\n  }\n\n  function toRichValidationError(validationError: ValidationError): RichValidationError {\n    const { path, message, severity } = validationError\n    const { line, column, from, to } = findTextLocation(normalization.escapeValue(text), path)\n\n    return {\n      path,\n      line,\n      column,\n      from,\n      to,\n      message,\n      severity,\n      actions: []\n    }\n  }\n\n  function toRichParseError(parseError: ParseError, isRepairable: boolean): RichValidationError {\n    const { line, column, position, message } = parseError\n\n    return {\n      path: [] as JSONPath,\n      line,\n      column,\n      from: position,\n      to: position,\n      severity: ValidationSeverity.error,\n      message,\n      actions:\n        isRepairable && !readOnly\n          ? [\n              {\n                name: 'Auto repair',\n                apply: () => handleRepair()\n              }\n            ]\n          : undefined\n    }\n  }\n\n  function toDiagnostic(error: RichValidationError): Diagnostic {\n    return {\n      from: error.from || 0,\n      to: error.to || 0,\n      message: error.message || '',\n      actions: error.actions as Diagnostic['actions'],\n      severity: error.severity\n    }\n  }\n\n  function setCodeMirrorContent(newContent: Content, emitChange: boolean, forceUpdate: boolean) {\n    const newText = getText(newContent, indentation, parser)\n    const isChanged = !isEqual(newContent, content)\n    const previousContent = content\n\n    debug('setCodeMirrorContent', { isChanged, emitChange, forceUpdate })\n\n    if (!codeMirrorView || (!isChanged && !forceUpdate)) {\n      return\n    }\n\n    content = newContent\n    text = newText\n\n    if (!disableTextEditor(text, acceptTooLarge)) {\n      // keep state\n      // to reset state: codeMirrorView.setState(EditorState.create({doc: text, extensions: ...}))\n      codeMirrorView.dispatch({\n        changes: {\n          from: 0,\n          to: codeMirrorView.state.doc.length,\n          insert: normalization.escapeValue(text)\n        }\n      })\n    }\n\n    addHistoryItem()\n\n    if (isChanged && emitChange) {\n      emitOnChange(content, previousContent)\n    }\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (!isTextSelection(externalSelection)) {\n      return\n    }\n\n    const selection = fromTextSelection(externalSelection)\n    if (codeMirrorView && selection && (!editorState || !editorState.selection.eq(selection))) {\n      debug('applyExternalSelection', selection)\n\n      // note that we cannot clear the selection (we could maybe set the cursor to 0 but that's not really what we want)\n      codeMirrorView.dispatch({ selection })\n    }\n  }\n\n  function fromTextSelection(\n    selection: JSONEditorSelection | undefined\n  ): EditorSelection | undefined {\n    return isTextSelection(selection) ? EditorSelection.fromJSON(selection) : undefined\n  }\n\n  /**\n   * Force refreshing the editor, for example after changing the font size\n   * to update the positioning of the line numbers in the gutter\n   */\n  export async function refresh(): Promise<void> {\n    debug('refresh')\n\n    // update the theme (light/dark), but also, as a side effect,\n    // refresh the font size of the line numbers in the gutter\n    await updateTheme()\n  }\n\n  function forceUpdateText() {\n    debug('forceUpdateText', { escapeUnicodeCharacters })\n\n    if (codeMirrorView) {\n      codeMirrorView.dispatch({\n        changes: {\n          from: 0,\n          to: codeMirrorView.state.doc.length,\n          insert: normalization.escapeValue(text)\n        }\n      })\n    }\n  }\n\n  function onChangeCodeMirrorValue() {\n    if (!codeMirrorView) {\n      return\n    }\n\n    const codeMirrorText = getCodeMirrorValue()\n\n    const isChanged = codeMirrorText !== text\n    debug('onChangeCodeMirrorValue', { isChanged })\n    if (!isChanged) {\n      return\n    }\n\n    const previousContent = content\n    text = codeMirrorText\n    content = { text }\n\n    addHistoryItem()\n\n    emitOnChange(content, previousContent)\n\n    // We emit OnSelect on the next tick to cater for the case where\n    // the user changes the content directly inside the OnChange callback.\n    // This change will be dispatched by Svelte on the next tick. Before\n    // that tick, emitOnSelect would be fired based on the \"old\" contents,\n    // which may be out of range when the replacement by the user is shorter.\n    flushSync()\n    emitOnSelect()\n  }\n\n  function updateLinter(validator: Validator | undefined) {\n    debug('updateLinter', validator)\n\n    if (!codeMirrorView) {\n      return\n    }\n\n    codeMirrorView.dispatch({\n      effects: linterCompartment.reconfigure(createLinter())\n    })\n  }\n\n  function updateIndentation(indentation: number | string) {\n    if (codeMirrorView) {\n      debug('updateIndentation', indentation)\n\n      codeMirrorView.dispatch({\n        effects: indentCompartment.reconfigure(createIndent(indentation))\n      })\n    }\n  }\n\n  function updateTabSize(tabSize: number) {\n    if (codeMirrorView) {\n      debug('updateTabSize', tabSize)\n\n      codeMirrorView.dispatch({\n        effects: tabSizeCompartment.reconfigure(EditorState.tabSize.of(tabSize))\n      })\n    }\n  }\n\n  function updateReadOnly(readOnly: boolean) {\n    if (codeMirrorView) {\n      debug('updateReadOnly', readOnly)\n\n      codeMirrorView.dispatch({\n        effects: [readOnlyCompartment.reconfigure(EditorState.readOnly.of(readOnly))]\n      })\n    }\n  }\n\n  async function updateTheme(): Promise<void> {\n    // we check the theme on the next tick, to make sure the page\n    // is re-rendered with (possibly) changed CSS variables\n    flushSync()\n\n    if (codeMirrorView) {\n      const dark = hasDarkTheme()\n      debug('updateTheme', { dark })\n\n      codeMirrorView.dispatch({\n        effects: [themeCompartment.reconfigure(EditorView.theme({}, { dark }))]\n      })\n\n      // resolve on next tick, when code mirror rendering is updated\n      return new Promise((resolve) => setTimeout(resolve))\n    }\n\n    return Promise.resolve()\n  }\n\n  function createIndent(indentation: number | string): Extension[] {\n    const indent = indentUnit.of(\n      typeof indentation === 'number' ? ' '.repeat(indentation) : indentation\n    )\n\n    // We disable wrappedLineIndent in case of tabs to work around a bug:\n    // https://github.com/fauzi9331/codemirror-wrapped-line-indent/issues/2\n    return indentation === '\\t' ? [indent] : [indent, wrappedLineIndent]\n  }\n\n  // debounce the input: when pressing Enter at the end of a line, two change\n  // events are fired: one with the new Return character, and a second with\n  // indentation added on the new line. This causes a race condition when used\n  // for example in React. Debouncing the onChange events also results in not\n  // firing a change event with every character that a user types, but only as\n  // soon as the user stops typing.\n  const onChangeCodeMirrorValueDebounced = debounce(\n    onChangeCodeMirrorValue,\n    TEXT_MODE_ONCHANGE_DELAY\n  )\n\n  export function flush() {\n    onChangeCodeMirrorValueDebounced.flush()\n  }\n\n  function emitOnChange(content: Content, previousContent: Content) {\n    if (onChange) {\n      onChange(content, previousContent, {\n        contentErrors: validate(),\n        patchResult: undefined\n      })\n    }\n  }\n\n  function emitOnSelect() {\n    onSelect(toTextSelection(editorState.selection))\n  }\n\n  function toTextSelection(selection: EditorSelection): TextSelection {\n    return {\n      type: SelectionType.text,\n      ...selection.toJSON()\n    }\n  }\n\n  function disableTextEditor(text: string, acceptTooLarge: boolean): boolean {\n    const tooLarge = text ? text.length > MAX_DOCUMENT_SIZE_TEXT_MODE : false\n    return tooLarge && !acceptTooLarge\n  }\n\n  let jsonStatus = JSON_STATUS_VALID\n\n  let jsonParseError: ParseError | undefined\n\n  function linterCallback(): Diagnostic[] {\n    if (disableTextEditor(text, acceptTooLarge)) {\n      return []\n    }\n\n    const contentErrors = validate()\n\n    if (isContentParseError(contentErrors)) {\n      const { parseError, isRepairable } = contentErrors\n\n      return [toDiagnostic(toRichParseError(parseError, isRepairable))]\n    }\n\n    if (isContentValidationErrors(contentErrors)) {\n      return contentErrors.validationErrors.map(toRichValidationError).map(toDiagnostic)\n    }\n\n    return []\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate:start')\n\n    flush()\n\n    const contentErrors = memoizedValidateText(\n      normalization.escapeValue(text),\n      validator,\n      parser,\n      validationParser\n    )\n\n    if (isContentParseError(contentErrors)) {\n      jsonStatus = contentErrors.isRepairable ? JSON_STATUS_REPAIRABLE : JSON_STATUS_INVALID\n      jsonParseError = contentErrors.parseError\n      validationErrors = []\n    } else {\n      jsonStatus = JSON_STATUS_VALID\n      jsonParseError = undefined\n      validationErrors = contentErrors?.validationErrors || []\n    }\n\n    debug('validate:end')\n\n    return contentErrors\n  }\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidateText = memoizeOne(validateText)\n\n  function handleShowMe() {\n    if (jsonParseError) {\n      handleSelectParseError(jsonParseError)\n    }\n  }\n\n  const repairActionShowMe = {\n    icon: faEye,\n    text: 'Show me',\n    title: 'Move to the parse error location',\n    onClick: handleShowMe\n  }\n\n  $: repairActions =\n    jsonStatus === JSON_STATUS_REPAIRABLE && !readOnly\n      ? [\n          {\n            icon: faWrench,\n            text: 'Auto repair',\n            title: 'Automatically repair JSON',\n            onClick: handleRepair\n          },\n          repairActionShowMe\n        ]\n      : [repairActionShowMe]\n</script>\n\n<div class=\"jse-text-mode\" class:no-main-menu={!mainMenuBar} bind:this={domTextMode}>\n  {#if mainMenuBar}\n    {@const isNewDocument = text.length === 0}\n\n    <TextMenu\n      {readOnly}\n      onFormat={handleFormat}\n      onCompact={handleCompact}\n      onSort={handleSort}\n      onTransform={handleTransform}\n      onToggleSearch={handleToggleSearch}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      canFormat={!isNewDocument}\n      canCompact={!isNewDocument}\n      canSort={!isNewDocument}\n      canTransform={!isNewDocument}\n      canUndo={history.canUndo}\n      canRedo={history.canRedo}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if !isSSR}\n    {@const editorDisabled = disableTextEditor(text, acceptTooLarge)}\n\n    <div class=\"jse-contents\" class:jse-hidden={editorDisabled} bind:this={codeMirrorRef}></div>\n\n    {#if editorDisabled}\n      <Message\n        icon={faExclamationTriangle}\n        type=\"error\"\n        message={`The JSON document is larger than ${formatSize(MAX_DOCUMENT_SIZE_TEXT_MODE)}, ` +\n          `and may crash your browser when loading it in text mode. Actual size: ${formatSize(text.length)}.`}\n        actions={[\n          {\n            text: 'Open anyway',\n            title: 'Open the document in text mode. This may freeze or crash your browser.',\n            onClick: handleAcceptTooLarge\n          },\n          {\n            text: 'Open in tree mode',\n            title: 'Open the document in tree mode. Tree mode can handle large documents.',\n            onClick: handleSwitchToTreeMode\n          },\n          {\n            text: 'Cancel',\n            title: 'Cancel opening this large document.',\n            onClick: cancelLoadTooLarge\n          }\n        ]}\n        onClose={focus}\n      />\n\n      <div class=\"jse-contents jse-preview\">\n        {truncate(text || '', MAX_CHARACTERS_TEXT_PREVIEW)}\n      </div>\n    {/if}\n\n    {#if !editorDisabled}\n      {#if statusBar}\n        <StatusBar {editorState} />\n      {/if}\n\n      {#if jsonParseError}\n        <Message\n          type=\"error\"\n          icon={faExclamationTriangle}\n          message={jsonParseError.message}\n          actions={repairActions}\n          onClick={handleShowMe}\n          onClose={focus}\n        />\n      {/if}\n\n      {#if !jsonParseError && askToFormatApplied && needsFormatting(text)}\n        <Message\n          type=\"success\"\n          message=\"Do you want to format the JSON?\"\n          actions={[\n            {\n              icon: faJSONEditorFormat,\n              text: 'Format',\n              title: 'Format JSON: add proper indentation and new lines (Ctrl+I)',\n              onClick: handleFormat\n            },\n            {\n              icon: faTimes,\n              text: 'No thanks',\n              title: 'Close this message',\n              onClick: () => (askToFormatApplied = false)\n            }\n          ]}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview {validationErrors} selectError={handleSelectValidationError} />\n    {/if}\n  {:else}\n    <div class=\"jse-contents\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n<style src=\"./TextMode.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { faJSONEditorCompact, faJSONEditorFormat } from '$lib/img/customFontawesomeIcons.js'\n  import Menu from '../../../controls/Menu.svelte'\n  import type { MenuItem, OnRenderMenuInternal } from '$lib/types'\n\n  export let readOnly = false\n  export let onFormat: () => boolean\n  export let onCompact: () => boolean\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onToggleSearch: () => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let canUndo: boolean\n  export let canRedo: boolean\n  export let canFormat: boolean\n  export let canCompact: boolean\n  export let canSort: boolean\n  export let canTransform: boolean\n  export let onRenderMenu: OnRenderMenuInternal\n\n  const searchItem: MenuItem = {\n    type: 'button',\n    icon: faSearch,\n    title: 'Search (Ctrl+F)',\n    className: 'jse-search',\n    onClick: onToggleSearch\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        {\n          type: 'button',\n          icon: faJSONEditorFormat,\n          title: 'Format JSON: add proper indentation and new lines (Ctrl+I)',\n          className: 'jse-format',\n          onClick: onFormat,\n          disabled: readOnly || !canFormat\n        },\n        {\n          type: 'button',\n          icon: faJSONEditorCompact,\n          title: 'Compact JSON: remove all white spacing and new lines (Ctrl+Shift+I)',\n          className: 'jse-compact',\n          onClick: onCompact,\n          disabled: readOnly || !canCompact\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || !canSort\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || !canTransform\n        },\n        searchItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        searchItem,\n        {\n          type: 'space'\n        }\n      ]\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<script lang=\"ts\">\n  import type { EditorState, Line } from '@codemirror/state'\n\n  export let editorState: EditorState | undefined\n\n  let pos: number | undefined\n  $: pos = editorState?.selection?.main?.head\n\n  let line: Line | undefined\n  $: line = pos !== undefined ? editorState?.doc?.lineAt(pos) : undefined\n\n  let lineNumber: number | undefined\n  $: lineNumber = line !== undefined ? line.number : undefined\n\n  let columnNumber: number | undefined\n  $: columnNumber = line !== undefined && pos !== undefined ? pos - line.from + 1 : undefined\n\n  let charCount: number | undefined\n  $: charCount = editorState?.selection?.ranges?.reduce((count, range) => {\n    return count + range.to - range.from\n  }, 0)\n</script>\n\n<div class=\"jse-status-bar\">\n  {#if lineNumber !== undefined}\n    <div class=\"jse-status-bar-info\">Line: {lineNumber}</div>\n  {/if}\n\n  {#if columnNumber !== undefined}\n    <div class=\"jse-status-bar-info\">Column: {columnNumber}</div>\n  {/if}\n\n  {#if charCount !== undefined && charCount > 0}\n    <div class=\"jse-status-bar-info\">Selection: {charCount} characters</div>\n  {/if}\n</div>\n\n<style src=\"./StatusBar.scss\"></style>\n","<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { getIn, isJSONArray, isJSONObject } from 'immutable-json-patch'\n  import type { JSONParser, OnChangeMode } from '$lib/types.js'\n  import { Mode } from '$lib/types.js'\n  import { valueType } from '$lib/utils/typeUtils.js'\n  import { findNestedArrays } from '$lib/logic/table.js'\n  import { isEmpty } from 'lodash-es'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n\n  interface Props {\n    text: string | undefined\n    json: unknown | undefined\n    readOnly: boolean\n    parser: JSONParser\n    openJSONEditorModal: (path: JSONPath) => void\n    extractPath: (path: JSONPath) => void\n    onChangeMode: OnChangeMode\n    onClick: () => void\n  }\n\n  const {\n    text,\n    json,\n    readOnly,\n    parser,\n    openJSONEditorModal,\n    extractPath,\n    onChangeMode,\n    onClick\n  }: Props = $props()\n\n  const nestedArrayPaths: JSONPath[] = $derived(\n    json\n      ? findNestedArrays(json)\n          .slice(0, 99)\n          .filter((path) => path.length > 0)\n      : []\n  )\n  const hasNestedArrays = $derived(!isEmpty(nestedArrayPaths))\n  const isEmptyDocument = $derived(json === undefined && (text === '' || text === undefined))\n\n  const documentType = $derived(\n    hasNestedArrays\n      ? 'Object with nested arrays'\n      : isEmptyDocument\n        ? 'An empty document'\n        : isJSONObject(json)\n          ? 'An object'\n          : isJSONArray(json)\n            ? 'An empty array' // note: can also be an array with objects but without properties\n            : `A ${valueType(json, parser)}`\n  )\n\n  function countItems(nestedArrayPath: JSONPath): number {\n    return (getIn(json, nestedArrayPath) as JSONPath).length\n  }\n</script>\n\n<div class=\"jse-table-mode-welcome\" onclick={() => onClick()} role=\"none\">\n  <div class=\"jse-space jse-before\"></div>\n\n  <div class=\"jse-nested-arrays\">\n    <div class=\"jse-nested-arrays-title\">{documentType}</div>\n    <div class=\"jse-nested-arrays-info\">\n      {#if hasNestedArrays}\n        An object cannot be opened in table mode. You can open a nested array instead, or open the\n        document in tree mode.\n      {:else if isEmptyDocument && !readOnly}\n        An empty document cannot be opened in table mode. You can go to tree mode instead, or paste\n        a JSON Array using <b>Ctrl+V</b>.\n      {:else}\n        {documentType} cannot be opened in table mode. You can open the document in tree mode instead.\n      {/if}\n    </div>\n    {#each nestedArrayPaths as nestedArrayPath}\n      {@const count = countItems(nestedArrayPath)}\n\n      <div class=\"jse-nested-property\">\n        <div class=\"jse-nested-property-path\">\n          \"{stringifyJSONPath(nestedArrayPath)}\"\n          <span class=\"jse-nested-property-count\">({count} {count !== 1 ? 'items' : 'item'})</span>\n        </div>\n\n        <button\n          type=\"button\"\n          class=\"jse-nested-array-action\"\n          onclick={() => openJSONEditorModal(nestedArrayPath)}\n        >\n          {readOnly ? 'View' : 'Edit'}\n        </button>\n        {#if !readOnly}\n          <button\n            type=\"button\"\n            class=\"jse-nested-array-action\"\n            onclick={() => extractPath(nestedArrayPath)}\n          >\n            Extract\n          </button>\n        {/if}\n      </div>\n    {/each}\n    <button type=\"button\" class=\"jse-nested-array-action\" onclick={() => onChangeMode(Mode.tree)}>\n      Switch to tree mode\n    </button>\n  </div>\n\n  <div class=\"jse-space jse-after\"></div>\n</div>\n\n<style src=\"./TableModeWelcome.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type {\n    AbsolutePopupContext,\n    AbsolutePopupOptions,\n    AfterPatchCallback,\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    DocumentState,\n    History,\n    HistoryItem,\n    JSONEditorContext,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONRepairModalProps,\n    JSONSelection,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRedo,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    OnUndo,\n    ParseError,\n    PastedJson,\n    ScrollToOptions,\n    SearchResultDetails,\n    SearchResults,\n    SortedColumn,\n    TransformModalOptions,\n    ValidationError,\n    Validator,\n    ValueNormalization\n  } from '$lib/types'\n  import { Mode, SortDirection, ValidationSeverity } from '$lib/types.js'\n  import TableMenu from './menu/TableMenu.svelte'\n  import {\n    compileJSONPointer,\n    existsIn,\n    getIn,\n    immutableJSONPatch,\n    isJSONArray,\n    type JSONPatchDocument,\n    type JSONPath\n  } from 'immutable-json-patch'\n  import {\n    isTextContent,\n    normalizeJsonParseError,\n    parseAndRepair,\n    parsePartialJson,\n    repairPartialJson\n  } from '../../../utils/jsonUtils.js'\n  import {\n    calculateAbsolutePosition,\n    calculateVisibleSection,\n    clearSortedColumnWhenAffectedByOperations,\n    getColumns,\n    groupValidationErrors,\n    maintainColumnOrder,\n    mergeValidationErrors,\n    selectNextColumn,\n    selectNextRow,\n    selectPreviousColumn,\n    selectPreviousRow,\n    toTableCellPosition\n  } from '$lib/logic/table.js'\n  import { isEmpty, isEqual, uniqueId } from 'lodash-es'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    encodeDataPath,\n    findParentWithNodeName,\n    getDataPathFromTarget,\n    getWindow,\n    isChildOf\n  } from '$lib/utils/domUtils.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import {\n    createDocumentState,\n    documentStatePatch,\n    getEnforceString,\n    getInRecursiveState,\n    setInDocumentState,\n    syncDocumentState\n  } from '$lib/logic/documentState.js'\n  import { isObjectOrArray, isUrl, stringConvert } from '$lib/utils/typeUtils.js'\n  import InlineValue from './tag/InlineValue.svelte'\n  import {\n    createNestedValueOperations,\n    extract,\n    revertJSONPatchWithMoveOperations\n  } from '$lib/logic/operations.js'\n  import {\n    createValueSelection,\n    getAnchorPath,\n    getFocusPath,\n    isEditingSelection,\n    isJSONSelection,\n    isValueSelection,\n    pathInSelection,\n    pathStartsWith,\n    removeEditModeFromSelection\n  } from '$lib/logic/selection.js'\n  import ColumnHeader from './ColumnHeader.svelte'\n  import { sortJson } from '$lib/logic/sort.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createFocusTracker } from '$lib/components/controls/createFocusTracker.js'\n  import { flushSync, getContext, onDestroy, onMount } from 'svelte'\n  import { jsonrepair } from 'jsonrepair'\n  import Message from '../../controls/Message.svelte'\n  import { faCheck, faCode, faWrench } from '@fortawesome/free-solid-svg-icons'\n  import { measure } from '$lib/utils/timeUtils.js'\n  import memoizeOne from 'memoize-one'\n  import { validateJSON } from '$lib/logic/validation.js'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import {\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH,\n    SCROLL_DURATION,\n    SEARCH_BOX_HEIGHT\n  } from '$lib/constants.js'\n  import { noop } from '$lib/utils/noop.js'\n  import { createJump } from '$lib/assets/jump.js/src/jump.js'\n  import ValidationErrorIcon from '../treemode/ValidationErrorIcon.svelte'\n  import {\n    onCopy,\n    onCut,\n    onDuplicateRow,\n    onInsertAfterRow,\n    onInsertBeforeRow,\n    onInsertCharacter,\n    onPaste,\n    onRemove,\n    onRemoveRow\n  } from '$lib/logic/actions.js'\n  import JSONRepairModal from '../../modals/JSONRepairModal.svelte'\n  import { resizeObserver } from '$lib/actions/resizeObserver.js'\n  import CopyPasteModal from '../../../components/modals/CopyPasteModal.svelte'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n  import SearchBox from '../../controls/SearchBox.svelte'\n  import TableModeWelcome from './TableModeWelcome.svelte'\n  import JSONPreview from '../../controls/JSONPreview.svelte'\n  import RefreshColumnHeader from './RefreshColumnHeader.svelte'\n  import createTableContextMenuItems from './contextmenu/createTableContextMenuItems'\n  import ContextMenu from '../../controls/contextmenu/ContextMenu.svelte'\n  import { flattenSearchResults, toRecursiveSearchResults } from '$lib/logic/search.js'\n  import JSONValue from '../treemode/JSONValue.svelte'\n  import { isTreeHistoryItem } from 'svelte-jsoneditor'\n\n  const debug = createDebug('jsoneditor:TableMode')\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n  const jump = createJump()\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  export let readOnly: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let history: History<HistoryItem>\n  export let truncateTextSize: number\n  export let mainMenuBar: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let indentation: number | string\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onUndo: OnUndo\n  export let onRedo: OnRedo\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  let normalization: ValueNormalization\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters,\n    escapeUnicodeCharacters\n  })\n\n  let refJsonEditor: HTMLDivElement\n  let refContents: HTMLDivElement | undefined\n  let refHiddenInput: HTMLInputElement\n\n  let jsonRepairModalProps: JSONRepairModalProps | undefined = undefined\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(refJsonEditor),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(refJsonEditor),\n    onFocus: () => {\n      hasFocus = true\n      if (onFocus) {\n        onFocus()\n      }\n    },\n    onBlur: () => {\n      hasFocus = false\n      if (onBlur) {\n        onBlur()\n      }\n    }\n  })\n\n  let json: unknown | undefined\n  let text: string | undefined\n  let parseError: ParseError | undefined = undefined\n\n  let pastedJson: PastedJson | undefined\n\n  let searchResultDetails: SearchResultDetails | undefined\n  let searchResults: SearchResults | undefined\n  let showSearch = false\n  let showReplace = false\n\n  $: applySearchBoxSpacing(showSearch)\n\n  function applySearchBoxSpacing(showSearch: boolean) {\n    if (!refContents) {\n      return\n    }\n\n    const offset = showSearch ? SEARCH_BOX_HEIGHT : -SEARCH_BOX_HEIGHT\n    refContents.scrollTo({\n      top: (refContents.scrollTop += offset),\n      left: refContents.scrollLeft\n    })\n  }\n\n  function handleSearch(result: SearchResultDetails | undefined) {\n    searchResultDetails = result\n    searchResults = searchResultDetails\n      ? toRecursiveSearchResults(json, searchResultDetails.items)\n      : undefined\n  }\n\n  async function handleFocusSearch(path: JSONPath) {\n    selection = undefined // navigation path of current selection would be confusing\n    await scrollTo(path)\n  }\n\n  function handleCloseSearch() {\n    showSearch = false\n    showReplace = false\n    focus()\n  }\n\n  $: applyExternalContent(externalContent)\n  $: applyExternalSelection(externalSelection)\n\n  let maxSampleCount = 10_000\n  let columns: JSONPath[] = []\n  $: columns = isJSONArray(json)\n    ? maintainColumnOrder(getColumns(json, flattenColumns, maxSampleCount), columns)\n    : []\n\n  let containsValidArray: boolean\n  $: containsValidArray = !!(json && !isEmpty(columns))\n  $: showRefreshButton = Array.isArray(json) && json.length > maxSampleCount\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n\n  let hasFocus = false\n  let copyPasteModalOpen = false\n\n  let itemHeightsCache: Record<number, number> = {}\n\n  let viewPortHeight = 600\n  let scrollTop = 0\n  let defaultItemHeight = 18 // px\n\n  $: visibleSection = calculateVisibleSection(\n    scrollTop,\n    viewPortHeight,\n    json,\n    itemHeightsCache, // warning: itemHeightsCache is mutated and is not responsive itself\n    defaultItemHeight,\n    showSearch ? SEARCH_BOX_HEIGHT : 0\n  )\n\n  $: refreshScrollTop(json)\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function refreshScrollTop(_json: unknown | undefined) {\n    // When the contents go from lots of items and scrollable contents to only a few items and\n    // no vertical scroll, the actual scrollTop changes to 0 but there is no on:scroll event\n    // triggered, so the internal scrollTop variable is not up-to-date.\n    // This is a workaround to update the scrollTop by triggering an on:scroll event\n    if (refContents) {\n      refContents.scrollTo({\n        top: refContents.scrollTop,\n        left: refContents.scrollLeft\n      })\n    }\n  }\n\n  function handleSelect(updatedSelection: JSONSelection | undefined) {\n    selection = updatedSelection\n  }\n\n  function emitOnSelect(updatedSelection: JSONSelection | undefined) {\n    if (!isEqual(updatedSelection, externalSelection)) {\n      debug('onSelect', updatedSelection)\n      onSelect(updatedSelection)\n    }\n  }\n\n  $: emitOnSelect(selection)\n\n  function clearSelectionWhenNotExisting(json: unknown | undefined) {\n    if (!selection || json === undefined) {\n      return\n    }\n\n    if (existsIn(json, getAnchorPath(selection)) && existsIn(json, getFocusPath(selection))) {\n      return\n    }\n\n    debug('clearing selection: path does not exist anymore', selection)\n    selection = undefined // TODO: try find the closest cell that still exists (similar to getInitialSelection)\n  }\n\n  let documentState: DocumentState | undefined =\n    json !== undefined ? createDocumentState({ json }) : undefined\n  let selection: JSONSelection | undefined = isJSONSelection(externalSelection)\n    ? externalSelection\n    : undefined\n  let sortedColumn: SortedColumn | undefined\n  let textIsRepaired = false\n\n  onMount(() => {\n    if (selection) {\n      scrollIntoView(getFocusPath(selection))\n    }\n  })\n\n  function onSortByHeader(newSortedColumn: SortedColumn) {\n    if (readOnly) {\n      return\n    }\n\n    debug('onSortByHeader', newSortedColumn)\n\n    const rootPath: JSONPath = []\n    const direction = newSortedColumn.sortDirection === SortDirection.desc ? -1 : 1\n    const operations = sortJson(json, rootPath, newSortedColumn.path, direction)\n    handlePatch(operations, (_, patchedState) => {\n      return {\n        state: patchedState,\n        sortedColumn: newSortedColumn\n      }\n    })\n  }\n\n  let context: JSONEditorContext\n  $: context = {\n    mode: Mode.table,\n    readOnly,\n    truncateTextSize,\n    parser,\n    normalization,\n    getJson: () => json,\n    getDocumentState: () => documentState,\n    findElement,\n    findNextInside,\n    focus,\n    onPatch: (operations, afterPatch) => {\n      // When having flattened table columns and having inserted a new row, it is possible that\n      // we edit a nested value of which the parent object is not existing. Therefore, we call\n      // replaceNestedValue to create the parent object(s) first.\n      return handlePatch(createNestedValueOperations(operations, json), afterPatch)\n    },\n    onSelect: handleSelect,\n    onFind: openFind,\n    onPasteJson: handlePasteJson,\n    onRenderValue\n  }\n\n  function applyExternalContent(content: Content) {\n    const currentContent = { json }\n    const isChanged = isTextContent(content)\n      ? content.text !== text\n      : !isEqual(currentContent.json, content.json)\n\n    debug('update external content', { isChanged })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    if (isTextContent(content)) {\n      try {\n        json = parseMemoizeOne(content.text)\n        documentState = syncDocumentState(json, documentState)\n        text = content.text\n        textIsRepaired = false\n        parseError = undefined\n      } catch (err) {\n        try {\n          json = parseMemoizeOne(jsonrepair(content.text))\n          documentState = syncDocumentState(json, documentState)\n          text = content.text\n          textIsRepaired = true\n          parseError = undefined\n        } catch {\n          // no valid JSON, will show empty document or invalid json\n          json = undefined\n          documentState = undefined\n          text = content.text\n          textIsRepaired = false\n          parseError =\n            text !== ''\n              ? normalizeJsonParseError(text, (err as Error).message || String(err))\n              : undefined\n        }\n      }\n    } else {\n      json = content.json\n      documentState = syncDocumentState(json, documentState)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    }\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    // reset the sorting order (we don't know...)\n    sortedColumn = undefined\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (isEqual(selection, externalSelection)) {\n      return\n    }\n\n    debug('applyExternalSelection', { selection, externalSelection })\n\n    if (isJSONSelection(externalSelection)) {\n      selection = externalSelection\n    }\n  }\n\n  interface PreviousState {\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    textIsRepaired: boolean\n    sortedColumn: SortedColumn | undefined\n  }\n\n  function addHistoryItem(previous: PreviousState) {\n    if (previous.json === undefined && previous.text === undefined) {\n      // initialization -> do not create a history item\n      return\n    }\n\n    const canPatch = json !== undefined && previous.json !== undefined\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: previous.json }] : undefined,\n        json: previous.json,\n        text: previous.text,\n        documentState: previous.documentState,\n        textIsRepaired: previous.textIsRepaired,\n        selection: removeEditModeFromSelection(previous.selection),\n        sortedColumn: previous.sortedColumn\n      },\n      redo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: json }] : undefined,\n        json,\n        text,\n        documentState,\n        textIsRepaired,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn\n      }\n    })\n  }\n\n  let validationErrors: ValidationError[] = []\n  $: updateValidationErrors(json, validator, parser, validationParser)\n  $: groupedValidationErrors = groupValidationErrors(validationErrors, columns)\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidate = memoizeOne(validateJSON)\n\n  function updateValidationErrors(\n    json: unknown,\n    validator: Validator | undefined,\n    parser: JSONParser,\n    validationParser: JSONParser\n  ) {\n    measure(\n      () => {\n        let newValidationErrors: ValidationError[]\n        try {\n          newValidationErrors = memoizedValidate(json, validator, parser, validationParser)\n        } catch (err) {\n          newValidationErrors = [\n            {\n              path: [],\n              message: 'Failed to validate: ' + (err as Error).message,\n              severity: ValidationSeverity.warning\n            }\n          ]\n        }\n\n        if (!isEqual(newValidationErrors, validationErrors)) {\n          debug('validationErrors changed:', newValidationErrors)\n          validationErrors = newValidationErrors\n        }\n      },\n      (duration) => debug(`validationErrors updated in ${duration} ms`)\n    )\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate')\n\n    if (parseError) {\n      return {\n        parseError,\n        isRepairable: false // not applicable, if repairable, we will not have a parseError\n      }\n    }\n\n    // make sure the validation results are up-to-date\n    // normally, they are only updated on the next tick after the json is changed\n    updateValidationErrors(json, validator, parser, validationParser)\n    return !isEmpty(validationErrors) ? { validationErrors } : undefined\n  }\n\n  export function patch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('patch', operations, afterPatch)\n\n    if (json === undefined) {\n      throw new Error('Cannot apply patch: no JSON')\n    }\n\n    const previousJson = json\n    const previousState: PreviousState = {\n      json: undefined, // not needed: we use patch to reconstruct the json\n      text,\n      documentState,\n      selection: removeEditModeFromSelection(selection),\n      sortedColumn,\n      textIsRepaired\n    }\n\n    // execute the patch operations\n    const undo: JSONPatchDocument = revertJSONPatchWithMoveOperations(\n      json,\n      operations\n    ) as JSONPatchDocument\n    const patched = documentStatePatch(json, documentState, operations)\n\n    // Clear the sorted column when needed. We need to do this before `afterPatch`,\n    // else we clear any changed made in the callback. It is a bit odd that\n    // afterPatch does not receive the actual previousDocumentState. Better ideas?\n    const patchedSortedColumn = clearSortedColumnWhenAffectedByOperations(\n      sortedColumn,\n      operations,\n      columns\n    )\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(patched.json, patched.documentState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : patched.json\n    documentState = callback?.state !== undefined ? callback.state : patched.documentState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    sortedColumn =\n      callback?.sortedColumn !== undefined ? callback.sortedColumn : patchedSortedColumn\n    text = undefined\n    textIsRepaired = false\n    pastedJson = undefined\n    parseError = undefined\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: undo,\n        ...previousState\n      },\n      redo: {\n        patch: operations,\n        json: undefined, // not needed: we use patch to reconstruct the json\n        text: undefined,\n        documentState,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn,\n        textIsRepaired\n      }\n    })\n\n    return {\n      json,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handlePatch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('handlePatch', operations, afterPatch)\n\n    const previousContent = { json, text }\n    const patchResult = patch(operations, afterPatch)\n\n    emitOnChange(previousContent, patchResult)\n\n    return patchResult\n  }\n\n  function emitOnChange(previousContent: Content, patchResult: JSONPatchResult | undefined) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (previousContent.json === undefined && previousContent?.text === undefined) {\n      // initialization -> do not fire an onChange event\n      return\n    }\n\n    // make sure we cannot send an invalid contents like having both\n    // json and text defined, or having none defined\n    if (onChange) {\n      if (text !== undefined) {\n        const content = { text, json: undefined }\n        onChange(content, previousContent, {\n          contentErrors: validate(),\n          patchResult\n        })\n      } else if (json !== undefined) {\n        const content = { text: undefined, json }\n        onChange(content, previousContent, {\n          contentErrors: validate(),\n          patchResult\n        })\n      }\n    }\n  }\n\n  function handlePasteJson(newPastedJson: PastedJson) {\n    debug('pasted json as text', newPastedJson)\n\n    pastedJson = newPastedJson\n  }\n\n  function findNextInside(path: JSONPath): JSONSelection {\n    const index = parseInt(path[0], 10)\n    const nextPath = [String(index + 1), ...path.slice(1)]\n\n    return existsIn(json, nextPath) ? createValueSelection(nextPath) : createValueSelection(path)\n  }\n\n  export function focus() {\n    debug('focus')\n    // with just .focus(), sometimes the input doesn't react on onpaste events\n    // in Chrome when having a large document open and then doing cut/paste.\n    // Calling both .focus() and .select() did solve this issue.\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n      refHiddenInput.select()\n    }\n  }\n\n  function handleWindowMouseDown(event: MouseEvent & { currentTarget: EventTarget & Window }) {\n    const outsideEditor = !isChildOf(\n      event.target as Element,\n      (element) => element === refJsonEditor\n    )\n    if (outsideEditor) {\n      if (isEditingSelection(selection)) {\n        debug('click outside the editor, exit edit mode')\n        selection = removeEditModeFromSelection(selection)\n\n        if (hasFocus && refHiddenInput) {\n          refHiddenInput.focus()\n          refHiddenInput.blur()\n        }\n\n        debug('blur (outside editor)')\n        if (refHiddenInput) {\n          refHiddenInput.blur()\n        }\n      }\n    }\n  }\n\n  function handleScroll(event: Event) {\n    scrollTop = (event.target as HTMLElement)['scrollTop']\n  }\n\n  function handleMouseDown(event: MouseEvent) {\n    // only handle when the left or right mouse button is pressed, not the middle mouse button (scroll wheel)\n    if (event.buttons !== 1 && event.buttons !== 2) {\n      return\n    }\n\n    const target = event.target as HTMLElement\n    if (!target.isContentEditable) {\n      focus()\n    }\n\n    const path = getDataPathFromTarget(target)\n    if (path) {\n      // when clicking inside the current selection, editing a value, do nothing\n      if (isEditingSelection(selection) && pathInSelection(json, selection, path)) {\n        return\n      }\n\n      selection = createValueSelection(path)\n\n      event.preventDefault()\n    }\n  }\n\n  function createDefaultSelection(): JSONSelection | undefined {\n    if (isJSONArray(json) && !isEmpty(json) && !isEmpty(columns)) {\n      // Select the first row, first column\n      const path = ['0', ...columns[0]]\n\n      return createValueSelection(path)\n    } else {\n      return undefined\n    }\n  }\n\n  function createDefaultSelectionWhenUndefined() {\n    if (!selection) {\n      selection = createDefaultSelection()\n    }\n  }\n\n  export function acceptAutoRepair() {\n    if (textIsRepaired && json !== undefined) {\n      const previousContent = { json, text }\n      const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n      // json stays as is\n      text = undefined\n      textIsRepaired = false\n\n      clearSelectionWhenNotExisting(json)\n\n      addHistoryItem(previousState)\n\n      // we could work out a patchResult, or use patch(), but only when the previous and new\n      // contents are both json and not text. We go for simplicity and consistency here and\n      // do _not_ return a patchResult ever.\n      const patchResult = undefined\n\n      emitOnChange(previousContent, patchResult)\n    }\n\n    return { json, text }\n  }\n\n  /**\n   * Scroll the window vertically to the node with given path.\n   * Expand the path when needed.\n   */\n  export function scrollTo(\n    path: JSONPath,\n    { scrollToWhenVisible = true }: ScrollToOptions = {}\n  ): Promise<void> {\n    const searchBoxHeight = showSearch ? SEARCH_BOX_HEIGHT : 0\n    const top = calculateAbsolutePosition(path, columns, itemHeightsCache, defaultItemHeight)\n    const roughDistance = top - scrollTop + searchBoxHeight + defaultItemHeight\n    const elem = findElement(path)\n\n    debug('scrollTo', { path, top, scrollTop, elem })\n\n    if (!refContents) {\n      return Promise.resolve()\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    if (elem && !scrollToWhenVisible) {\n      const elemRect = elem.getBoundingClientRect()\n      if (elemRect.bottom > viewPortRect.top && elemRect.top < viewPortRect.bottom) {\n        // element is fully or partially visible, don't scroll to it\n        return Promise.resolve()\n      }\n    }\n\n    const offset = -Math.max(searchBoxHeight + 2 * defaultItemHeight, viewPortRect.height / 4)\n\n    if (elem) {\n      return new Promise((resolve) => {\n        jump(elem, {\n          container: refContents,\n          offset,\n          duration: SCROLL_DURATION,\n          callback: () => {\n            // TODO: improve horizontal scrolling: animate and integrate with the vertical scrolling (jump)\n            scrollToHorizontal(path)\n            resolve()\n          }\n        })\n      })\n    } else {\n      return new Promise((resolve) => {\n        jump(roughDistance, {\n          container: refContents,\n          offset,\n          duration: SCROLL_DURATION,\n          callback: () => {\n            // ensure the element is rendered now that it is scrolled into view\n            flushSync()\n\n            // TODO: improve horizontal scrolling: animate and integrate with the vertical scrolling (jump)\n            scrollToHorizontal(path)\n            resolve()\n          }\n        })\n      })\n    }\n  }\n\n  function scrollToVertical(path: JSONPath) {\n    if (!refContents) {\n      return\n    }\n\n    const { rowIndex } = toTableCellPosition(path, columns)\n    const top = calculateAbsolutePosition(path, columns, itemHeightsCache, defaultItemHeight)\n    const bottom = top + (itemHeightsCache[rowIndex] || defaultItemHeight)\n\n    const headerHeight = defaultItemHeight\n    const viewPortRect = refContents.getBoundingClientRect()\n    const viewPortTop = scrollTop\n    const viewPortBottom = scrollTop + viewPortRect.height - headerHeight\n\n    if (bottom > viewPortBottom) {\n      const diff = bottom - viewPortBottom\n      refContents.scrollTop += diff\n    }\n\n    if (top < viewPortTop) {\n      const diff = viewPortTop - top\n      refContents.scrollTop -= diff\n    }\n  }\n\n  function scrollToHorizontal(path: JSONPath) {\n    const elem = findElement(path)\n    if (!elem || !refContents) {\n      return\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect() // TODO: scroll to column instead of item (is always rendered)\n\n    if (elemRect.right > viewPortRect.right) {\n      const diff = elemRect.right - viewPortRect.right\n      refContents.scrollLeft += diff\n    }\n\n    if (elemRect.left < viewPortRect.left) {\n      const diff = viewPortRect.left - elemRect.left\n      refContents.scrollLeft -= diff\n    }\n  }\n\n  function scrollIntoView(path: JSONPath) {\n    scrollToVertical(path)\n    scrollToHorizontal(path)\n  }\n\n  /**\n   * Find the DOM element of a given path.\n   * Note that the path can only be found when the node is expanded.\n   */\n  export function findElement(path: JSONPath): Element | undefined {\n    const column = columns.find((c) => pathStartsWith(path.slice(1), c))\n\n    const resolvedPath = column ? path.slice(0, 1).concat(column) : path\n\n    return (\n      refContents?.querySelector(`td[data-path=\"${encodeDataPath(resolvedPath)}\"]`) ?? undefined\n    )\n  }\n\n  function openContextMenu({\n    anchor,\n    left,\n    top,\n    width,\n    height,\n    offsetTop,\n    offsetLeft,\n    showTip\n  }: AbsolutePopupOptions) {\n    const defaultItems: ContextMenuItem[] = createTableContextMenuItems({\n      json,\n      documentState,\n      selection,\n      readOnly,\n\n      onEditValue: handleEditValue,\n      onEditRow: handleEditRow,\n      onToggleEnforceString: handleToggleEnforceString,\n\n      onCut: handleCut,\n      onCopy: handleCopy,\n      onPaste: handlePasteFromMenu,\n\n      onRemove: handleRemove,\n      onDuplicateRow: handleDuplicateRow,\n      onInsertBeforeRow: handleInsertBeforeRow,\n      onInsertAfterRow: handleInsertAfterRow,\n      onRemoveRow: handleRemoveRow\n    })\n\n    const items = onRenderContextMenu(defaultItems) ?? defaultItems\n\n    if (items === false) {\n      return\n    }\n\n    const props = {\n      tip: showTip\n        ? 'Tip: you can open this context menu via right-click or with Ctrl+Q'\n        : undefined,\n      items,\n      onRequestClose: function () {\n        closeAbsolutePopup(popupId)\n        focus()\n      }\n    }\n\n    const options = {\n      left,\n      top,\n      offsetTop,\n      offsetLeft,\n      width,\n      height,\n      anchor,\n      closeOnOuterClick: true,\n      onClose: () => {\n        modalOpen = false\n        focus()\n      }\n    }\n\n    modalOpen = true\n\n    const popupId = openAbsolutePopup(ContextMenu, props, options)\n  }\n\n  function handleContextMenu(event: Event) {\n    if (isEditingSelection(selection)) {\n      return\n    }\n\n    if (event) {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n\n    if (event && event.type === 'contextmenu' && event.target !== refHiddenInput) {\n      // right mouse click to open context menu\n      openContextMenu({\n        left: (event as MouseEvent).clientX,\n        top: (event as MouseEvent).clientY,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        showTip: false\n      })\n    } else {\n      // type === 'keydown' (from the quick key Ctrl+Q)\n      // or target is hidden input -> context menu button on keyboard\n      const anchor = refContents?.querySelector('.jse-table-cell.jse-selected-value')\n      if (anchor) {\n        openContextMenu({\n          anchor,\n          offsetTop: 2,\n          width: CONTEXT_MENU_WIDTH,\n          height: CONTEXT_MENU_HEIGHT,\n          showTip: false\n        })\n      } else {\n        // fallback on just displaying the TreeContextMenu top left\n        const rect = refContents?.getBoundingClientRect()\n        if (rect) {\n          openContextMenu({\n            top: rect.top + 2,\n            left: rect.left + 2,\n            width: CONTEXT_MENU_WIDTH,\n            height: CONTEXT_MENU_HEIGHT,\n            showTip: false\n          })\n        }\n      }\n    }\n  }\n\n  function handleContextMenuFromTableMenu(event: MouseEvent) {\n    openContextMenu({\n      anchor: findParentWithNodeName(event.target as HTMLElement, 'BUTTON'),\n      offsetTop: 0,\n      width: CONTEXT_MENU_WIDTH,\n      height: CONTEXT_MENU_HEIGHT,\n      showTip: true\n    })\n  }\n\n  function handleEditValue() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const value = getIn(json, path)\n    if (isObjectOrArray(value)) {\n      openJSONEditorModal(path)\n    } else {\n      selection = createValueSelection(path)\n    }\n  }\n\n  function handleEditRow() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const pathRow = path.slice(0, 1)\n    openJSONEditorModal(pathRow)\n  }\n\n  function handleToggleEnforceString() {\n    if (readOnly || !isValueSelection(selection)) {\n      return\n    }\n\n    const path = selection.path\n    const pointer = compileJSONPointer(path)\n    const value = getIn(json, path)\n    const enforceString = !getEnforceString(json, documentState, path)\n    const updatedValue = enforceString ? String(value) : stringConvert(String(value), parser)\n\n    debug('handleToggleEnforceString', { enforceString, value, updatedValue })\n\n    handlePatch(\n      [\n        {\n          op: 'replace',\n          path: pointer,\n          value: updatedValue\n        }\n      ],\n      (_, patchedState) => {\n        return {\n          state: setInDocumentState(json, patchedState, path, { type: 'value', enforceString })\n        }\n      }\n    )\n  }\n\n  async function handleParsePastedJson() {\n    debug('apply pasted json', pastedJson)\n    if (!pastedJson) {\n      return\n    }\n\n    const { onPasteAsJson } = pastedJson\n    onPasteAsJson()\n\n    // TODO: get rid of the setTimeout here\n    setTimeout(focus)\n  }\n\n  async function handlePasteFromMenu() {\n    try {\n      const clipboardText = await navigator.clipboard.readText()\n\n      _paste(clipboardText)\n    } catch (err) {\n      console.error(err)\n\n      copyPasteModalOpen = true\n    }\n  }\n\n  function handleClearPastedJson() {\n    debug('clear pasted json')\n    pastedJson = undefined\n    focus()\n  }\n\n  function handleRequestRepair() {\n    onChangeMode(Mode.text)\n  }\n\n  async function handleCut(indent: boolean) {\n    await onCut({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      readOnly,\n      parser,\n      onPatch: handlePatch\n    })\n  }\n\n  async function handleCopy(indent = true) {\n    if (json === undefined) {\n      return\n    }\n\n    await onCopy({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      parser\n    })\n  }\n\n  function handleRemove() {\n    onRemove({\n      json,\n      text,\n      selection,\n      keepSelection: true,\n      readOnly,\n      onChange,\n      onPatch: handlePatch\n    })\n  }\n\n  function handleExtract(path: JSONPath) {\n    if (readOnly) {\n      return\n    }\n\n    debug('extract', { path })\n\n    const operations = extract(json, createValueSelection(path))\n\n    handlePatch(operations)\n  }\n\n  function handleDuplicateRow() {\n    onDuplicateRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleInsertBeforeRow() {\n    onInsertBeforeRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleInsertAfterRow() {\n    onInsertAfterRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleRemoveRow() {\n    onRemoveRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  async function handleInsertCharacter(char: string) {\n    await onInsertCharacter({\n      char,\n      selectInside: false,\n      json,\n      selection: selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson,\n      onSelect: handleSelect\n    })\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    debug('keydown', { combo, key: event.key })\n\n    if (combo === 'Ctrl+X') {\n      // cut formatted\n      event.preventDefault()\n      handleCut(true)\n    }\n    if (combo === 'Ctrl+Shift+X') {\n      // cut compact\n      event.preventDefault()\n      handleCut(false)\n    }\n    if (combo === 'Ctrl+C') {\n      // copy formatted\n      event.preventDefault()\n      handleCopy(true)\n    }\n    if (combo === 'Ctrl+Shift+C') {\n      // copy compact\n      event.preventDefault()\n      handleCopy(false)\n    }\n    // Note: Ctrl+V (paste) is handled by the on:paste event\n\n    if (combo === 'Ctrl+D') {\n      event.preventDefault()\n      handleDuplicateRow()\n    }\n    if (combo === 'Delete' || combo === 'Backspace') {\n      event.preventDefault()\n      handleRemove()\n    }\n    if (combo === 'Insert') {\n      event.preventDefault()\n      // TODO: implement insert\n    }\n    if (combo === 'Ctrl+A') {\n      event.preventDefault()\n      // selection = selectAll()\n      // TODO: implement select all\n    }\n\n    if (combo === 'Ctrl+Q') {\n      handleContextMenu(event)\n    }\n\n    if (combo === 'ArrowLeft') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectPreviousColumn(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowRight') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectNextColumn(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowUp') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectPreviousRow(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowDown') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectNextRow(json, columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'Enter' && selection) {\n      if (isValueSelection(selection)) {\n        event.preventDefault()\n\n        const path = selection.path\n        const value = getIn(json, path)\n        if (isObjectOrArray(value)) {\n          // edit nested object/array\n          openJSONEditorModal(path)\n        } else {\n          if (!readOnly) {\n            // go to value edit mode\n            selection = { ...selection, edit: true }\n          }\n        }\n      }\n    }\n\n    const normalizedCombo = combo.replace(/^Shift\\+/, '') // replace 'Shift+A' with 'A'\n    if (normalizedCombo.length === 1 && selection) {\n      // a regular key like a, A, _, etc is entered.\n      // Replace selected contents with a new value having this first character as text\n      event.preventDefault()\n      handleInsertCharacter(event.key)\n      return\n    }\n\n    if (combo === 'Ctrl+Enter' && isValueSelection(selection)) {\n      event.preventDefault()\n\n      const value = getIn(json, selection.path)\n\n      if (isUrl(value)) {\n        // open url in new page\n        window.open(String(value), '_blank')\n      }\n    }\n\n    if (combo === 'Escape' && selection) {\n      event.preventDefault()\n      selection = undefined\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      openFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      openFind(true)\n    }\n\n    if (combo === 'Ctrl+Z') {\n      event.preventDefault()\n\n      handleUndo()\n    }\n\n    if (combo === 'Ctrl+Shift+Z') {\n      event.preventDefault()\n\n      handleRedo()\n    }\n  }\n\n  function handlePaste(event: ClipboardEvent) {\n    event.preventDefault()\n\n    const clipboardText = event.clipboardData?.getData('text/plain')\n\n    _paste(clipboardText)\n  }\n\n  function _paste(clipboardText: string | undefined) {\n    if (clipboardText === undefined) {\n      return\n    }\n\n    onPaste({\n      clipboardText,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onChangeText: handleChangeText,\n      openRepairModal\n    })\n  }\n\n  // TODO: this function is duplicated from TreeMode. See if we can reuse the code instead\n  function handleReplaceJson(updatedJson: unknown, afterPatch?: AfterPatchCallback) {\n    const previousContent = { json, text }\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    const updatedState = syncDocumentState(updatedJson, documentState)\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(updatedJson, updatedState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : updatedJson\n    documentState = callback?.state !== undefined ? callback.state : updatedState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    sortedColumn = undefined // we can't know whether the new json is still sorted or not\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // we could work out a patchResult, or use patch(), but only when the previous and new\n    // contents are both json and not text. We go for simplicity and consistency here and\n    // do _not_ return a patchResult ever.\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  // TODO: this function is duplicated from TreeMode. See if we can reuse the code instead\n  function handleChangeText(updatedText: string, afterPatch?: AfterPatchCallback) {\n    debug('handleChangeText')\n\n    const previousContent = { json, text }\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = syncDocumentState(json, documentState)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = syncDocumentState(json, documentState)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = undefined\n        text = updatedText\n        textIsRepaired = false\n        parseError =\n          text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    if (typeof afterPatch === 'function') {\n      const callback = afterPatch(json, documentState, selection)\n\n      json = callback?.json !== undefined ? callback.json : json\n      documentState = callback?.state !== undefined ? callback.state : documentState\n      selection = callback?.selection !== undefined ? callback.selection : selection\n    }\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // no JSON patch actions available in text mode\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  function handleSelectValidationError(error: ValidationError) {\n    debug('select validation error', error)\n\n    selection = createValueSelection(error.path)\n\n    scrollTo(error.path)\n  }\n\n  function openSortModal(rootPath: JSONPath) {\n    if (readOnly || json === undefined) {\n      return\n    }\n\n    modalOpen = true\n\n    onSortModal({\n      id: sortModalId,\n      json,\n      rootPath,\n      onSort: ({ operations, itemPath, direction }) => {\n        debug('onSort', operations, rootPath, itemPath, direction)\n\n        handlePatch(operations, (_, patchedState) => {\n          return {\n            state: patchedState,\n            sortedColumn: {\n              path: itemPath,\n              sortDirection: direction === -1 ? SortDirection.desc : SortDirection.asc\n            }\n          }\n        })\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal(options: TransformModalOptions) {\n    if (json === undefined) {\n      return\n    }\n\n    const { id, onTransform, onClose } = options\n    const rootPath = options.rootPath || []\n\n    modalOpen = true\n\n    onTransformModal({\n      id: id || transformModalId,\n      json,\n      rootPath: rootPath || [],\n      onTransform: (operations) => {\n        if (onTransform) {\n          onTransform({\n            operations,\n            json: json,\n            transformedJson: immutableJSONPatch(json, operations)\n          })\n        } else {\n          debug('onTransform', rootPath, operations)\n\n          handlePatch(operations)\n        }\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n        if (onClose) {\n          onClose()\n        }\n      }\n    })\n  }\n\n  function openJSONEditorModal(path: JSONPath) {\n    debug('openJSONEditorModal', { path })\n\n    modalOpen = true\n\n    // open a popup where you can edit the nested object/array\n    onJSONEditorModal({\n      content: {\n        json: getIn(json, path)\n      },\n      path,\n      onPatch: handlePatch,\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  function openRepairModal(text: string, onApply: (repairedText: string) => void) {\n    jsonRepairModalProps = {\n      text,\n      onParse: (text) => parsePartialJson(text, (t) => parseAndRepair(t, parser)),\n      onRepair: repairPartialJson,\n      onApply,\n      onClose: focus\n    }\n  }\n\n  function handleSortAll() {\n    const rootPath: JSONPath = []\n    openSortModal(rootPath)\n  }\n\n  function handleTransformAll() {\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function openFind(findAndReplace: boolean): void {\n    debug('openFind', { findAndReplace })\n\n    showSearch = false\n    showReplace = false\n\n    flushSync()\n\n    // trick to make sure the focus goes to the search box\n    showSearch = true\n    showReplace = findAndReplace\n  }\n\n  function handleUndo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canUndo) {\n      return\n    }\n\n    const item = history.undo()\n    if (!isTreeHistoryItem(item)) {\n      onUndo(item)\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.undo.patch ? immutableJSONPatch(json, item.undo.patch) : item.undo.json\n    documentState = item.undo.documentState\n    selection = item.undo.selection\n    sortedColumn = item.undo.sortedColumn\n    text = item.undo.text\n    textIsRepaired = item.undo.textIsRepaired\n    parseError = undefined\n\n    debug('undo', { item, json })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.undo.patch,\n            undo: item.redo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), { scrollToWhenVisible: false })\n    }\n  }\n\n  function handleRedo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canRedo) {\n      return\n    }\n\n    const item = history.redo()\n    if (!isTreeHistoryItem(item)) {\n      onRedo(item)\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.redo.patch ? immutableJSONPatch(json, item.redo.patch) : item.redo.json\n    documentState = item.redo.documentState\n    selection = item.redo.selection\n    sortedColumn = item.redo.sortedColumn\n    text = item.redo.text\n    textIsRepaired = item.redo.textIsRepaired\n    parseError = undefined\n\n    debug('redo', { item, json })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.redo.patch,\n            undo: item.undo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), { scrollToWhenVisible: false })\n    }\n  }\n\n  function handleResizeContents(element: Element) {\n    viewPortHeight = element.getBoundingClientRect().height\n  }\n\n  function handleResizeRow(element: Element, rowIndex: number) {\n    itemHeightsCache[rowIndex] = element.getBoundingClientRect().height\n  }\n</script>\n\n<svelte:window on:mousedown={handleWindowMouseDown} />\n\n<!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n<div\n  role=\"table\"\n  class=\"jse-table-mode\"\n  class:no-main-menu={!mainMenuBar}\n  on:mousedown={handleMouseDown}\n  on:keydown={handleKeyDown}\n  on:contextmenu={handleContextMenu}\n  bind:this={refJsonEditor}\n>\n  {#if mainMenuBar}\n    <TableMenu\n      {containsValidArray}\n      {readOnly}\n      bind:showSearch\n      {history}\n      onSort={handleSortAll}\n      onTransform={handleTransformAll}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      onContextMenu={handleContextMenuFromTableMenu}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if !isSSR}\n    <label class=\"jse-hidden-input-label\">\n      <input\n        type=\"text\"\n        readonly={true}\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n        on:paste={handlePaste}\n      />\n    </label>\n    {#if containsValidArray}\n      <div class=\"jse-search-box-container\">\n        <SearchBox\n          {json}\n          {documentState}\n          {parser}\n          {showSearch}\n          {showReplace}\n          {readOnly}\n          {columns}\n          onSearch={handleSearch}\n          onFocus={handleFocusSearch}\n          onPatch={handlePatch}\n          onClose={handleCloseSearch}\n        />\n      </div>\n      <div\n        class=\"jse-contents\"\n        bind:this={refContents}\n        use:resizeObserver={handleResizeContents}\n        on:scroll={handleScroll}\n      >\n        <table class=\"jse-table-main\">\n          <tbody>\n            <tr class=\"jse-table-row jse-table-row-header\">\n              <th class=\"jse-table-cell jse-table-cell-header\">\n                {#if !isEmpty(groupedValidationErrors?.root)}\n                  {@const validationError = mergeValidationErrors(\n                    [],\n                    groupedValidationErrors?.root\n                  )}\n                  {#if validationError}\n                    <div class=\"jse-table-root-error\">\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    </div>\n                  {/if}\n                {/if}\n              </th>\n              {#each columns as column}\n                <th class=\"jse-table-cell jse-table-cell-header\">\n                  <ColumnHeader path={column} {sortedColumn} {readOnly} onSort={onSortByHeader} />\n                </th>\n              {/each}\n              {#if showRefreshButton}\n                <th class=\"jse-table-cell jse-table-cell-header\">\n                  <RefreshColumnHeader\n                    count={Array.isArray(json) ? json.length : 0}\n                    {maxSampleCount}\n                    {readOnly}\n                    onRefresh={() => (maxSampleCount = Infinity)}\n                  />\n                </th>\n              {/if}\n            </tr>\n            <tr\n              class=\"jse-table-invisible-start-section\"\n              class:jse-search-box-background={showSearch}\n            >\n              <td style:height={visibleSection.startHeight + 'px'} colspan={columns.length}></td>\n            </tr>\n            {#each visibleSection.visibleItems as item, visibleIndex}\n              {@const rowIndex = visibleSection.startIndex + visibleIndex}\n              {@const validationErrorsByRow = groupedValidationErrors.rows[rowIndex]}\n              {@const validationError = mergeValidationErrors(\n                [String(rowIndex)],\n                validationErrorsByRow?.row\n              )}\n              {@const searchResultByRow = getInRecursiveState(json, searchResults, [\n                String(rowIndex)\n              ])}\n              <tr class=\"jse-table-row\">\n                {#key rowIndex}\n                  <th\n                    class=\"jse-table-cell jse-table-cell-gutter\"\n                    use:resizeObserver={(element) => handleResizeRow(element, rowIndex)}\n                  >\n                    {rowIndex}\n                    {#if validationError}\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    {/if}\n                  </th>\n                {/key}\n                {#each columns as column, columnIndex}\n                  {@const path = [String(rowIndex)].concat(column)}\n                  {@const value = getIn(item, column)}\n                  {@const isSelected =\n                    isValueSelection(selection) && pathStartsWith(selection.path, path)}\n                  {@const validationErrorsByColumn = validationErrorsByRow?.columns[columnIndex]}\n                  {@const validationError = mergeValidationErrors(path, validationErrorsByColumn)}\n                  <td class=\"jse-table-cell\" data-path={encodeDataPath(path)}>\n                    <div class=\"jse-value-outer\" class:jse-selected-value={isSelected}>\n                      {#if isObjectOrArray(value)}\n                        {@const searchResultsByCell = flattenSearchResults(\n                          getInRecursiveState(item, searchResultByRow, column)\n                        )}\n\n                        {@const containsActiveSearchResult = searchResultsByCell\n                          ? searchResultsByCell.some((item) => item.active)\n                          : false}\n\n                        <InlineValue\n                          {path}\n                          {value}\n                          {parser}\n                          {isSelected}\n                          containsSearchResult={!isEmpty(searchResultsByCell)}\n                          {containsActiveSearchResult}\n                          onEdit={openJSONEditorModal}\n                        />{:else}\n                        {@const searchResultItemsByCell = getInRecursiveState(\n                          json,\n                          searchResults,\n                          path\n                        )?.searchResults}\n\n                        <JSONValue\n                          {path}\n                          value={value !== undefined ? value : ''}\n                          enforceString={getEnforceString(json, documentState, path)}\n                          selection={isSelected ? selection : undefined}\n                          searchResultItems={searchResultItemsByCell}\n                          {context}\n                        />{/if}{#if !readOnly && isSelected && !isEditingSelection(selection)}\n                        <div class=\"jse-context-menu-anchor\">\n                          <ContextMenuPointer selected={true} onContextMenu={openContextMenu} />\n                        </div>\n                      {/if}\n                    </div>\n                    {#if validationError}\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    {/if}\n                  </td>\n                {/each}\n                {#if showRefreshButton}\n                  <td class=\"jse-table-cell\"></td>\n                {/if}\n              </tr>\n            {/each}\n\n            <tr class=\"jse-table-invisible-end-section\">\n              <td style:height={visibleSection.endHeight + 'px'} colspan={columns.length}></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n\n      {#if pastedJson}\n        <Message\n          type=\"info\"\n          message={`You pasted a JSON ${\n            Array.isArray(pastedJson.contents) ? 'array' : 'object'\n          } as text`}\n          actions={[\n            {\n              icon: faWrench,\n              text: 'Paste as JSON instead',\n              title: 'Paste the text as JSON instead of a single value',\n              // We use mousedown here instead of click: this message pops up\n              // whilst the user is editing a value. When clicking this button,\n              // the actual value is applied and the event is not propagated\n              // and an onClick on this button never happens.\n              onMouseDown: handleParsePastedJson\n            },\n            {\n              text: 'Leave as is',\n              title: 'Keep the pasted content as a single value',\n              onClick: handleClearPastedJson\n            }\n          ]}\n        />\n      {/if}\n\n      {#if textIsRepaired}\n        <Message\n          type=\"success\"\n          message=\"The loaded JSON document was invalid but is successfully repaired.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCheck,\n                  text: 'Ok',\n                  title: 'Accept the repaired document',\n                  onClick: acceptAutoRepair\n                },\n                {\n                  icon: faCode,\n                  text: 'Repair manually instead',\n                  title: 'Leave the document unchanged and repair it manually instead',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview {validationErrors} selectError={handleSelectValidationError} />\n    {:else if parseError && text !== undefined && text !== ''}\n      <Message\n        type=\"error\"\n        message=\"The loaded JSON document is invalid and could not be repaired automatically.\"\n        actions={!readOnly\n          ? [\n              {\n                icon: faCode,\n                text: 'Repair manually',\n                title: 'Open the document in \"code\" mode and repair it manually',\n                onClick: handleRequestRepair\n              }\n            ]\n          : []}\n      />\n      <JSONPreview {text} {json} {indentation} {parser} />\n    {:else}\n      <TableModeWelcome\n        {text}\n        {json}\n        {readOnly}\n        {parser}\n        {openJSONEditorModal}\n        extractPath={handleExtract}\n        {onChangeMode}\n        onClick={() => {\n          // FIXME: this is a workaround for the editor not putting the focus on refHiddenInput\n          //  when clicking in the welcome screen so you cannot paste a document from clipboard.\n          focus()\n        }}\n      />\n    {/if}\n  {:else}\n    <div class=\"jse-contents jse-contents-loading\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n{#if copyPasteModalOpen}\n  <CopyPasteModal onClose={() => (copyPasteModalOpen = false)} />\n{/if}\n\n{#if jsonRepairModalProps}\n  <JSONRepairModal\n    {...jsonRepairModalProps}\n    onClose={() => {\n      jsonRepairModalProps?.onClose()\n      jsonRepairModalProps = undefined\n    }}\n  />\n{/if}\n\n<style src=\"./TableMode.scss\"></style>\n","import type { ContextMenuItem, DocumentState, JSONSelection } from 'svelte-jsoneditor'\nimport {\n  faCheckSquare,\n  faClone,\n  faCopy,\n  faCut,\n  faPaste,\n  faPen,\n  faPlus,\n  faSquare,\n  faTrashCan\n} from '@fortawesome/free-solid-svg-icons'\nimport { isKeySelection, isMultiSelection, isValueSelection } from '$lib/logic/selection'\nimport { getIn } from 'immutable-json-patch'\nimport { getFocusPath, singleItemSelected } from '$lib/logic/selection'\nimport { isObjectOrArray } from '$lib/utils/typeUtils'\nimport { getEnforceString } from '$lib/logic/documentState'\n\nexport default function ({\n  json,\n  documentState,\n  selection,\n  readOnly,\n  onEditValue,\n  onEditRow,\n  onToggleEnforceString,\n  onCut,\n  onCopy,\n  onPaste,\n  onRemove,\n  onDuplicateRow,\n  onInsertBeforeRow,\n  onInsertAfterRow,\n  onRemoveRow\n}: {\n  json: unknown | undefined\n  documentState: DocumentState | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  onEditValue: () => void\n  onEditRow: () => void\n  onToggleEnforceString: () => void\n  onCut: (indent: boolean) => void\n  onCopy: (indent: boolean) => void\n  onPaste: () => void\n  onRemove: () => void\n  onDuplicateRow: () => void\n  onInsertBeforeRow: () => void\n  onInsertAfterRow: () => void\n  onRemoveRow: () => void\n}): ContextMenuItem[] {\n  const hasJson = json !== undefined\n  const hasSelection = !!selection\n  const focusValue =\n    json !== undefined && selection ? getIn(json, getFocusPath(selection)) : undefined\n\n  const hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  const canEditValue =\n    !readOnly && hasJson && selection !== undefined && singleItemSelected(selection)\n  const canEnforceString = canEditValue && !isObjectOrArray(focusValue)\n\n  const canCut = !readOnly && hasSelectionContents\n\n  const enforceString =\n    selection !== undefined ? getEnforceString(json, documentState, getFocusPath(selection)) : false\n\n  return [\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: 'Table cell:' },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onEditValue(),\n                icon: faPen,\n                text: 'Edit',\n                title: 'Edit the value (Double-click on the value)',\n                disabled: !canEditValue\n              },\n              width: '11em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faPen,\n                  text: 'Edit',\n                  title: 'Edit the value (Double-click on the value)',\n                  onClick: () => onEditValue(),\n                  disabled: !canEditValue\n                },\n                {\n                  type: 'button',\n                  icon: enforceString ? faCheckSquare : faSquare,\n                  text: 'Enforce string',\n                  title: 'Enforce keeping the value as string when it contains a numeric value',\n                  onClick: () => onToggleEnforceString(),\n                  disabled: !canEnforceString\n                }\n              ]\n            },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onCut(true),\n                icon: faCut,\n                text: 'Cut',\n                title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n                disabled: !canCut\n              },\n              width: '10em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faCut,\n                  text: 'Cut formatted',\n                  title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n                  onClick: () => onCut(true),\n                  disabled: readOnly || !hasSelectionContents\n                },\n                {\n                  type: 'button',\n                  icon: faCut,\n                  text: 'Cut compacted',\n                  title: 'Cut selected contents, without indentation (Ctrl+Shift+X)',\n                  onClick: () => onCut(false),\n                  disabled: readOnly || !hasSelectionContents\n                }\n              ]\n            },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onCopy(true),\n                icon: faCopy,\n                text: 'Copy',\n                title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n                disabled: !hasSelectionContents\n              },\n              width: '12em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faCopy,\n                  text: 'Copy formatted',\n                  title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n                  onClick: () => onCopy(false),\n                  disabled: !hasSelectionContents\n                },\n                {\n                  type: 'button',\n                  icon: faCopy,\n                  text: 'Copy compacted',\n                  title: 'Copy selected contents, without indentation (Ctrl+Shift+C)',\n                  onClick: () => onCopy(false),\n                  disabled: !hasSelectionContents\n                }\n              ]\n            },\n            {\n              type: 'button',\n              onClick: () => onPaste(),\n              icon: faPaste,\n              text: 'Paste',\n              title: 'Paste clipboard contents (Ctrl+V)',\n              disabled: readOnly || !hasSelection\n            },\n            {\n              type: 'button',\n              onClick: () => onRemove(),\n              icon: faTrashCan,\n              text: 'Remove',\n              title: 'Remove selected contents (Delete)',\n              disabled: readOnly || !hasSelectionContents\n            }\n          ]\n        },\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: 'Table row:' },\n            {\n              type: 'button',\n              onClick: () => onEditRow(),\n              icon: faPen,\n              text: 'Edit row',\n              title: 'Edit the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onDuplicateRow(),\n              icon: faClone,\n              text: 'Duplicate row',\n              title: 'Duplicate the current row (Ctrl+D)',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onInsertBeforeRow(),\n              icon: faPlus,\n              text: 'Insert before',\n              title: 'Insert a row before the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onInsertAfterRow(),\n              icon: faPlus,\n              text: 'Insert after',\n              title: 'Insert a row after the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onRemoveRow(),\n              icon: faTrashCan,\n              text: 'Remove row',\n              title: 'Remove current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { HistoryItem, History, MenuItem, OnRenderMenuInternal } from '$lib/types'\n  import Menu from '../../../controls/Menu.svelte'\n  import {\n    faEllipsisV,\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { CONTEXT_MENU_EXPLANATION } from '$lib/constants.js'\n\n  export let containsValidArray: boolean\n  export let readOnly: boolean\n  export let showSearch = false\n  export let history: History<HistoryItem>\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onContextMenu: (event: MouseEvent) => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let onRenderMenu: OnRenderMenuInternal\n\n  function handleToggleSearch() {\n    showSearch = !showSearch\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faSearch,\n          title: 'Search (Ctrl+F)',\n          className: 'jse-search',\n          onClick: handleToggleSearch,\n          disabled: !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faEllipsisV,\n          title: CONTEXT_MENU_EXPLANATION,\n          className: 'jse-contextmenu',\n          onClick: onContextMenu\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !history.canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !history.canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        {\n          type: 'space'\n        }\n      ]\n\n  let items: MenuItem[]\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { SortedColumn } from '$lib/types.js'\n  import { SortDirection } from '$lib/types.js'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import Icon from 'svelte-awesome'\n  import { faCaretDown, faCaretUp } from '@fortawesome/free-solid-svg-icons'\n  import { isEmpty, isEqual } from 'lodash-es'\n  import { MAX_HEADER_NAME_CHARACTERS, SORT_DIRECTION_NAMES } from '$lib/constants.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n\n  export let path: JSONPath\n  export let sortedColumn: SortedColumn | undefined\n  export let readOnly: boolean\n  export let onSort: (sortedColumn: SortedColumn) => void\n\n  // TODO: improve truncating of long column names when they are a deeply nested path: the last item from the path should be visible, and halfway the path is least interesting\n  $: columnName = !isEmpty(path) ? stringifyJSONPath(path) : 'values'\n\n  $: sortDirection =\n    sortedColumn && isEqual(path, sortedColumn?.path) ? sortedColumn.sortDirection : undefined\n\n  $: sortDirectionName = sortDirection ? SORT_DIRECTION_NAMES[sortDirection] : undefined\n\n  function handleSort() {\n    if (readOnly) {\n      return\n    }\n\n    onSort({\n      path,\n      sortDirection: sortDirection === SortDirection.asc ? SortDirection.desc : SortDirection.asc\n    })\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-column-header\"\n  class:jse-readonly={readOnly}\n  on:click={handleSort}\n  title={!readOnly ? columnName + ' (Click to sort the data by this column)' : columnName}\n>\n  <span class=\"jse-column-name\">\n    {truncate(columnName, MAX_HEADER_NAME_CHARACTERS)}\n  </span>\n  {#if sortDirection !== undefined}\n    <span class=\"jse-column-sort-icon\" title={`Currently sorted in ${sortDirectionName} order`}>\n      <Icon data={sortDirection === SortDirection.asc ? faCaretDown : faCaretUp} />\n    </span>\n  {/if}\n</button>\n\n<style src=\"./ColumnHeader.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faRotate } from '@fortawesome/free-solid-svg-icons'\n\n  export let count: number\n  export let maxSampleCount: number\n  export let readOnly: boolean\n  export let onRefresh: () => void\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-column-header\"\n  class:jse-readonly={readOnly}\n  title={`The Columns are created by sampling ${maxSampleCount} items out of ${count}. ` +\n    \"If you're missing a column, click here to sample all of the items instead of a subset. \" +\n    'This is slower.'}\n  on:click={() => onRefresh()}\n>\n  <Icon data={faRotate} />\n</button>\n\n<style src=\"./RefreshColumnHeader.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { JSONParser } from '$lib/types'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { MAX_INLINE_OBJECT_CHARS } from '$lib/constants.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let parser: JSONParser\n  export let isSelected: boolean\n  export let containsSearchResult: boolean\n  export let containsActiveSearchResult: boolean\n  export let onEdit: (path: JSONPath) => void\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-inline-value\"\n  class:jse-selected={isSelected}\n  class:jse-highlight={containsSearchResult}\n  class:jse-active={containsActiveSearchResult}\n  on:dblclick={() => onEdit(path)}\n>\n  {truncate(parser.stringify(value) ?? '', MAX_INLINE_OBJECT_CHARS)}\n</button>\n\n<style src=\"./InlineValue.scss\"></style>\n","<script lang=\"ts\">\n  import type {\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    HistoryItem,\n    History,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    MenuItem,\n    MenuSeparator,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRenderContextMenu,\n    OnRenderContextMenuInternal,\n    OnRenderMenu,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    TransformModalOptions,\n    Validator,\n    ModeHistoryItem\n  } from '$lib/types'\n  import { Mode } from '$lib/types.js'\n  import TextMode from './textmode/TextMode.svelte'\n  import TableMode from './tablemode/TableMode.svelte'\n  import TreeMode from './treemode/TreeMode.svelte'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { isMenuSpace, isModeHistoryItem } from '$lib/typeguards.js'\n  import { cloneDeep } from 'lodash-es'\n  import { createHistoryInstance } from '$lib/logic/history'\n  import { createDebug } from '$lib/utils/debug'\n\n  export let content: Content\n  export let selection: JSONEditorSelection | undefined\n\n  export let readOnly: boolean\n  export let indentation: number | string\n  export let tabSize: number\n  export let truncateTextSize: number\n  export let externalMode: Mode\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n  export let insideModal: boolean\n\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onRenderValue: OnRenderValue\n  export let onClassName: OnClassName\n  export let onRenderMenu: OnRenderMenu\n  export let onRenderContextMenu: OnRenderContextMenu\n  export let onError: OnError\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  let refTreeMode: TreeMode | undefined\n  let refTableMode: TableMode | undefined\n  let refTextMode: TextMode | undefined\n\n  const debug = createDebug('jsoneditor:JSONEditorRoot')\n\n  const historyInstance = createHistoryInstance<HistoryItem>({\n    onChange: (updatedHistory) => (history = updatedHistory)\n  })\n\n  let history: History<HistoryItem> = historyInstance.get()\n\n  let mode = externalMode\n\n  function applyExternalMode(externalMode: Mode) {\n    if (externalMode === mode) {\n      return\n    }\n\n    const item: ModeHistoryItem = {\n      type: 'mode',\n      undo: { mode, selection: undefined },\n      redo: { mode: externalMode, selection: undefined }\n    }\n\n    if (mode === 'text' && refTextMode) {\n      // flush pending changes before adding a new history item\n      refTextMode.flush()\n    }\n\n    debug('add history item', item)\n    history.add(item)\n\n    mode = externalMode\n  }\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyExternalMode(externalMode)\n\n  function handleUndo(item: HistoryItem | undefined) {\n    if (isModeHistoryItem(item)) {\n      mode = item.undo.mode // important to prevent a new history item from being created\n\n      // find the selection of the previous history item (if any), and use that as initial selection\n      const items = history.items()\n      const index = items.findIndex((i) => i === item)\n      const prevItem = index !== -1 ? items[index - 1] : undefined\n      debug('handleUndo', { index, item, items, prevItem })\n      if (prevItem) {\n        selection = prevItem.redo.selection\n      }\n\n      onChangeMode(mode)\n    }\n  }\n\n  function handleRedo(item: HistoryItem | undefined) {\n    if (isModeHistoryItem(item)) {\n      // prevent a new history item from being created\n      mode = item.redo.mode\n\n      // find the selection of the next history item (if any), and use that as initial selection\n      const items = history.items()\n      const index = items.findIndex((i) => i === item)\n      const nextItem = index !== -1 ? items[index + 1] : undefined\n      debug('handleRedo', { index, item, items, nextItem })\n      if (nextItem) {\n        selection = nextItem.undo.selection\n      }\n\n      onChangeMode(mode)\n    }\n  }\n\n  let modeMenuItems: MenuItem[]\n  $: modeMenuItems = [\n    {\n      type: 'button',\n      text: 'text',\n      title: `Switch to text mode (current mode: ${mode})`,\n      className: 'jse-group-button jse-first' + (mode === Mode.text ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.text)\n    },\n    {\n      type: 'button',\n      text: 'tree',\n      title: `Switch to tree mode (current mode: ${mode})`,\n      className: 'jse-group-button ' + (mode === Mode.tree ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.tree)\n    },\n    {\n      type: 'button',\n      text: 'table',\n      title: `Switch to table mode (current mode: ${mode})`,\n      className: 'jse-group-button jse-last' + (mode === Mode.table ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.table)\n    }\n  ]\n\n  const separatorMenuItem: MenuSeparator = {\n    type: 'separator'\n  }\n\n  let handleRenderMenu: OnRenderMenuInternal\n  $: handleRenderMenu = (items: MenuItem[]) => {\n    const updatedItems = isMenuSpace(items[0])\n      ? modeMenuItems.concat(items) // menu is empty, readOnly mode\n      : modeMenuItems.concat(separatorMenuItem, items)\n\n    const updatedItemsOriginal = cloneDeep(updatedItems) // the user may change updatedItems in the callback\n\n    return (\n      onRenderMenu(updatedItems, { mode, modal: insideModal, readOnly }) || updatedItemsOriginal\n    )\n  }\n\n  let handleRenderContextMenu: OnRenderContextMenuInternal\n  $: handleRenderContextMenu = (items: ContextMenuItem[]) => {\n    const itemsOriginal = cloneDeep(items) // the user may change items in the callback\n\n    return (\n      onRenderContextMenu(items, { mode, modal: insideModal, readOnly, selection }) ??\n      (readOnly ? false : itemsOriginal)\n    )\n  }\n\n  export function patch(operations: JSONPatchDocument): JSONPatchResult {\n    if (refTreeMode) {\n      // Note that tree mode has an optional afterPatch callback.\n      // right now we don's support this in the public API.\n      return refTreeMode.patch(operations)\n    }\n\n    if (refTableMode) {\n      // Note that tree mode has an optional afterPatch callback.\n      // right now we don's support this in the public API.\n      return refTableMode.patch(operations)\n    }\n\n    if (refTextMode) {\n      return refTextMode.patch(operations)\n    }\n\n    throw new Error(`Method patch is not available in mode \"${mode}\"`)\n  }\n\n  export function expand(path: JSONPath, callback?: OnExpand): void {\n    if (refTreeMode) {\n      return refTreeMode.expand(path, callback)\n    } else {\n      throw new Error(`Method expand is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function collapse(path: JSONPath, recursive: boolean): void {\n    if (refTreeMode) {\n      return refTreeMode.collapse(path, recursive)\n    } else {\n      throw new Error(`Method collapse is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * Open the transform modal\n   */\n  export function transform(options: TransformModalOptions): void {\n    if (refTextMode) {\n      refTextMode.openTransformModal(options)\n    } else if (refTreeMode) {\n      refTreeMode.openTransformModal(options)\n    } else if (refTableMode) {\n      refTableMode.openTransformModal(options)\n    } else {\n      throw new Error(`Method transform is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * Validate the contents of the editor using the configured validator.\n   * Returns a parse error or a list with validation warnings\n   */\n  export function validate(): ContentErrors | undefined {\n    if (refTextMode) {\n      return refTextMode.validate()\n    } else if (refTreeMode) {\n      return refTreeMode.validate()\n    } else if (refTableMode) {\n      return refTableMode.validate()\n    } else {\n      throw new Error(`Method validate is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * In tree mode, invalid JSON is automatically repaired when loaded. When the\n   * repair was successful, the repaired contents are rendered but not yet\n   * applied to the document itself until the user clicks \"Ok\" or starts editing\n   * the data. Instead of accepting the repair, the user can also click\n   * \"Repair manually instead\". Invoking `.acceptAutoRepair()` will\n   * programmatically accept the repair. This will trigger an update,\n   * and the method itself also returns the updated contents. In case of text\n   * mode or when the editor is not in an \"accept auto repair\" status, nothing\n   * will happen, and the contents will be returned as is.\n   */\n  export function acceptAutoRepair(): Content {\n    if (refTreeMode) {\n      return refTreeMode.acceptAutoRepair()\n    } else {\n      return content\n    }\n  }\n\n  export function scrollTo(path: JSONPath): Promise<void> {\n    if (refTreeMode) {\n      return refTreeMode.scrollTo(path)\n    } else if (refTableMode) {\n      return refTableMode.scrollTo(path)\n    } else {\n      // TODO: implement scrollTo for text mode\n      throw new Error(`Method scrollTo is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function findElement(path: JSONPath): Element | undefined {\n    if (refTreeMode) {\n      return refTreeMode.findElement(path)\n    } else if (refTableMode) {\n      return refTableMode.findElement(path)\n    } else {\n      throw new Error(`Method findElement is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function focus() {\n    if (refTextMode) {\n      refTextMode.focus()\n    } else if (refTreeMode) {\n      refTreeMode.focus()\n    } else if (refTableMode) {\n      refTableMode.focus()\n    }\n  }\n\n  export async function refresh(): Promise<void> {\n    if (refTextMode) {\n      await refTextMode.refresh()\n    } else {\n      // nothing to do in tree or table mode (also: don't throw an exception or so,\n      // that annoying having to reckon with that when using .refresh()).\n    }\n  }\n</script>\n\n{#if mode === Mode.text || String(mode) === 'code'}\n  <TextMode\n    bind:this={refTextMode}\n    externalContent={content}\n    externalSelection={selection}\n    {history}\n    {readOnly}\n    {indentation}\n    {tabSize}\n    {mainMenuBar}\n    {statusBar}\n    {askToFormat}\n    {escapeUnicodeCharacters}\n    {parser}\n    {validator}\n    {validationParser}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    onUndo={handleUndo}\n    onRedo={handleRedo}\n    {onError}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    {onSortModal}\n    {onTransformModal}\n  />\n{:else if mode === Mode.table}\n  <TableMode\n    bind:this={refTableMode}\n    externalContent={content}\n    externalSelection={selection}\n    {history}\n    {readOnly}\n    {truncateTextSize}\n    {mainMenuBar}\n    {escapeControlCharacters}\n    {escapeUnicodeCharacters}\n    {flattenColumns}\n    {parser}\n    {parseMemoizeOne}\n    {validator}\n    {validationParser}\n    {indentation}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    onUndo={handleUndo}\n    onRedo={handleRedo}\n    {onRenderValue}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    onRenderContextMenu={handleRenderContextMenu}\n    {onSortModal}\n    {onTransformModal}\n    {onJSONEditorModal}\n  />\n{:else}\n  <!-- mode === Mode.tree -->\n  <TreeMode\n    bind:this={refTreeMode}\n    externalContent={content}\n    externalSelection={selection}\n    {history}\n    {readOnly}\n    {indentation}\n    {truncateTextSize}\n    {mainMenuBar}\n    {navigationBar}\n    {escapeControlCharacters}\n    {escapeUnicodeCharacters}\n    {parser}\n    {parseMemoizeOne}\n    {validator}\n    {validationParser}\n    {pathParser}\n    {onError}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    onUndo={handleUndo}\n    onRedo={handleRedo}\n    {onRenderValue}\n    {onClassName}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    onRenderContextMenu={handleRenderContextMenu}\n    {onSortModal}\n    {onTransformModal}\n    {onJSONEditorModal}\n  />\n{/if}\n","import type { NumberOption, PathOption } from '$lib/types.js'\n\nexport interface SortModalState {\n  selectedProperty: PathOption\n  selectedDirection: NumberOption\n}\n\nexport const sortModalStates: Record<string, SortModalState> = {}\n","<svelte:options accessors={false} immutable={true} />\n\n<script lang=\"ts\">\n  import { createDebug } from '../utils/debug.js'\n  import { uniqueId } from '../utils/uniqueId.js'\n  import { isEqualParser, isJSONContent, validateContentType } from '../utils/jsonUtils.js'\n  import AbsolutePopup from './modals/popup/AbsolutePopup.svelte'\n  import { jsonQueryLanguage } from '$lib/plugins/query/jsonQueryLanguage.js'\n  import { renderValue } from '$lib/plugins/value/renderValue.js'\n  import { flushSync } from 'svelte'\n  import TransformModal from './modals/TransformModal.svelte'\n  import type {\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    JSONEditorModalCallback,\n    JSONEditorModalProps,\n    JSONEditorPropsOptional,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    MenuItem,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnChangeQueryLanguage,\n    OnChangeStatus,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnRenderMenu,\n    OnRenderValue,\n    OnSelect,\n    QueryLanguage,\n    SortModalCallback,\n    TransformModalCallback,\n    TransformModalOptions,\n    TransformModalProps,\n    Validator\n  } from '$lib/types'\n  import type { OnRenderContextMenu } from '$lib/types.js'\n  import { Mode } from '$lib/types.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { noop } from '../utils/noop.js'\n  import { parseJSONPath, stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import JSONEditorRoot from './modes/JSONEditorRoot.svelte'\n  import JSONEditorModal from './modals/JSONEditorModal.svelte'\n  import memoizeOne from 'memoize-one'\n  import { cloneDeep } from 'lodash-es'\n  import SortModal from './modals/SortModal.svelte'\n\n  // TODO: document how to enable debugging in the readme: localStorage.debug=\"jsoneditor:*\", then reload\n  const debug = createDebug('jsoneditor:JSONEditor')\n\n  const contentDefault = { text: '' }\n  const selectionDefault = undefined\n  const readOnlyDefault = false\n  const indentationDefault = 2\n  const tabSizeDefault = 4\n  const truncateTextSizeDefault = 1000\n  const modeDefault = Mode.tree\n  const mainMenuBarDefault = true\n  const navigationBarDefault = true\n  const statusBarDefault = true\n  const askToFormatDefault = true\n  const escapeControlCharactersDefault = false\n  const escapeUnicodeCharactersDefault = false\n  const flattenColumnsDefault = true\n  const parserDefault = JSON\n  const validatorDefault = undefined\n  const validationParserDefault = JSON\n  const pathParserDefault = {\n    parse: parseJSONPath,\n    stringify: stringifyJSONPath\n  }\n  const queryLanguagesDefault = [jsonQueryLanguage]\n  const queryLanguageIdDefault = queryLanguagesDefault[0].id\n  const onChangeQueryLanguageDefault = noop\n  const onChangeDefault = undefined\n  const onSelectDefault = undefined\n  const onRenderValueDefault = renderValue\n  const onClassNameDefault = noop\n  const onRenderMenuDefault = noop\n  const onRenderContextMenuDefault = noop\n  const onChangeModeDefault = noop\n  const onErrorDefault: OnError = (err) => {\n    console.error(err)\n    alert(err.toString()) // TODO: create a nice alert modal\n  }\n  const onFocusDefault = noop\n  const onBlurDefault = noop\n\n  export let content: Content = contentDefault\n  export let selection: JSONEditorSelection | undefined = selectionDefault\n  export let readOnly: boolean = readOnlyDefault\n  export let indentation: number | string = indentationDefault\n  export let tabSize: number = tabSizeDefault\n  export let truncateTextSize: number = truncateTextSizeDefault\n  export let mode: Mode = modeDefault\n  export let mainMenuBar: boolean = mainMenuBarDefault\n  export let navigationBar: boolean = navigationBarDefault\n  export let statusBar: boolean = statusBarDefault\n  export let askToFormat: boolean = askToFormatDefault\n  export let escapeControlCharacters: boolean = escapeControlCharactersDefault\n  export let escapeUnicodeCharacters: boolean = escapeUnicodeCharactersDefault\n  export let flattenColumns: boolean = flattenColumnsDefault\n  export let parser: JSONParser = parserDefault\n  export let validator: Validator | undefined = validatorDefault\n  export let validationParser: JSONParser = validationParserDefault\n  export let pathParser: JSONPathParser = pathParserDefault\n  export let queryLanguages: QueryLanguage[] = queryLanguagesDefault\n  export let queryLanguageId: string = queryLanguageIdDefault\n  export let onChangeQueryLanguage: OnChangeQueryLanguage = onChangeQueryLanguageDefault\n  export let onChange: OnChange | undefined = onChangeDefault\n  export let onSelect: OnSelect | undefined = onSelectDefault\n  export let onRenderValue: OnRenderValue = onRenderValueDefault\n  export let onClassName: OnClassName = onClassNameDefault\n  export let onRenderMenu: OnRenderMenu = onRenderMenuDefault\n  export let onRenderContextMenu: OnRenderContextMenu = onRenderContextMenuDefault\n  export let onChangeMode: OnChangeMode = onChangeModeDefault\n  export let onError: OnError = onErrorDefault\n  export let onFocus: OnFocus = onFocusDefault\n  export let onBlur: OnBlur = onBlurDefault\n\n  let instanceId = uniqueId()\n  let hasFocus = false\n  let refJSONEditorRoot: JSONEditorRoot\n  let jsonEditorModalProps: JSONEditorModalProps | undefined = undefined\n  let sortModalProps: SortModalCallback | undefined\n  let transformModalProps: TransformModalProps | undefined\n\n  $: {\n    const contentError = validateContentType(content)\n    if (contentError) {\n      console.error('Error: ' + contentError)\n    }\n  }\n\n  // backward compatibility warning since v1.0.0\n  $: if (selection === null) {\n    console.warn('selection is invalid: it is null but should be undefined')\n  }\n\n  // We memoize the last parse result for the case when the content is text and very large.\n  // In that case parsing takes a few seconds. When the user switches between tree and table mode,\n  // without having made a change, we do not want to parse the text again.\n  $: parseMemoizeOne = memoizeOne(parser.parse)\n\n  // rerender the full editor when the parser changes. This is needed because\n  // numeric state is hold at many places in the editor.\n  let previousParser = parser\n  $: {\n    if (!isEqualParser(parser, previousParser)) {\n      debug('parser changed, recreate editor')\n\n      if (isJSONContent(content)) {\n        const text = previousParser.stringify(content.json)\n        content = {\n          json: text !== undefined ? parser.parse(text) : undefined\n        }\n      }\n\n      previousParser = parser\n\n      // new editor id -> will re-create the editor\n      instanceId = uniqueId()\n    }\n  }\n\n  export function get(): Content {\n    return content\n  }\n\n  export function set(newContent: Content): void {\n    debug('set')\n\n    const contentError = validateContentType(newContent)\n    if (contentError) {\n      throw new Error(contentError)\n    }\n\n    // new editor id -> will re-create the editor\n    instanceId = uniqueId()\n\n    // update content *after* re-render, so that the new editor will trigger an onChange event\n    content = newContent\n\n    flushSync()\n  }\n\n  export function update(updatedContent: Content): void {\n    debug('update')\n\n    const contentError = validateContentType(updatedContent)\n    if (contentError) {\n      throw new Error(contentError)\n    }\n\n    content = updatedContent\n\n    flushSync()\n  }\n\n  export function patch(operations: JSONPatchDocument): JSONPatchResult {\n    // Note that patch has an optional afterPatch callback.\n    // right now we don's support this in the public API.\n    const result = refJSONEditorRoot.patch(operations)\n\n    flushSync()\n\n    return result\n  }\n\n  export function select(newSelection: JSONEditorSelection | undefined): void {\n    selection = newSelection\n\n    flushSync()\n  }\n\n  export function expand(path: JSONPath, callback?: OnExpand): void {\n    refJSONEditorRoot.expand(path, callback)\n\n    flushSync()\n  }\n\n  export function collapse(path: JSONPath, recursive = false): void {\n    refJSONEditorRoot.collapse(path, recursive)\n\n    flushSync()\n  }\n\n  /**\n   * Open the transform modal\n   */\n  export function transform(options: TransformModalOptions = {}): void {\n    refJSONEditorRoot.transform(options)\n\n    flushSync()\n  }\n\n  /**\n   * Validate the contents of the editor using the configured validator.\n   * Returns a parse error or a list with validation warnings\n   */\n  export function validate(): ContentErrors | undefined {\n    return refJSONEditorRoot.validate()\n  }\n\n  /**\n   * In tree mode, invalid JSON is automatically repaired when loaded. When the\n   * repair was successful, the repaired contents are rendered but not yet\n   * applied to the document itself until the user clicks \"Ok\" or starts editing\n   * the data. Instead of accepting the repair, the user can also click\n   * \"Repair manually instead\". Invoking `.acceptAutoRepair()` will\n   * programmatically accept the repair. This will trigger an update,\n   * and the method itself also returns the updated contents. In case of text\n   * mode or when the editor is not in an \"accept auto repair\" status, nothing\n   * will happen, and the contents will be returned as is.\n   */\n  export function acceptAutoRepair(): Content {\n    const content = refJSONEditorRoot.acceptAutoRepair()\n\n    flushSync()\n\n    return content\n  }\n\n  export async function scrollTo(path: JSONPath): Promise<void> {\n    await refJSONEditorRoot.scrollTo(path)\n  }\n\n  export function findElement(path: JSONPath): Element | undefined {\n    return refJSONEditorRoot.findElement(path)\n  }\n\n  export function focus(): void {\n    refJSONEditorRoot.focus()\n\n    flushSync()\n  }\n\n  export async function refresh(): Promise<void> {\n    await refJSONEditorRoot.refresh()\n  }\n\n  export function updateProps(props: JSONEditorPropsOptional): void {\n    const names = Object.keys(props) as (keyof JSONEditorPropsOptional)[]\n\n    for (const name of names) {\n      switch (name) {\n        case 'content':\n          content = props[name] ?? contentDefault\n          break\n        case 'selection':\n          selection = props[name] ?? selectionDefault\n          break\n        case 'readOnly':\n          readOnly = props[name] ?? readOnlyDefault\n          break\n        case 'indentation':\n          indentation = props[name] ?? indentationDefault\n          break\n        case 'tabSize':\n          tabSize = props[name] ?? tabSizeDefault\n          break\n        case 'truncateTextSize':\n          truncateTextSize = props[name] ?? truncateTextSizeDefault\n          break\n        case 'mode':\n          mode = props[name] ?? modeDefault\n          break\n        case 'mainMenuBar':\n          mainMenuBar = props[name] ?? mainMenuBarDefault\n          break\n        case 'navigationBar':\n          navigationBar = props[name] ?? navigationBarDefault\n          break\n        case 'statusBar':\n          statusBar = props[name] ?? statusBarDefault\n          break\n        case 'askToFormat':\n          askToFormat = props[name] ?? askToFormatDefault\n          break\n        case 'escapeControlCharacters':\n          escapeControlCharacters = props[name] ?? escapeControlCharactersDefault\n          break\n        case 'escapeUnicodeCharacters':\n          escapeUnicodeCharacters = props[name] ?? escapeUnicodeCharactersDefault\n          break\n        case 'flattenColumns':\n          flattenColumns = props[name] ?? flattenColumnsDefault\n          break\n        case 'parser':\n          parser = props[name] ?? parserDefault\n          break\n        case 'validator':\n          validator = props[name] ?? validatorDefault\n          break\n        case 'validationParser':\n          validationParser = props[name] ?? validationParserDefault\n          break\n        case 'pathParser':\n          pathParser = props[name] ?? pathParserDefault\n          break\n        case 'queryLanguages':\n          queryLanguages = props[name] ?? queryLanguagesDefault\n          break\n        case 'queryLanguageId':\n          queryLanguageId = props[name] ?? queryLanguageIdDefault\n          break\n        case 'onChangeQueryLanguage':\n          onChangeQueryLanguage = props[name] ?? onChangeQueryLanguageDefault\n          break\n        case 'onChange':\n          onChange = props[name] ?? onChangeDefault\n          break\n        case 'onRenderValue':\n          onRenderValue = props[name] ?? onRenderValueDefault\n          break\n        case 'onClassName':\n          onClassName = props[name] ?? onClassNameDefault\n          break\n        case 'onRenderMenu':\n          onRenderMenu = props[name] ?? onRenderMenuDefault\n          break\n        case 'onRenderContextMenu':\n          onRenderContextMenu = props[name] ?? onRenderContextMenuDefault\n          break\n        case 'onChangeMode':\n          onChangeMode = props[name] ?? onChangeModeDefault\n          break\n        case 'onSelect':\n          onSelect = props[name] ?? onSelectDefault\n          break\n        case 'onError':\n          onError = props[name] ?? onErrorDefault\n          break\n        case 'onFocus':\n          onFocus = props[name] ?? onFocusDefault\n          break\n        case 'onBlur':\n          onBlur = props[name] ?? onBlurDefault\n          break\n\n        default:\n          // We should never reach this default case\n          unknownProperty(name)\n      }\n    }\n\n    if (!queryLanguages.some((queryLanguage) => queryLanguage.id === queryLanguageId)) {\n      queryLanguageId = queryLanguages[0].id\n    }\n\n    function unknownProperty(name: never) {\n      debug(`Unknown property \"${name}\"`)\n    }\n\n    flushSync()\n  }\n\n  export async function destroy() {\n    throw new Error(\n      'class method destroy() is deprecated. ' +\n        'It is replaced with a method destroy() in the vanilla library.'\n    )\n  }\n\n  function handleChange(updatedContent: Content, previousContent: Content, status: OnChangeStatus) {\n    content = updatedContent\n\n    if (onChange) {\n      onChange(updatedContent, previousContent, status)\n    }\n  }\n\n  function handleSelect(updatedSelection: JSONEditorSelection | undefined) {\n    selection = updatedSelection\n\n    if (onSelect) {\n      onSelect(cloneDeep(updatedSelection))\n    }\n  }\n\n  function handleFocus() {\n    hasFocus = true\n    if (onFocus) {\n      onFocus()\n    }\n  }\n\n  function handleBlur() {\n    hasFocus = false\n    if (onBlur) {\n      onBlur()\n    }\n  }\n\n  async function toggleMode(newMode: Mode) {\n    if (mode === newMode) {\n      return\n    }\n\n    mode = newMode\n\n    flushSync()\n    focus()\n\n    onChangeMode(newMode)\n  }\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    debug('handleChangeQueryLanguage', newQueryLanguageId)\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n  }\n\n  // The onTransformModal method is located in JSONEditor to prevent circular references:\n  //     TreeMode -> TransformModal -> TreeMode\n  function onTransformModal({ id, json, rootPath, onTransform, onClose }: TransformModalCallback) {\n    if (readOnly) {\n      return\n    }\n\n    transformModalProps = {\n      id,\n      json,\n      rootPath,\n      indentation,\n      truncateTextSize,\n      escapeControlCharacters,\n      escapeUnicodeCharacters,\n      parser,\n      parseMemoizeOne,\n      validationParser,\n      pathParser,\n      queryLanguages,\n      queryLanguageId,\n      onChangeQueryLanguage: handleChangeQueryLanguage,\n      onRenderValue,\n      onRenderMenu: (items: MenuItem[]) => onRenderMenu(items, { mode, modal: true, readOnly }),\n      onRenderContextMenu: (items: ContextMenuItem[]) =>\n        onRenderContextMenu(items, { mode, modal: true, readOnly, selection }),\n      onClassName,\n      onTransform,\n      onClose\n    }\n  }\n\n  // The onSortModal is positioned here for consistency with TransformModal\n  function onSortModal(props: SortModalCallback) {\n    if (readOnly) {\n      return\n    }\n\n    sortModalProps = props\n  }\n\n  // The onJSONEditorModal method is located in JSONEditor to prevent circular references:\n  //     JSONEditor -> TableMode -> JSONEditorModal -> JSONEditor\n  function onJSONEditorModal({ content, path, onPatch, onClose }: JSONEditorModalCallback) {\n    debug('onJSONEditorModal', { content, path })\n\n    jsonEditorModalProps = {\n      content,\n      path,\n      onPatch,\n\n      readOnly,\n      indentation,\n      tabSize,\n      truncateTextSize,\n      mainMenuBar,\n      navigationBar,\n      statusBar,\n      askToFormat,\n      escapeControlCharacters,\n      escapeUnicodeCharacters,\n      flattenColumns,\n      parser,\n      validator: undefined, // TODO: support partial JSON validation?\n      validationParser,\n      pathParser,\n      onRenderValue,\n      onClassName,\n      onRenderMenu,\n      onRenderContextMenu,\n      onSortModal,\n      onTransformModal,\n      onClose\n    }\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    // prevent browser addons from reacting to keyboard inputs inside the editor\n    // see https://github.com/josdejong/svelte-jsoneditor/issues/512\n    event.stopPropagation()\n  }\n\n  $: debug('mode changed to', mode)\n</script>\n\n<AbsolutePopup>\n  <div class=\"jse-main\" class:jse-focus={hasFocus} on:keydown={handleKeyDown} role=\"none\">\n    {#key instanceId}\n      <JSONEditorRoot\n        bind:this={refJSONEditorRoot}\n        externalMode={mode}\n        {content}\n        {selection}\n        {readOnly}\n        {indentation}\n        {tabSize}\n        {truncateTextSize}\n        {statusBar}\n        {askToFormat}\n        {mainMenuBar}\n        {navigationBar}\n        {escapeControlCharacters}\n        {escapeUnicodeCharacters}\n        {flattenColumns}\n        {parser}\n        {parseMemoizeOne}\n        {validator}\n        {validationParser}\n        {pathParser}\n        insideModal={false}\n        {onError}\n        onChange={handleChange}\n        onChangeMode={toggleMode}\n        onSelect={handleSelect}\n        {onRenderValue}\n        {onClassName}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        {onRenderMenu}\n        {onRenderContextMenu}\n        {onSortModal}\n        {onTransformModal}\n        {onJSONEditorModal}\n      />\n    {/key}\n  </div>\n\n  {#if sortModalProps}\n    <SortModal\n      {...sortModalProps}\n      onClose={() => {\n        sortModalProps?.onClose()\n        sortModalProps = undefined\n      }}\n    />\n  {/if}\n\n  {#if transformModalProps}\n    <TransformModal\n      {...transformModalProps}\n      onClose={() => {\n        transformModalProps?.onClose()\n        transformModalProps = undefined\n      }}\n    />\n  {/if}\n\n  {#if jsonEditorModalProps}\n    <JSONEditorModal\n      {...jsonEditorModalProps}\n      onClose={() => {\n        jsonEditorModalProps?.onClose()\n        jsonEditorModalProps = undefined\n      }}\n    />\n  {/if}\n</AbsolutePopup>\n\n<style src=\"./JSONEditor.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isEmpty } from 'lodash-es'\n  import Select from 'svelte-select'\n  import Header from './Header.svelte'\n  import { getNestedPaths } from '$lib/utils/arrayUtils.js'\n  import { pathToOption, stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { sortJson } from '$lib/logic/sort.js'\n  import { sortModalStates } from './sortModalStates'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, getIn } from 'immutable-json-patch'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { OnSort } from '$lib/types.js'\n  import Modal from './Modal.svelte'\n\n  const debug = createDebug('jsoneditor:SortModal')\n\n  export let id: string\n  export let json: unknown // the whole document\n  export let rootPath: JSONPath\n  export let onSort: OnSort\n  export let onClose: () => void\n\n  $: selectedJson = getIn(json, rootPath)\n  $: jsonIsArray = Array.isArray(selectedJson)\n  $: paths = jsonIsArray ? getNestedPaths(selectedJson) : undefined\n  $: properties = paths ? paths.map(pathToOption) : undefined\n\n  const asc = {\n    value: 1,\n    label: 'ascending'\n  }\n  const desc = {\n    value: -1,\n    label: 'descending'\n  }\n  const directions = [asc, desc]\n\n  const stateId = `${id}:${compileJSONPointer(rootPath)}`\n  let selectedProperty = sortModalStates[stateId]?.selectedProperty\n  let selectedDirection = sortModalStates[stateId]?.selectedDirection || asc\n  let sortError: string | undefined = undefined\n\n  $: {\n    // remember the selected values for the next time we open the SortModal\n    // just in memory, not persisted\n    sortModalStates[stateId] = {\n      selectedProperty,\n      selectedDirection\n    }\n\n    debug('store state in memory', stateId, sortModalStates[stateId])\n  }\n\n  function handleSort() {\n    try {\n      sortError = undefined\n\n      const itemPath: JSONPath = selectedProperty?.value || properties?.[0]?.value || []\n      const direction = selectedDirection?.value\n      const operations = sortJson(json, rootPath, itemPath, direction)\n      if (onSort !== undefined && rootPath !== undefined) {\n        onSort({ operations, rootPath, itemPath, direction })\n      }\n\n      onClose()\n    } catch (err) {\n      sortError = String(err)\n    }\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n</script>\n\n<Modal {onClose} className=\"jse-sort-modal\">\n  <Header title={jsonIsArray ? 'Sort array items' : 'Sort object keys'} {onClose} />\n\n  <div class=\"jse-modal-contents\">\n    <table>\n      <colgroup>\n        <col width=\"25%\" />\n        <col width=\"75%\" />\n      </colgroup>\n      <tbody>\n        <tr>\n          <th>Path</th>\n          <td>\n            <input\n              class=\"jse-path\"\n              type=\"text\"\n              readonly\n              title=\"Selected path\"\n              value={rootPath && !isEmpty(rootPath)\n                ? stringifyJSONPath(rootPath)\n                : '(document root)'}\n            />\n          </td>\n        </tr>\n        {#if jsonIsArray && ((properties && properties?.length > 1) || selectedProperty === undefined)}\n          <tr>\n            <th>Property</th>\n            <td>\n              <Select showChevron items={properties} bind:value={selectedProperty} />\n            </td>\n          </tr>\n        {/if}\n        <tr>\n          <th>Direction</th>\n          <td>\n            <Select\n              showChevron\n              clearable={false}\n              items={directions}\n              bind:value={selectedDirection}\n            />\n          </td>\n        </tr>\n      </tbody>\n    </table>\n\n    <div class=\"jse-space\">\n      {#if sortError}\n        <div class=\"jse-error\">\n          {sortError}\n        </div>\n      {/if}\n    </div>\n\n    <div class=\"jse-actions\">\n      <button\n        type=\"button\"\n        class=\"jse-primary\"\n        on:click={handleSort}\n        use:focus\n        disabled={jsonIsArray && properties && properties?.length > 1 ? !selectedProperty : false}\n      >\n        Sort\n      </button>\n    </div>\n  </div>\n</Modal>\n\n<style src=\"./SortModal.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { flushSync, onMount } from 'svelte'\n  import Header from './Header.svelte'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, immutableJSONPatch, isJSONArray } from 'immutable-json-patch'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type {\n    Content,\n    JSONEditorModalCallback,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPathParser,\n    OnClassName,\n    OnPatch,\n    OnRenderContextMenu,\n    OnRenderMenu,\n    OnRenderValue,\n    OnSortModal,\n    OnTransformModal,\n    Validator\n  } from '$lib/types'\n  import { Mode } from '$lib/types.js'\n  import JSONEditorRoot from '../modes/JSONEditorRoot.svelte'\n  import { noop } from '$lib/utils/noop.js'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { initial, isEmpty, last } from 'lodash-es'\n  import { isJSONContent, toJSONContent } from '$lib/utils/jsonUtils.js'\n  import Icon from 'svelte-awesome'\n  import { faCaretLeft } from '@fortawesome/free-solid-svg-icons'\n  import memoizeOne from 'memoize-one'\n  import { getFocusPath, isJSONSelection } from '$lib/logic/selection.js'\n  import Modal from './Modal.svelte'\n  import AbsolutePopup from './popup/AbsolutePopup.svelte'\n\n  const debug = createDebug('jsoneditor:JSONEditorModal')\n\n  export let content: Content // the nested document\n  export let path: JSONPath\n  export let onPatch: OnPatch\n\n  export let readOnly: boolean\n  export let indentation: number | string\n  export let tabSize: number\n  export let truncateTextSize: number\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n\n  export let onRenderValue: OnRenderValue\n  export let onClassName: OnClassName\n  export let onRenderMenu: OnRenderMenu\n  export let onRenderContextMenu: OnRenderContextMenu\n\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n\n  export let onClose: () => void\n\n  interface ModalState {\n    mode: Mode\n    content: Content\n    selection: JSONEditorSelection | undefined\n    relativePath: JSONPath\n  }\n\n  let refEditor: JSONEditorRoot\n  let fullscreen: boolean\n\n  const rootState: ModalState = {\n    mode: determineMode(content),\n    content,\n    selection: undefined,\n    relativePath: path\n  }\n  let stack: ModalState[] = [rootState]\n\n  $: currentState = last(stack) || rootState\n  $: absolutePath = stack.flatMap((state) => state.relativePath)\n  $: pathDescription = !isEmpty(absolutePath) ? stringifyJSONPath(absolutePath) : '(document root)'\n\n  // not relevant in this Modal setting, but well\n  $: parseMemoizeOne = memoizeOne(parser.parse)\n\n  let error: string | undefined = undefined\n\n  onMount(() => {\n    refEditor?.focus()\n  })\n\n  function determineMode(content: Content): Mode {\n    return isJSONContent(content) && isJSONArray(content.json) ? Mode.table : Mode.tree\n  }\n\n  function scrollToSelection() {\n    const selection: JSONEditorSelection | undefined = last(stack)?.selection\n    if (isJSONSelection(selection)) {\n      refEditor.scrollTo(getFocusPath(selection))\n    }\n  }\n\n  function handleApply() {\n    debug('handleApply')\n\n    if (readOnly) {\n      return\n    }\n\n    try {\n      error = undefined\n\n      const path = currentState.relativePath\n      const content = currentState.content\n      const operations: JSONPatchDocument = [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: toJSONContent(content, parser).json // this can throw an error\n        }\n      ]\n\n      if (stack.length > 1) {\n        const parentContent = stack[stack.length - 2].content\n        const parentJson = toJSONContent(parentContent, parser).json\n        const updatedParentContent = {\n          json: immutableJSONPatch(parentJson, operations)\n        }\n\n        // after successfully updated, remove from the stack and apply the change to the parent\n        const parentState = stack[stack.length - 2] || rootState\n        const updatedParentState: ModalState = { ...parentState, content: updatedParentContent }\n        stack = [...stack.slice(0, stack.length - 2), updatedParentState]\n        flushSync()\n        scrollToSelection()\n      } else {\n        onPatch(operations)\n\n        onClose()\n      }\n    } catch (err) {\n      error = String(err)\n    }\n  }\n\n  function handleClose() {\n    debug('handleClose')\n\n    if (fullscreen) {\n      // exit fullscreen\n      fullscreen = false\n    } else if (stack.length > 1) {\n      // remove the last item from the stack\n      stack = initial(stack)\n      flushSync()\n      refEditor?.focus()\n      scrollToSelection()\n\n      // clear any error from the just closed state\n      error = undefined\n    } else {\n      // this is the first modal, the root state, close the modal\n      onClose()\n    }\n  }\n\n  function handleChange(updatedContent: Content) {\n    debug('handleChange', updatedContent)\n    updateState((state) => ({ ...state, content: updatedContent }))\n  }\n\n  function handleChangeSelection(newSelection: JSONEditorSelection | undefined) {\n    debug('handleChangeSelection', newSelection)\n    updateState((state) => ({ ...state, selection: newSelection }))\n  }\n\n  function handleChangeMode(newMode: Mode) {\n    debug('handleChangeMode', newMode)\n    updateState((state) => ({ ...state, mode: newMode }))\n  }\n\n  function updateState(callback: (state: ModalState) => ModalState) {\n    const state = last(stack) as ModalState\n    const updatedState = callback(state)\n    stack = [...initial(stack), updatedState]\n  }\n\n  function handleError(newError: Error) {\n    error = newError.toString()\n    console.error(newError)\n  }\n\n  function handleJSONEditorModal({ content, path }: JSONEditorModalCallback) {\n    debug('handleJSONEditorModal', { content, path })\n\n    const nestedModalState = {\n      mode: determineMode(content),\n      content,\n      selection: undefined,\n      relativePath: path\n    }\n    stack = [...stack, nestedModalState]\n\n    flushSync()\n    refEditor?.focus()\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n</script>\n\n<Modal onClose={handleClose} className=\"jse-jsoneditor-modal\" {fullscreen}>\n  <div class=\"jse-modal-wrapper\">\n    <AbsolutePopup>\n      <Header\n        title=\"Edit nested content {stack.length > 1 ? ` (${stack.length})` : ''}\"\n        fullScreenButton={true}\n        bind:fullscreen\n        onClose={handleClose}\n      />\n\n      <div class=\"jse-modal-contents\">\n        <div class=\"jse-label\">\n          <div class=\"jse-label-inner\">Path</div>\n        </div>\n        <input\n          class=\"jse-path\"\n          type=\"text\"\n          readonly\n          title=\"Selected path\"\n          value={pathDescription}\n        />\n\n        <div class=\"jse-label\">\n          <div class=\"jse-label-inner\">Contents</div>\n        </div>\n\n        <div class=\"jse-modal-inline-editor\">\n          <JSONEditorRoot\n            bind:this={refEditor}\n            externalMode={currentState.mode}\n            content={currentState.content}\n            selection={currentState.selection}\n            {readOnly}\n            {indentation}\n            {tabSize}\n            {truncateTextSize}\n            {statusBar}\n            {askToFormat}\n            {mainMenuBar}\n            {navigationBar}\n            {escapeControlCharacters}\n            {escapeUnicodeCharacters}\n            {flattenColumns}\n            {parser}\n            {parseMemoizeOne}\n            {validator}\n            {validationParser}\n            {pathParser}\n            insideModal={true}\n            onError={handleError}\n            onChange={handleChange}\n            onChangeMode={handleChangeMode}\n            onSelect={handleChangeSelection}\n            {onRenderValue}\n            {onClassName}\n            onFocus={noop}\n            onBlur={noop}\n            {onRenderMenu}\n            {onRenderContextMenu}\n            {onSortModal}\n            {onTransformModal}\n            onJSONEditorModal={handleJSONEditorModal}\n          />\n        </div>\n\n        <div class=\"jse-actions\">\n          {#if error}\n            <div class=\"jse-error\">\n              {error}\n            </div>\n          {/if}\n\n          {#if stack.length > 1}\n            <button type=\"button\" class=\"jse-secondary\" on:click={handleClose}>\n              <Icon data={faCaretLeft} /> Back\n            </button>\n          {/if}\n          {#if !readOnly}\n            <button type=\"button\" class=\"jse-primary\" on:click={handleApply} use:focus>\n              Apply\n            </button>\n          {:else}\n            <button type=\"button\" class=\"jse-primary\" on:click={handleClose}> Close </button>\n          {/if}\n        </div>\n      </div>\n    </AbsolutePopup>\n  </div>\n</Modal>\n\n<style src=\"./JSONEditorModal.scss\"></style>\n","import JsonEditor from './components/JSONEditor.svelte'\nimport type { JSONEditorPropsOptional } from '$lib/types'\nimport { flushSync, mount, unmount } from 'svelte'\n\n// Note: index.ts exports `JSONEditor`, but we will override this on purpose\n//  since we cannot use it in the vanilla environment starting in Svelte 5.\nexport * from './index'\n\nexport interface CreateJSONEditorProps {\n  target: HTMLDivElement\n  props: JSONEditorPropsOptional\n}\n\nexport { JsonEditor }\n\nexport function createJSONEditor({ target, props }: Parameters<typeof mount>[1]): JsonEditor {\n  const editor = mount(JsonEditor, { target, props })\n\n  editor.destroy = async () => unmount(editor)\n\n  flushSync()\n\n  return editor as JsonEditor\n}\n\n/**\n * @deprecated The constructor \"new JSONEditor(...)\" is deprecated. Please use \"createJSONEditor(...)\" instead.\n */\nexport function JSONEditor({ target, props }: CreateJSONEditorProps) {\n  // TODO: deprecation warning since v1. Remove some day\n  console.warn(\n    'WARNING: the constructor \"new JSONEditor(...)\" is deprecated since v1. ' +\n      'Please use \"createJSONEditor(...)\" instead.'\n  )\n\n  return createJSONEditor({ target, props })\n}\n"],"names":["_window$__svelte","_window$__svelte$v","_window","_window$__svelte2","window","__svelte","v","Set","add","legacy_mode_flag","UNINITIALIZED","Symbol","DEV","BRANCH_EFFECT","ROOT_EFFECT","BOUNDARY_EFFECT","UNOWNED","DISCONNECTED","CLEAN","DIRTY","MAYBE_DIRTY","INERT","DESTROYED","EFFECT_TRANSPARENT","LEGACY_DERIVED_PROP","EFFECT_HAS_DERIVED","EFFECT_IS_UPDATING","STATE_SYMBOL","LEGACY_PROPS","LOADING_ATTR_SYMBOL","is_array","Array","isArray","index_of","prototype","indexOf","array_from","from","define_property","Object","defineProperty","get_descriptor","getOwnPropertyDescriptor","get_descriptors","getOwnPropertyDescriptors","object_prototype","array_prototype","get_prototype_of","getPrototypeOf","is_extensible","isExtensible","is_function","thing","noop","noop$2","run","fn","run_all","arr","i","length","micro_tasks","idle_tasks","run_micro_tasks","tasks","queue_micro_task","queueMicrotask","push","flush_tasks","equals","value","this","safe_not_equal","a","b","not_equal","safe_equals","proxy","prev","sources","Map","is_proxied_array","version","source","reaction","active_reaction","with_parent","result","previous_reaction","set_active_reaction","set","Proxy","_","prop","descriptor","configurable","enumerable","writable","Error","e.state_descriptors_fixed","s","get","undefined","deleteProperty","target","ls","n","Number","isInteger","update_version","receiver","_get_descriptor","exists","Reflect","has","_get_descriptor2","active_effect","_get_descriptor3","other_s","call","ownKeys","own_keys","filter","key","setPrototypeOf","e.state_prototype_fixed","signal","d","arguments","get_proxied_value","_unused","old_values","stack","f","reactions","rv","wv","state","push_reaction_value","mutable_source","initial_value","_component_context$l","_component_context$l$","immutable","component_context","l","mutate","untrack","_reaction_sources","should_proxy","untracking","is_runes","reaction_sources","includes","e.state_unsafe_mutation","internal_set","old_value","is_destroying_effect","increment_write_version","mark_reactions","untracked_writes","set_untracked_writes","update","status","runes","flags","set_signal_status","schedule_effect","derived","DERIVED","parent_derived","ctx","deps","effects","parent","user_derived","derived_safe_equal","destroy_derived_effects","destroy_effect","update_derived","prev_active_effect","set_active_effect","get_derived_parent_effect","update_reaction","execute_derived","skip_reaction","$window","is_firefox","first_child_getter","next_sibling_getter","create_text","document","createTextNode","get_first_child","node","get_next_sibling","child","is_text","first_child","fragment","first","Comment","data","sibling","count","next_sibling","is_throwing_error","is_flushing","last_scheduled_effect","is_updating_effect","set_is_destroying_effect","queued_root_effects","effect","new_deps","skipped_deps","write_version","read_version","captured_signals","check_dirtiness","dependencies","is_unowned","dependency","is_disconnected","is_unowned_connected","_dependency","_dependency2","_dependency2$reaction","handle_error","error","previous_effect","should_rethrow_error","current","_unused2","propagate_error","schedule_possible_effect_self_invalidation","root","_reaction_sources2","previous_deps","previous_skipped_deps","previous_untracked_writes","previous_skip_reaction","previous_reaction_sources","previous_component_context","previous_untracking","set_component_context","remove_reactions","_deps$i","_deps$i$reactions","remove_reaction","index","new_length","pop","start_index","update_effect","was_updating_effect","next","destroy_block_effect_children","destroy_effect_children","execute_effect_teardown","teardown","infinite_loop_guard","e.effect_update_depth_exceeded","flush_queued_root_effects","flush_count","root_effects","flush_queued_effects","process_effects","clear","nodes_start","unlink_effect","is_branch","previous_active_reaction","flushSync","_tick","_asyncToGenerator","Promise","resolve","apply","_reaction_sources3","is_derived","invalidate_inner_signals","captured","previous_captured_signals","capture_signals","dep","STATUS_MASK","deep_read_state","EventTarget","deep_read","visited","Date","getTime","e","proto","descriptors","validate_effect","rune","e.effect_orphan","e.effect_in_unowned_derived","e.effect_in_teardown","create_effect","type","sync","nodes_end","last","transitions","parent_effect","parent_last","push_effect","_derived$effects","user_effect","m","_context$e","context","legacy_pre_effect","token","ran","r1","render_effect","r2","legacy_pre_effect_reset","template_effect","deriveds","map","block","RENDER_EFFECT","branch","previously_destroying_effect","remove_dom","removed","end","remove","transition","stop","pause_effect","callback","pause_children","run_out_transitions","remaining","check","out","local","is_global","resume_effect","resume_children","in","lifecycle_outside_component","name","getContext","get_or_init_context_map","props","p","c","x","u","component","context_stack_item","component_effects","component_effect","_component_context","_component_context$c","context_map","get_parent_context","DELEGATED_EVENTS","ATTRIBUTE_ALIASES","formnovalidate","ismap","nomodule","playsinline","readonly","defaultvalue","defaultchecked","srcobject","novalidate","allowfullscreen","disablepictureinpicture","disableremoteplayback","PASSIVE_EVENTS","is_passive_event","listening_to_form_reset","without_reactive_context","listen_to_event_and_reset_event","element","event","handler","on_reset","addEventListener","__on_r","evt","then","defaultPrevented","elements","_e$__on_r","capture","all_registered_events","root_event_handles","create_event","event_name","dom","options","target_handler","handle_event_propagation","cancelBubble","startsWith","passive","body","removeEventListener","delegate","events","_event$composedPath","handler_element","owner_document","ownerDocument","path","composedPath","current_target","path_idx","handled_at","__root","at_idx","handler_idx","throw_error","other_errors","parent_element","assignedSlot","parentNode","host","delegated","_loop","currentTarget","create_fragment_from_html","html","elem","createElement","innerHTML","content","assign_nodes","start","template","is_fragment","use_import_node","has_start","clone","importNode","cloneNode","lastChild","ns_template","ns","wrapped","concat","createDocumentFragment","appendChild","text","t","comment","frag","createComment","anchor","append","before","set_text","_text$__t","str","__t","nodeValue","mount","Component","_ref2","intro","test","navigator","userAgent","element_prototype","Element","node_prototype","Node","text_prototype","Text","__click","__className","__attributes","__style","__e","init_operations","registered_events","event_handle","document_listeners","unmount","fulfil","outro","component_root","anchor_node","$$events","delete","_anchor_node$parentNo","removeChild","mounted_components","_mount","WeakMap","if_block","root_index","hydrate_index","consequent_effect","alternate_effect","condition","has_branch","set_branch","update_branch","new_condition","key_block","get_key","render_fn","changed","each","get_collection","fallback_fn","items","fallback","was_empty","each_array","collection","array","seen","to_animate","item","is_animated","should_update","matched","stashed","_item$a","measure","_item$a2","update_item","unfix","j","move","link","k","create_item","to_destroy","destroy_length","controlled_anchor","_to_destroy$i$a","_to_destroy$i$a2","fix","items_map","is_controlled","parent_node","textContent","pause_effects","_item$a3","reconcile","dest","next_node","get_value","svg","mathml","skip_warning","_get_value","slot","$$props","slot_props","_$$props$$$slots","slot_fn","$$slots","is_interop","get_component","action","payload","inited","destroy","r","o","clsx","_clsx","whitespace","append_styles","styles","separator","css","to_css_name","toLowerCase","set_class","is_html","hash","prev_classes","next_classes","next_class_name","directives","classname","len","substring","to_class","removeAttribute","className","setAttribute","is_present","classList","toggle","update_styles","priority","style","removeProperty","setProperty","set_style","prev_styles","next_styles","next_style_attr","normal_styles","important_styles","new_style","String","replaceAll","trim","in_str","in_apo","in_comment","reserved_names","keys","name_index","to_style","cssText","CLASS","STYLE","IS_CUSTOM_ELEMENT","IS_HTML","set_value","attributes","get_attributes","nodeName","set_attribute","attribute","get_setters","set_attributes","css_hash","_next$style","is_custom_element","preserve_attribute_case","is_option_element","tagName","class","prev_value","prefix","is_default","setters","_loop2","_key3","__value","namespaceURI","opts","event_handle_key","slice","is_delegated","endsWith","is_capture_event","handle","autofocus","activeElement","focus","Boolean","selected","hasAttribute","set_selected","_ATTRIBUTE_ALIASES$na","normalize_attribute","input","use_default","previous","defaultValue","defaultChecked","checked","_element$__attributes","setters_cache","element_proto","bind_value","is_reset","is_numberlike_input","to_number","selectionStart","selectionEnd","Math","min","bind_prop","desc","select_option","select","mounting","multiple","option","get_option_value","select_options","option_value","is","selectedIndex","bind_select_value","query","querySelectorAll","_select$querySelector","selected_option","querySelector","observer","MutationObserver","observe","childList","subtree","attributeFilter","disconnect","init_select","is_bound_this","bound_value","element_or_component","bind_this","old_parts","parts","stopPropagation","_len3","args","_key5","preventDefault","_len4","_key6","init","callbacks","observe_all","fns","reactive_import","bubble_event","_$$props$$$events","onMount","init_update_callbacks","cleanup","onDestroy","createEventDispatcher","active_component_context","detail","_active_component_con","bubbles","cancelable","CustomEvent","create_custom_event","beforeUpdate","e.lifecycle_legacy_only","_l$u","is_store_binding","legacy_rest_props_handler","exclude","special","legacy_rest_props","spread_props_handler","spread_props","_len5","_key7","has_destroyed_component_ctx","current_value","_current_value$ctx$d","_current_value$ctx","_get_descriptor$set","_get_descriptor4","prop_value","bindable","lazy","is_store_sub","previous_is_store_binding","capture_store_binding","getter","is_entry_props","setter","fallback_value","fallback_dirty","fallback_used","get_fallback","e.props_invalid_value","derived_getter","legacy_parent","$$legacy","mutation","from_child","was_from_child","inner_current_value","parent_value","child_value","new_value","createDebug","namespace","enabled","debug","localStorage","_unused3","tryReadLocalStorage","enableDebug","color","charCodeAt","colors","abs","selectColor","_len6","_key8","console","log","id","uniqueId","int","parseInt","containsNumber","NUMBER_REGEX","isObject","constructor","isObjectOrArray","isBoolean","isTimestamp","isFinite","floor","isNaN","valueOf","_unused4","getColorCSS","colorTestDiv","applied","replace","isColor","valueType","parser","valueStr","stringify","isUrlRegex","isUrl","stringConvert","strTrim","parse","INTEGER_REGEX","ROOT_PATH","strictShallowEqual","getNestedPaths","includeObjects","pointersMap","TypeError","recurseNestedPaths","obj","compileJSONPointer","forEach","max","sort","parseJSONPointer","forEachIndex","iteratee","limit","arrayToObject","_objectSpread","objectToArray","object","values","moveItems","offset","copy","moving","splice","insertItemsAt","parseAndRepair","jsonText","_unused5","jsonrepair","parseAndRepairOrUndefined","partialJson","_unused6","parsePartialJson","END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX","_unused7","_unused8","_unused9","repairPartialJson","_unused10","repaired","_unused11","_unused12","normalizeJsonParseError","parseErrorMessage","positionMatch","POSITION_REGEX","exec","position","line","character","charAt","countCharacterOccurrences","column","lastIndexOf","message","lineMatch","LINE_REGEX","lineOneBased","columnMatch","COLUMN_REGEX","columnOneBased","calculatePosition","validateContentType","json","isContent","isTextContent","isJSONContent","toTextContent","indentation","JSON","toJSONContent","getText","isLargeContent","maxSize","estimateSerializedSize","Infinity","estimatedSize","recurse","isEqualParser","Mode","SelectionType","CaretType","ValidationSeverity","SearchField","SortDirection","UpdateSelectionAfterChange","DELIMITER_WITHOUT_SPACING_REGEX","createNormalizationFunctions","_ref3","escapeControlCharacters","escapeUnicodeCharacters","normalizeControlAndUnicode","normalizeControl","normalizeUnicode","normalizeNothing","escapeValue","jsonEscapeUnicode","jsonEscapeControl","unescapeValue","jsonUnescapeControl","jsonUnescapeUnicode","_x$codePointAt","codePointAt","toString","unescaped","controlCharacters","_unused15","escapedControlCharacters","addNewLineSuffix","isChildOfNodeName","isChildOf","toUpperCase","isChildOfAttribute","getAttribute","predicate","findParent","getWindow","_element$ownerDocumen","_element$ownerDocumen2","defaultView","activeElementIsChildOf","findParentWithNodeName","getSelectionTypeFromTarget","inside","after","multi","encodeDataPath","encodeURIComponent","getDataPathFromTarget","_parent$getAttribute","dataPath","decodeURIComponent","findNearestElement","_ref4","allElements","currentElement","direction","hasPrio","margin","all","rect","getBoundingClientRect","width","height","calculateCenter","left","y","top","distance","weightY","diffX","diffY","sqrt","distanceToCurrent","candidate","candidatesLeft","button","isLeft","isRight","right","candidatesLeftOnRow","isOnSameRow","nearest","minBy","candidates","isAbove","isBelow","prioCandidates","isMacDevice","_ref5","_navigator$platform$t","_navigator","_navigator2","platform","userAgentData","keyComboFromEvent","combi","isCtrlKeyDown","altKey","shiftKey","keyName","metaKeys","join","isMac","ctrlKey","metaKey","Ctrl","Command","Control","Alt","Option","Shift","styleInject","ref","insertAt","head","getElementsByTagName","firstChild","insertBefore","styleSheet","popup","$.prop","closeAbsolutePopup","refRootPopup","$.mutable_source","refHiddenInput","closeWhenOutside","closeOnOuterClick","$.get","handleKeyDown","$.bind_this","$$value","$.set","$.component","$$anchor","$$component","$.spread_props","rootRect","positionAbove","positionLeft","offsetTop","offsetLeft","bottom","innerHeight","innerWidth","calculateStyle","$$render","consequent","div","popups","popupId","popupIndex","findIndex","onClose","openAbsolutePopup","$.each","findUniqueName","keysSet","nameWithoutCopySuffix","validName","truncate","maxLength","maxTextLength","ellipsis","parseString","lower","num","numFloat","parseFloat","jsonQueryLanguage","_json","queryOptions","projection","queryFunctions","relation","operator","paths","executeQuery","jsonquery","cursor","raw","getRaw","rawData","ids","match","rawId","pointerId","iconData","scale","spin","inverse","pulse","flip","label","combinedStyle","box","normalisedScale","numScale","warn","calculateRatio","iconName","icon","normaliseData","combined","size","_className","$$restProps","_get2","$.index","_get3","polygons","polygon","_get4","readOnly","onPatch","expression","$.derived_safe_equal","faCheckSquare","faSquare","$.set_attribute","op","onChange","showOnTop","destroyColorPicker","_yield$import","colorPicker","import","default","onDone","hex","rgba","show","title","_get5","_getWindow$1$innerHei","_getWindow$","ColorPickerPopup","MAX_SEARCH_RESULTS","ARRAY_SECTION_SIZE","MAX_CHARACTERS_TEXT_PREVIEW","DEFAULT_VISIBLE_SECTIONS","MAX_AUTO_REPAIRABLE_SIZE","MAX_DOCUMENT_SIZE_TEXT_MODE","INSERT_EXPLANATION","CONTEXT_MENU_EXPLANATION","HOVER_INSERT_INSIDE","HOVER_INSERT_AFTER","HOVER_COLLECTION","JSON_STATUS_VALID","JSON_STATUS_REPAIRABLE","CONTEXT_MENU_HEIGHT","CONTEXT_MENU_WIDTH","SEARCH_BOX_HEIGHT","SORT_DIRECTION_NAMES","asc","mergeSections","sections","sortedSections","sortBy","section","mergedSections","sortedIndex","mergedIndex","nextRoundNumber","currentRoundNumber","isMenuSpace","isMenuSeparator","isMenuLabel","isMenuButton","isMenuDropDownButton","isContextMenuRow","isContextMenuColumn","isContentParseError","contentErrors","isContentValidationErrors","isValidationError","isNestedValidationError","isChildError","isSvelteComponentRenderer","isSvelteActionRenderer","isObjectRecursiveState","isArrayRecursiveState","isValueRecursiveState","isExpandableState","hasSearchResults","searchResults","isTreeHistoryItem","historyItem","isTextHistoryItem","isModeHistoryItem","createDocumentState","_ref8","expand","documentState","_ref7","factory","createArrayDocumentState","createObjectDocumentState","createValueDocumentState","createRecursiveState","documentStateFactory","expandPath","expanded","visibleSections","properties","ensureRecursiveState","_ref9","arrayState","itemState","setIn","objectState","syncDocumentState","_transformDocumentState","nestedJson","nestedState","updatedState","forEachVisibleIndex","itemPath","updatedItem","propPath","updatedProp","jsonArray","_ref10","toRecursiveStatePath","recursiveStatePath","partialPath","updateInDocumentState","some","inVisibleSection","newVisibleSection","expandVisibleSection","_loop3","nestedValue","nestedPath","_expandRecursively","collapsePath","recursive","_collapse","_collapseRecursively","documentStatePatch","operations","initial","reduce","operation","immutableJSONPatch","_documentStatePatch","isJSONPatchAdd","documentStateAdd","isJSONPatchRemove","documentStateRemove","isJSONPatchReplace","parsePath","enforceString","getEnforceString","setInDocumentState","isJSONPatchCopy","isJSONPatchMove","stateValue","getInRecursiveState","documentStateMoveOrCopy","getIn","_unused16","updateInRecursiveState","transform","ensuredState","updateIn","recursiveState","setInRecursiveState","_parent","shiftVisibleSections","parentPath","recursivePath","existsIn","deleteIn","deleteInDocumentState","merged","mergeAdjacentSections","getNextKeys","includeKey","getVisiblePaths","_recurse","isJSONArray","isJSONObject","getVisibleCaretPositions","includeInside","valueState","propertyPath","getNextVisiblePath","visiblePaths","expandSmart","expandMinimal","expandAll","expandSmartIfCollapsed","relativePath","expandSelf","expandNone","isAfterSelection","selection","isInsideSelection","isKeySelection","isValueSelection","isMultiSelection","isMultiSelectionWithOneItem","isEqual","focusPath","anchorPath","isJSONSelection","isTextSelection","getSelectionPaths","getAnchorPath","getFocusPath","sharedPath","findSharedPath","createMultiSelection","startPath","getStartPath","endPath","getEndPath","startIndex","getChildIndex","endIndex","iterateOverSelection","getParentPath","anchorIndex","getSelectionUp","keepAnchorPath","previousPath","visiblePathPointers","pathPointer","getPreviousVisiblePath","createValueSelection","isEmpty","createKeySelection","findCaretAndSiblings","caret","visibleCaretPositions","getInitialSelection","createSelectionFromOperations","every","firstOp","otherOps","path1","path2","singleItemSelected","findRootPath","pathStartsWith","removeEditModeFromSelection","isEditingSelection","createEditKeySelection","initialValue","edit","createEditValueSelection","createInsideSelection","createAfterSelection","isParent","selectionToPartialJson","hasSelectionContents","canConvert","fromCaretPosition","caretPosition","fromSelectionType","selectionType","selectionIfOverlapping","pathInSelection","pathIndex","classnames","classes","_len7","_key9","arg","hasOwnProperty","getValueClass","mode","table","shortText","onCancel","onFind","onPaste","onValueClass","domValue","valueClass","closed","getDomValue","removeNewLineSuffix","innerText","setDomValue","updatedValue","$.mutate","range","createRange","getSelection","setStart","collapse","removeAllRanges","addRange","setCursorToEnd","newValue","no","$.clsx","combo","nextInside","clipboardData","clipboardText","getData","hasFocus","self","normalization","onPasteJson","onSelect","findNextInside","convert","handleCancelChange","expression_1","updateSelection","patchedState","patchedSelection","pastedText","pastedJson","contents","onPasteAsJson","patchedJson","_unused17","entry","afterKey","nextKeys","newProp","moveDown","rename","oldKey","newKey","newKeyUnique","duplicate","lastPath","beforeKey","extract","insert","clipboard","_unused18","newValues","clipboardToValues","firstPath","removeAll","removeKeys","filteredKeys","nextKey","firstKey","reverse","textIsObject","textIsArray","clipboardOriginal","clipboardRepaired","createRemoveOperations","newSelection","previousKey","revertJSONPatchWithMoveOperations","comparator","dedupeKeepLast","revertJSONPatch","revertOperations","createRevertMoveOperations","searchNext","searchResult","nextActiveIndex","activeIndex","nextActiveItem","active","activeItem","search","searchText","_options$maxResults","searchTextLowerCase","maxResults","columns","results","onMatch","searchRecursive","level","findCaseInsensitiveMatches","field","textLower","fieldIndex","replaceText","replacementText","replaceAllText","occurrences","updatedText","forEachRight","occurrence","createSearchAndReplaceOperations","searchResultItem","currentValue","currentValueText","getSearchResultPath","searchResultsFactory","toRecursiveSearchResults","searchResultItems","updateInSearchResults","flattenSearchResults","_node$searchResults","nested","flatMap","matches","previousEnd","precedingText","resultIndex","matchingText","lastMatch","splitValue","part","$.template_effect","$.set_text","text_1","alternate","formatSize","kilo","factor","toFixed","KB","MB","GB","handleClick","$.derived","_get6","$$args","get_snippet","_len","_key2","snippet_effect","snippet","handleValueClick","valueIsUrl","open","handleValueDoubleClick","doTruncate","isTruncated","truncateTextSize","truncatedValue","handleShowMore","$0","consequent_1","tooltip","_ref11","handleMouseEnter","Tooltip","handleMouseLeave","absolutePopupContext","faClock","renderValue","renderers","isEditing","BooleanToggle","ColorPicker","EditableValue","ReadonlyValue","TimestampTag","stringifyJSONPath","integerNumberRegex","escapeQuotes","parseJSONPath","pathStr","parseProp","eatCharacter","isEnd","unescape","char","SyntaxError","pathToOption","stringifyLodashProperty","javaScriptPropertyRegex","propStr","createPropertySelector","transformModalStates","transformModalStateShared","showWizard","showOriginal","round","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","evaluate","param","getSide","placement","split","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getOppositeAlignmentPlacement","alignment","getOppositePlacement","side","getPaddingObject","padding","expandPaddingObject","rectToClientRect","computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","computePosition","_ref12","config","strategy","middleware","validMiddleware","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","nextX","nextY","reset","initialPlacement","_x","_x2","_x3","detectOverflow","_x4","_x5","_detectOverflow","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","_convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","hasWindow","getNodeName","isNode","_node$ownerDocument","documentElement","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","overflow","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","isContainingBlock","elementOrCss","webkit","isWebKit","containerType","backdropFilter","willChange","contain","CSS","supports","isLastTraversableNode","getNodeScroll","scrollLeft","scrollTop","scrollX","scrollY","getParentNode","getNearestOverflowAncestor","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","visualViewport","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","noOffsets","getVisualOffsets","includeScale","isFixedStrategy","clientRect","visualOffsets","isFixed","floatingOffsetParent","shouldAddVisualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","getWindowScrollBarX","leftScroll","getHTMLOffset","scroll","ignoreScrollbarX","htmlRect","getClientRectFromClippingAncestor","clippingAncestor","clientWidth","clientHeight","visualViewportBased","getViewportRect","scrollWidth","scrollHeight","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","offsetRect","htmlOffset","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","svgOffsetParent","currentNode","getContainingBlock","topLayer","clippingAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingElementAncestors","_c","firstClippingAncestor","clippingRect","accRect","_ref13","getOffsetParentFn","getDimensionsFn","getDimensions","floatingDimensions","_x8","getClientRects","rectsAreEqual","autoUpdate","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","frameId","cleanupIo","onMove","timeoutId","io","_io","clearTimeout","refresh","skip","threshold","elementRectForRootMargin","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","observeMove","reobserveFrame","resizeObserver","firstEntry","unobserve","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","_middlewareData$offse","_middlewareData$arrow","diffCoords","_x6","_x7","convertValueToCoords","arrow","alignmentOffset","shift","_evaluate2","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","_objectWithoutProperties","_excluded2","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","_middlewareData$flip","_evaluate","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","_excluded","initialSideAxis","isBasePlacement","oppositePlacement","getExpandedPlacements","hasFallbackAxisSideDirection","isStart","lr","rl","getSideList","getOppositeAxisPlacements","placements","overflows","overflowsData","sides","mainAlignmentSide","getAlignmentSides","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","_overflowsData$filter2","currentSideAxis","acc","createFloatingActions","initOptions","referenceElement","floatingElement","defaultOptions","getOptions","mixin","updatePosition","updateOptions","mergedOptions","platformWithCache","computePosition$1","_options","assign","onComputed","setupVirtualElementObserver","subscribe","$node","contentAction","contentOptions","autoUpdateDestroy","destroyAutoUpdate","initAutoUpdate","tick","_autoUpdate","_ref14","loadOptions","filterText","itemId","groupBy","filterSelectedItems","itemFilter","convertStringItemsToObjects","filterGroupedItems","filterResults","matchesFilter","getItems","_x9","_getItems","_ref15","dispatch","res","catch","err","details","cancelled","filteredItems","loading","focused","listOpen","sanitized","children","timeout","justValue","_filter","container","multiFullItemClearable","disabled","placeholder","placeholderAlwaysShow","groupFilter","groups","groupHeaderSelectable","containerStyles","hasError","required","closeListOnChange","clearFilterTextOnBlur","createGroupHeaderItem","groupValue","getFilteredItems","searchable","inputStyles","clearable","debounce","wait","debounceWait","hideEmptyState","inputAttributes","listAutoWidth","showChevron","listOffset","hoverItemIndex","floatingConfig","containerClasses","activeValue","prev_filterText","prev_multiple","_inputAttributes","_items","groupValues","groupHeader","selectable","groupItem","sortedGroupedItems","checkHoverSelectable","startingIndex","ignoreGroup","setHoverIndex","checkValueForDuplicates","noDuplicates","uniqueValues","val","findItem","matchTo","find","handleMultiItemClear","_x10","_handleMultiItemClear","itemToRemove","closeList","hoverItem","handleSelect","handleFocus","_document","_input","handleBlur","_x11","_handleBlur","_input2","isScrolling","blur","handleClear","ariaValues","ariaListOpen","ariaFocused","isScrollingTimer","handleListScroll","_get8","itemSelected","handleHover","increment","hasOwn","hover","isItemActive","activeScroll","scrollAction","hoverScroll","scrollIntoView","behavior","_floatingConfig","floatingRef","floatingContent","floatingUpdate","prefloat","setValue","autocapitalize","autocomplete","autocorrect","spellcheck","tabindex","hasValue","hideSelectedItem","showClear","placeholderText","_value5","_multiple","ariaSelection","ariaContext","_item","handleAriaContent","updateValueDisplay","handleFilterEvent","listDom","listMounted","setListWidth","scrollToHoverItem","_floatingConfig2","_get7","contains","_get9","itemIndex","_get10","$.event","div_2","$.stopPropagation","isItemSelectable","handleItemClick","consequent_3","consequent_2","alternate_1","consequent_4","div_1","consequent_5","consequent_6","text_3","div_8","$.preventDefault","ClearIcon","consequent_7","text_4","consequent_8","alternate_2","consequent_9","input_1","consequent_10","consequent_11","consequent_12","consequent_13","_containerClasses","filterRelationOptions","sortDirectionOptions","filterPath","_queryOptions","filterRelation","_filterRelationOption","_queryOptions$filter","filterValue","_queryOptions2","sortPath","_queryOptions3","sortDirection","_sortDirectionOptions","_queryOptions$sort","jsonIsArray","pathsIncludingObjects","fieldOptions","projectionOptions","projectionPaths","_queryOptions10","_queryOptions4","_get11","_queryOptions5","_get12","_queryOptions6","_queryOptions7","_get13","_queryOptions8","_get14","_queryOptions9","changeProjectionPaths","$.bind_value","queryLanguages","queryLanguageId","onChangeQueryLanguage","queryLanguage","_get$name","handleChangeQueryLanguage","newQueryLanguageId","fullScreenButton","fullscreen","faDownLeftAndUpRightToCenter","faUpRightAndDownLeftFromCenter","faTimes","_onClose","createAutoScrollHandler","scrollableElement","autoScrollSpeed","autoScrollTimer","calculateSpeed","diff","autoScrollCallback","startAutoScroll","speed","stopAutoScroll","setInterval","clearInterval","onDrag","clientY","onDragEnd","easeInOutQuad","createJump","easing","a11y","duration","timeStart","timeElapsed","scrolling","scrollTo","loop","timeCurrent","done","onDuration","now","validationErrorsFactory","updateInValidationErrors","errors","validateJSON","validator","validationParser","validateText","validationErrors","severity","info","convertedJSON","isRepairable","_unused19","canAutoRepair","parseError","createFocusTracker","_ref18","blurTimeoutHandle","onFocus","onBlur","handleFocusIn","newFocus","handleFocusOut","actions","onClick","_get$text","onMouseDown","_type","_message","selectError","node_2","validationError","faExclamationTriangle","faAngleDown","$.set_class","tr","_get$severity","text_2","faAngleRight","_get15","getMaxSeverity","warning","onEscape","dialog","close","showModal","dialog_1","_len2","_key4","ctrl","_onClose2","node_1","_get$className","_get$onClick","unknownMenuItem","onParse","onRepair","onApply","domTextArea","goToError","setSelectionRange","handleApply","handleRepair","_unused21","getErrorMessage","repairable","_unused20","gotoAction","faArrowDown","repairAction","faWrench","errorActions","successActions","faCheck","textarea","repairedText","handleCancel","sectionIndex","total","onExpandSection","visibleSection","getJson","expandItemsSections","section1","start2","section2","currentIndex","previousIndex","section3","showSection2","getExpandItemsSections","expandItemsSection","_get$start","_get$end","_get16","_get17","onContextMenu","faCaretDown","buttonElem","showTip","onRenderValue","renderer","$.action","$$node","$$action_arg","_get18","singleton","selecting","selectionAnchor","selectionAnchorType","selectionFocus","dragging","onMoveSelection","_ref19","deltaY","updatedSelection","dragInsideAction","_ref20","initialPath","initialIndex","prevHeight","_items2","cumulativeHeight","beforePath","findSwapPathUp","_ref21","_items$beforeIndex","nextHeight","_items3","beforeIndex","findSwapPathDown","startKey","endKey","toKey","toIndex","times","moveInsideParent","_ref22","_items4","_items5","createUpdatedArraySelection","onExpand","_onExpand","_validationError$seve","pointer","onDragSelectionStart","hoverTimer","isNodeSelected","toggleExpand","handleExpand","handleUpdateKey","handleMouseMoveGlobal","handleMouseUpGlobal","$$_import_singleton","findContentTop","_context$findElement","findElement","calculateDeltaY","contentOffset","initialContentTop","initialClientY","handleDragSelectionStart","selectionParentPath","addHeight","currentSection","getVisibleItemsWithHeights","selectionStartIndex","initialTarget","selectionItemsCount","didMoveItems","handleDragSelection","handleDragSelectionEnd","handleInsertInside","handleInsertAfter","handleInsertInsideOpenContextMenu","contextMenuProps","handleInsertAfterOpenContextMenu","_validationErrors","faCaretRight","_value$length","_ref23","_value$length2","_ref24","node_15","indices","gutterIndex","nestedValidationErrors","nestedSelection","appendToJSONPointer","expression_4","alternate_4","alternate_5","consequent_14","consequent_15","consequent_17","consequent_16","alternate_6","consequent_18","getKeys","propPointer","nestedSearchResults","expression_7","filterKeySearchResults","filtered","onUpdateKey","handleKeyDoubleClick","isEditingKey","handleChangeValue","updatedKey","updatedPath","isKeySelected","expression_2","consequent_19","consequent_20","consequent_22","expression_9","filterValueSearchResults","consequent_23","consequent_24","consequent_25","consequent_21","alternate_7","alternate_3","consequent_26","$.set_style","onClassName","buttons","contentEditable","anchorType","getDocumentState","fullSelection","lastCaretPosition","empty","faJSONEditorExpand","faJSONEditorCollapse","faJSONEditorFormat","faJSONEditorCompact","handleCreateObject","handleCreateArray","caseInsensitiveNaturalCompare","aLower","bLower","naturalCompare","sortJson","rootPath","valueA","valueB","createObjectComparator","sortArray","sortedKeys","keyA","keyB","sortedObject","sortObjectKeys","selectedItem","refNavigationBarItem","handleSelectItem","button_1","NavigationBarDropdown","copyToClipBoard","_document$queryComman","_document2","writeText","queryCommandSupported","opacity","execCommand","pathParser","onError","pathExists","inputRef","inputPath","validationActive","copiedTimer","copied","parseAndValidate","validatePathExists","inputValidationError","faCopy","refNavigationBar","editing","handleCloseEditor","handleChangePath","hasNextItem","faClose","faEdit","showSearch","showReplace","onSearch","appliedText","searching","applyChangedSearchTextDebounced","_x13","_applyChangedSearchText","applyChangedJsonDebounced","_x14","_applyChangedJson","toggleShowReplace","flush","handleNext","handlePrevious","handleReplace","handleClose","handleReplaceKeyDown","handlePaste","_handlePaste","_handleReplace","_get22","handleReplaceAll","_handleReplaceAll","deduplicatedMatches","previousItem","lastNewSelection","allOperations","createSearchAndReplaceAllOperations","initSearchInput","_handleNext","_handlePrevious","previousActiveIndex","previousActiveItem","searchPrevious","_handleFocus","_get23","_applyChangedShowSearch","applySearch","_x15","_x16","_x17","_applySearch","newResultItems","previousResult","activePath","matchingActiveIndex","updateSearchResult","cancel","resultCount","_get19","_get20","formattedResultCount","_x12","applyChangedShowSearch","faCircleNotch","faSearch","$.effect","faChevronDown","faChevronUp","_ref25","_get21","endOfPath","getColumns","flatten","maxSampleCount","step","forEachSample","_recurseObject","_collectPaths","valueMerged","calculateVisibleSection","viewPortHeight","itemHeights","defaultItemHeight","searchBoxOffset","itemCount","averageItemHeight","calculateAverageItemHeight","viewPortTop","viewPortBottom","getItemHeight","startHeight","visibleHeight","endHeight","visibleItems","calculateAbsolutePosition","rowIndex","toTableCellPosition","columnIndex","fromTableCellPosition","groupValidationErrors","arrayErrors","rootErrors","partition","errorsByRow","findRowIndex","groupedErrorsByRow","mapValues","groupByRow","row","findColumnIndex","rows","mergeValidationErrors","clearSortedColumnWhenAffectedByOperations","sortedColumn","columms","mustBeCleared","selectedColumnIndex","operationAffectsSortedColumn","onCut","_x18","_onCut","_ref26","copyToClipboard","onCopy","_x19","_onCopy","_ref27","_ref28","onChangeText","openRepairModal","doPaste","_unused22","ensureSelection","onRemove","_ref29","keepSelection","removeSelection","patchResult","onInsert","_ref34","insertType","selectInside","onReplaceJson","jsonExample","cloneDeepWith","createNewValue","onInsertCharacter","_x20","_onInsertCharacter","_ref35","_x21","_onInsertValueWithCharacter","onInsertValueWithCharacter","_ref36","truncated","onRequestClose","visible","allItemsDisabled","_get$text2","_width3","wasVisible","main","_item$main$text","tip","refContextMenu","firstEnabledButton","directionByCombo","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","rowItem","columnItem","alternate_9","alternate_8","alternate_11","alternate_10","faLightbulb","refSelect","bindValue","applyFocus","option_1_value","option_1","$.bind_select_value","getJSONSchemaOptions","schema","schemaDefinitions","schemaForPath","findSchema","composite","enum","findEnum","topLevelSchema","currentSchema","nextPath","possibleSchemas","subSchemas","oneOf","anyOf","allOf","$ref","_ref$match","schemaUrl","referencedSchema","auxNextPath","refPath","segment","patternProperties","additionalProperties","renderJSONSchemaEnum","enumValues","enumValue","optionsWithValue","EnumValue","createAjvValidator","createValidateFunction","createAjvInstance","compile","createAjvValidatorAsync","_x22","_createAjvValidatorAsync","ajv","compileAsync","_options$onCreateAjv","_options$onCreateAjv2","ajvOptions","AjvDist","allErrors","verbose","$data","addSchema","onCreateAjv","ajvValidator","_ajvValidator$errors","improveAjvError","ajvError","_ajvError$message","_options$errorSeverit","instancePath","errorSeverity","normalizeAjvError","keyword","enums","more","params","additionalProperty","jmespathQueryLanguage","description","examplePath","exampleValue","filterValueStr","stringifyPathForJmespath","stringifyProp","preprocessedJson","stringifyAndParse","jmespath","jsonpathQueryLanguage","pathToString","output","JSONPathPlus","lettersOnlyRegex","lodashQueryLanguage","queryParts","actualValueGetter","isSafeInteger","createLodashPropertySelector","_query$match","_query$match2","chainCount","valueCount","validate","Function","queryFn","javascriptQueryLanguage","createQuery","onResize","isSSR","sortModalId","transformModalId","refContents","refJsonEditor","jump","externalContent","externalSelection","history","mainMenuBar","navigationBar","parseMemoizeOne","onChangeMode","onUndo","onRedo","onRenderMenu","onRenderContextMenu","onSortModal","onTransformModal","onJSONEditorModal","modalOpen","copyPasteModalOpen","jsonRepairModalProps","documentStateInitialized","searchResultDetails","handleSearch","handleFocusSearch","_x23","_x24","_handleFocusSearch","findSearchResult","handleCloseSearch","handleSelectValidationError","isSelectionInsidePath","textIsRepaired","validationErrorList","memoizedValidate","memoizeOne","updateValidationErrors","newValidationErrorList","toRecursiveValidationErrors","applyExternalContent","updatedContent","updatedJson","isChanged","currentlyText","previousState","expandWhenNotInitialized","clearSelectionWhenNotExisting","addHistoryItem","applyExternalJson","_unused23","applyExternalText","canPatch","undo","patch","redo","afterPatch","_createSelectionFromO","previousJson","patched","handleEditKey","handleEditValue","openJSONEditorModal","handleToggleEnforceString","handlePatch","acceptAutoRepair","handleReplaceJson","handleCut","_handleCut","indent","handleCopy","_handleCopy","_event$clipboardData","_paste","handlePasteFromMenu","_handlePasteFromMenu","readText","handleChangeText","handleRemove","handleDuplicate","handleExtract","handleInsert","handleInsertFromContextMenu","handleConvert","convertedValue","parsedValue","_unused13","_unused14","convertValue","handleInsertBefore","selectionBefore","handleContextMenu","handleInsertCharacter","_x25","_handleInsertCharacter","handleUndo","canUndo","previousContent","emitOnChange","scrollToWhenVisible","handleRedo","canRedo","openSortModal","_onSort","onSort","_ref38","_x26","handleSortSelection","handleSortAll","openTransformModal","onTransform","transformedJson","handleTransformSelection","handleTransformAll","_x27","_scrollTo","viewPortRect","elemRect","_get$querySelector","_get24","_get$querySelector2","_get25","elemHeight","_onChange","_onChange2","_unused24","handleExpandAll","handleCollapseAll","openFind","findAndReplace","handleExpandSection","_value","expandSection","handlePasteJson","newPastedJson","openContextMenu","_ref39","_onRenderContextMenu","defaultItems","_ref37","onEditKey","onEditValue","onToggleEnforceString","onDuplicate","onExtract","onInsertBefore","onConvert","onInsertAfter","hasJson","hasSelection","rootSelected","focusValue","editValueText","canEditKey","canEditValue","canEnforceString","canCut","canCopy","canPaste","canDuplicate","canExtract","convertMode","insertOrConvertText","canInsertOrConvertStructure","canInsertOrConvertObject","canInsertOrConvertArray","canInsertOrConvertValue","handleInsertOrConvert","faPen","faCut","faPaste","faClone","faCropAlt","faSortAmountDownAlt","faFilter","faTrashCan","faArrowRightArrowLeft","faPlus","faCaretSquareUp","faCaretSquareDown","createTreeContextMenuItems","ContextMenu","clientX","_get26","_get27","handleContextMenuFromTreeMenu","handleParsePastedJson","_handleParsePastedJson","handleClearPastedJson","handleRequestRepair","handleNavigationBarSelect","childPath","nextPathInside","getSelectionNextInside","handleDrag","autoScrollHandler","handleDragEnd","overflowAnchor","applySearchBoxSpacing","applyExternalSelection","tree","onExpandAll","onCollapseAll","handleToggleSearch","expandMenuItem","collapseMenuItem","searchMenuItem","faEllipsisV","faUndo","faRedo","onCreateObject","onCreateArray","faCode","_get28","collapsedState","nextPathAfter","getSelectionDown","getSelectionLeft","getSelectionRight","isContentEditable","readonlyProxy","property","createHistoryInstance","maxItems","reverseItems","handleChange","refQueryInput","updatedHistory","selectedJson","selectedContent","stateId","_$$_import_transformM","$$_import_transformModalStateShared","_state$queryOptions","isManual","_state$isManual","queryError","previewError","previewContent","getSelectedQueryLanguage","_queryLanguages$find","updateQueryByWizard","newQueryOptions","handleChangeQuery","_get29","previewTransformDebounced","previewJson","jsonTransformed","handleTransform","toggleShowWizard","toggleShowOriginal","handleEscape","refConfigButton","openConfig","SelectQueryLanguage","faCog","highlightStyle","HighlightStyle","define","tag","tags","propertyName","number","bool","string","highlighter","syntaxHighlighting","originalStyle","wrappedLineIndent","ViewPlugin","fromClass","view","indentUnit","getIndentUnit","initialPaddingLeft","isChrome","generate","docChanged","viewportChanged","builder","RangeSetBuilder","addStyleToBuilder","requestMeasure","read","lineElement","contentDOM","getPropertyValue","decorations","finish","visibleLines","getVisibleLines","numColumns","containsTab","tabSize","paddingValue","textIndentValue","Decoration","lines","lastLine","to","visibleRanges","pos","doc","lineAt","cols","statusBar","askToFormat","formatCompactKeyBinding","handleFormat","handleCompact","codeMirrorView","codeMirrorRef","domTextMode","editorState","acceptTooLarge","askToFormatApplied","linterCompartment","Compartment","readOnlyCompartment","indentCompartment","tabSizeCompartment","themeCompartment","historyAnnotation","Annotation","historyUpdatesQueue","startState","endState","mergedChanges","changes","change","compose","invert","toJSON","toTextSelection","previousEscapeUnicodeCharacters","_ref43","initialText","ranges","isValidSelection","fromTextSelection","EditorState","create","extensions","keymap","of","indentWithTab","createLinter","lintGutter","lineNumbers","highlightActiveLineGutter","highlightSpecialChars","foldGutter","drawSelection","dropCursor","allowMultipleSelections","indentOnInput","defaultHighlightStyle","bracketMatching","closeBrackets","autocompletion","rectangularSelection","crosshairCursor","highlightActiveLine","highlightSelectionMatches","closeBracketsKeymap","defaultKeymap","searchKeymap","mac","foldKeymap","completionKeymap","lintKeymap","indentationMarkers","hideFirstIndent","EditorView","domEventHandlers","dblclick","handleDoubleClick","updateListener","transactions","transaction","annotation","onChangeCodeMirrorValueDebounced","selectionSet","emitOnSelect","jsonLang","lineWrapping","createIndent","theme","dark","hasDarkTheme","createCodeMirrorView","disableTextEditor","emitChange","setCodeMirrorContent","jsonStatus","jsonParseError","handleSort","_onSort2","_ref41","_x28","_ref42","closeSearchPanel","openSearchPanel","annotations","ChangeSet","fromJSON","EditorSelection","handleAcceptTooLarge","handleSwitchToTreeMode","cancelLoadTooLarge","onChangeCodeMirrorValue","toRichValidationError","setSelection","_event","selectedText","jsmap","jsonSourceMap","pointers","_pointer$value","valueEnd","linter","linterCallback","delay","pointerName","keyEnd","findTextLocation","toRichParseError","toDiagnostic","newContent","forceUpdate","newText","_refresh","_updateTheme","updateTheme","codeMirrorText","reconfigure","repeat","memoizedValidateText","handleShowMe","richParseError","handleSelectParseError","repairActionShowMe","faEye","eq","updateLinter","updateIndentation","updateTabSize","updateReadOnly","repairActions","isNewDocument","onFormat","onCompact","onToggleSearch","canFormat","canCompact","canSort","canTransform","searchItem","editorDisabled","lineNumber","columnNumber","charCount","_editorState","_editorState2","_editorState3","_get30","_get31","_get32","nestedArrayPath","on_click_3","__3","nestedArrayPaths","maxLevel","findNestedArrays","hasNestedArrays","isEmptyDocument","documentType","_get33","countItems","text_5","_get34","_ref44","text_6","flattenColumns","_x29","_handleFocusSearch2","containsValidArray","itemHeightsCache","onSortByHeader","newSortedColumn","newValidationErrors","patchedSortedColumn","handleScroll","createDefaultSelectionWhenUndefined","createDefaultSelection","searchBoxHeight","roughDistance","scrollToHorizontal","headerHeight","scrollToVertical","_get$querySelector3","_get35","resolvedPath","_ref46","_onRenderContextMenu2","_ref45","onEditRow","onDuplicateRow","onInsertBeforeRow","onInsertAfterRow","onRemoveRow","createTableContextMenuItems","handleEditRow","handleDuplicateRow","handleInsertBeforeRow","handleInsertAfterRow","handleRemoveRow","_get36","_get37","handleContextMenuFromTableMenu","_handleParsePastedJson2","_handlePasteFromMenu2","_x30","_handleCut2","_handleCopy2","_ref30","rowPath","_ref31","_ref32","nextRowIndex","nextRowPath","_ref33","newRowIndex","_handleInsertCharacter2","_event$clipboardData2","_unused26","_ref47","handleResizeContents","currentContent","_unused25","newColumns","previousColumns","orderedColumns","newColumnsSet","maintainColumnOrder","showRefreshButton","extendedOperations","unshift","createNestedValueOperations","groupedValidationErrors","_get38","_get39","node_7","columnName","_sortedColumn","sortDirectionName","faCaretUp","onRefresh","faRotate","visibleIndex","validationErrorsByRow","_get40","searchResultByRow","th_3","handleResizeRow","_get41","node_14","$$array","isSelected","validationErrorsByColumn","_get42","searchResultsByCell","containsActiveSearchResult","containsSearchResult","onEdit","_parser$stringify","searchResultItemsByCell","_getInRecursiveState","expression_3","expression_6","td","td_3","_get43","selectPreviousColumn","selectNextColumn","selectPreviousRow","selectNextRow","_x31","externalMode","insideModal","refTreeMode","refTableMode","refTextMode","prevItem","nextItem","modeMenuItems","separatorMenuItem","handleRenderMenu","handleRenderContextMenu","_refresh2","applyExternalMode","updatedItems","updatedItemsOriginal","cloneDeep","modal","_onRenderContextMenu3","itemsOriginal","sortModalStates","contentDefault","selectionDefault","readOnlyDefault","modeDefault","mainMenuBarDefault","navigationBarDefault","statusBarDefault","askToFormatDefault","escapeControlCharactersDefault","escapeUnicodeCharactersDefault","flattenColumnsDefault","parserDefault","validatorDefault","validationParserDefault","pathParserDefault","queryLanguagesDefault","queryLanguageIdDefault","onChangeQueryLanguageDefault","onChangeDefault","onSelectDefault","onRenderValueDefault","onClassNameDefault","onRenderMenuDefault","onRenderContextMenuDefault","onChangeModeDefault","onErrorDefault","alert","onFocusDefault","onBlurDefault","instanceId","refJSONEditorRoot","jsonEditorModalProps","sortModalProps","transformModalProps","previousParser","contentError","_x32","_scrollTo2","_refresh3","updateProps","_props$name","_props$name2","_props$name3","_props$name4","_props$name5","_props$name6","_props$name7","_props$name8","_props$name9","_props$name10","_props$name11","_props$name12","_props$name13","_props$name14","_props$name15","_props$name16","_props$name17","_props$name18","_props$name19","_props$name20","_props$name21","_props$name22","_props$name23","_props$name24","_props$name25","_props$name26","_props$name27","_props$name28","_props$name29","_props$name30","_props$name31","names","unknownProperty","_destroy","toggleMode","_x33","_toggleMode","newMode","_ref49","_ref50","directions","selectedProperty","_$$_import_sortModalS","$$_import_sortModalStates","selectedDirection","_$$_import_sortModalS2","sortError","_get48","_get49","_get50","_get51","_get52","_get53","_get54","refEditor","rootState","determineMode","scrollToSelection","_last","currentState","parentJson","updatedParentContent","updatedParentState","parentState","_get45","updateState","handleChangeSelection","handleChangeMode","handleError","newError","handleJSONEditorModal","_ref48","_get46","nestedModalState","_get44","absolutePath","pathDescription","faCaretLeft","_get55","createJSONEditor","_ref51","editor","JsonEditor","JSONEditor","_ref53"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,58,63,64,65,83,91,92,93,94,95,96,97,98,158]}